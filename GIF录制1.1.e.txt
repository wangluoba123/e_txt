 ' 文件类型：Windows控制台程序

 ' 程序名称：gif录制
 ' 程序描述：gif录制软件,福仔制作
 ' 程序作者：福仔
 ' 邮政编码：
 ' 联系地址：
 ' 联系电话：
 ' 传真号码：
 ' 电子信箱：
 ' 主页地址：
 ' 版权声明：福仔原创作品,转载请注明出处
 ' 版本号：1.0
 ' 创建号：0.0

窗口 _启动窗口 ' 在程序启动后自动调入本窗口
    左边 = 50
    顶边 = 50
    宽度 = 506
    高度 = 339
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 真
    禁止 = 假
    边框 = 1
    底图方式 = 1
    底色 = 16777215 '  0xFFFFFF
    最大化按钮 = 真
    最小化按钮 = 真
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 真
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    窗口类名 = “”
    底图 =  ' 空
    图标 =  ' 已保存到：D:\易语言学习\Data\GIF录制1.1.e\_启动窗口_图标.ico
    背景音乐 =  ' 空
    标题 = “福仔制作,GIF录制小工具 QQ121007124”
    帮助文件名 = “”

窗口 窗口_预览
    左边 = 50
    顶边 = 50
    宽度 = 364
    高度 = 333
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 假
    禁止 = 假
    边框 = 1
    底图方式 = 1
    底色 = 16777215 '  0xFFFFFF
    最大化按钮 = 真
    最小化按钮 = 真
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    窗口类名 = “”
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “”
    帮助文件名 = “”

窗口 窗口_进度
    左边 = 50
    顶边 = 50
    宽度 = 267
    高度 = 77
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 假
    禁止 = 假
    边框 = 0
    底图方式 = 1
    底色 = -16777216 '  0xFF000000
    最大化按钮 = 假
    最小化按钮 = 真
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    窗口类名 = “”
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “”
    帮助文件名 = “”

窗口 窗口_编辑
    左边 = 50
    顶边 = 50
    宽度 = 806
    高度 = 333
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 真
    禁止 = 假

窗口 窗口_设置
    左边 = 50
    顶边 = 50
    宽度 = 244
    高度 = 341
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 假
    禁止 = 假
    边框 = 2
    底图方式 = 1
    底色 = -16777216 '  0xFF000000
    最大化按钮 = 假
    最小化按钮 = 假
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    窗口类名 = “”
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “设置”
    帮助文件名 = “”

窗口 窗口_显示编辑帧
    左边 = 50
    顶边 = 50
    宽度 = 567
    高度 = 417
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 真
    禁止 = 假
    边框 = 1
    底图方式 = 1
    底色 = -16777216 '  0xFF000000
    最大化按钮 = 假
    最小化按钮 = 假
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    窗口类名 = “”
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “”
    帮助文件名 = “”



.图片 资源_选中, " ' 已保存到：D:\易语言学习\Data\GIF录制1.1.e\资源_选中", , 
.常量 常量_正序, "1", , 
.常量 常量_倒序, "2", , 
.常量 常量_版权, "“小软件定制,接单QQ 121007124”", , 
.常量 , , , 
.常量 时钟_录制, "1001", , 
.常量 时钟_预览, "1002", , 
.常量 , , , 
.常量 菜单_录制, "1", , 
.常量 菜单_保存, "2", , 
.常量 菜单_编辑, "3", , 
.常量 , , , 
.常量 SRCCOPY, "13369376", , 
.常量 BITSPIXEL, "12", , 
.常量 , , , 
.常量 OFN_EXPLORER, "524288", , 
.常量 OFN_OVERWRITEPROMPT, "2", , 
.常量 OFN_PATHMUSTEXIST, "2048", , 
.常量 OFN_NOCHANGEDIR, "8", , 
.常量 , , , 
.常量 WS_EX_LAYERED, "524288", , 分层或透明窗口,该样式可使用混合特效
.常量 LWA_COLORKEY, "1", , 
.常量 LWA_ALPHA, "2", , 
.常量 , , , 
.常量 GWL_WNDPROC, "-4", , 为窗口设定一个新的处理函数。
.常量 GWL_EXSTYLE, "-20", , 获取、设定一个新的扩展风格。
.常量 , , , 
.常量 MF_ENABLED, "0", , 使菜单项有效，使该项能被选择，并使其从变灰的状态恢复。
.常量 MF_STRING, "0", , 指定菜单项是一个正文字符串；参数lpNewltem指向该字符串。
.常量 MF_UNCHECKED, "0", , 不放置选取标记在菜单项旁边（缺省）。如果应用程序提供一个选取标记位图（参见SetMenultemBitmaps），则将选取标记位图放置在菜单项旁边。
.常量 MF_GRAYED, "1", , 使菜单项无效并变灰，使其不能被选择。
.常量 MF_DISABLED, "2", , 使菜单项无效，使该项不能被选择，但不使菜单项变灰。
.常量 MF_BITMAP, "4", , 将一个位图用作菜单项。参数lpNewltem里含有该位图的句柄。
.常量 MF_CHECKED, "8", , 在菜单项旁边放置一个选取标记。如果应用程序提供一个选取标记，位图（参见SetMenultemBitmaps），则将选取标记位图放置在菜单项旁边。
.常量 MF_POPUP, "16", , 指定菜单打开一个下拉式菜单或子菜单。参数uIDNewltem下拉式菜单或子菜单的句柄。此标志用来给菜单条、打开一个下拉式菜单或于菜单的菜单项、子菜单或快捷菜单加一个名字。
.常量 MF_MENUBREAK, "64", , 对菜单条的功能同MF_MENUBREAK标志。对下拉式菜单、子菜单或快捷菜单，新列和旧列被垂直线分开。
.常量 MF_OWNERDRAW, "256", , 指定该菜单项为自绘制菜单项。菜单第一次显示前，拥有菜单的窗口接收一个WM_MEASUREITEM消息来得到菜单项的宽和高。然后，只要菜单项被修改，都将发送WM_DRAWITEM消息给菜单拥有者的窗口程序。
.常量 MF_SEPARATOR, "2048", , 画一条水平区分线。此标志只被下拉式菜单、子菜单或快捷菜单使用。此区分线不能被变灰、无效或加亮。参数IpNewltem和uIDNewltem无用。
.常量 , , , 
.常量 TPM_CENTERALIGN, "4", , 若设置此标志，函数将按参数x指定的坐标水平居中放置快捷菜单。
.常量 TPM_LEFTALIGN, "0", , 若设置此标志，函数使快捷菜单的左边界与由参数X指定的坐标对齐。
.常量 MF_MENUBARBREAK, "32", , 对菜单条的功能同MF_MENUBREAK标志。对下拉式菜单、子菜单或快捷菜单，新列和旧列被垂直线分开。
.常量 MF_BYCOMMAND, "0", , 表示参数uIDltem给出菜单项的标识符。如果MF_BYCOMMAND和MF_BYPOSITION都没被指定，则MF_BYCOMMAND是缺省值。
.常量 MF_BYPOSITION, "1024", , 
.常量 WM_MENUCHAR, "288", , 当菜单已被激活用户按下了某个键（不同于加速键），发送此消息给菜单的所有者
.常量 WM_DRAWITEM, "43", , 当button，combobox，listbox，menu的可视外观改变时发送此消息给这些空件的所有者
.常量 WM_MEASUREITEM, "44", , 当button,combobox,listbox,listviewcontrol,ormenuitem被创建时发送此消息给控件的所有者


 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 5 3 系统核心支持库
 ' GIF89a 887FF0B4-0802-452c-BCDD-420B9CC1201E 1 3 GIF动画全操作支持库
 ' iext 27bb20fdd3e145e4bee3db39ddd6e64c 2 0 扩展界面支持库一




数据类型 程序延时, , 
    .成员 成员_时间, 长整数型, , , 占用8个字节

数据类型 OPENFILENAME, , 打开文件名结构
    .成员 结构大小, 整数型, , , win2k以上为88，以下为76
    .成员 窗口句柄, 整数型, , , 
    .成员 实例句柄, 整数型, , , 
    .成员 过滤器, 字节集, , , 
    .成员 自定义过滤器, 文本型, , , 
    .成员 自定义过滤器最大长度, 整数型, , , 
    .成员 过滤器索引, 整数型, , , 
    .成员 文件名, 字节集, , , 
    .成员 文件名最大长度, 整数型, , , 
    .成员 文件标题, 文本型, , , 
    .成员 文件标题最大长度, 整数型, , , 
    .成员 初始目录, 文本型, , , 
    .成员 标题, 文本型, , , 
    .成员 标志, 整数型, , , 
    .成员 文件偏移量, 短整数型, , , 
    .成员 文件扩展名, 短整数型, , , 
    .成员 默认扩展名, 文本型, , , 
    .成员 自定义数据, 整数型, , , 
    .成员 回调函数地址, 整数型, , , 
    .成员 模板名, 整数型, , , 

数据类型 BITMAPINFO, , 
    .成员 BITMAPINFOHEADER, BITMAPINFOHEADER, , , 
    .成员 bmiColors, 整数型, , , RGBQUAD          bmiColors[1]; 

数据类型 BITMAPINFOHEADER, , 
    .成员 biSize, 整数型, , , 
    .成员 biWidth, 整数型, , , 
    .成员 biHeight, 整数型, , , 
    .成员 biPlanes, 短整数型, , , 
    .成员 biBitCount, 短整数型, , , 
    .成员 biCompression, 整数型, , , 
    .成员 biSizeImage, 整数型, , , 
    .成员 biXPelsPerMeter, 整数型, , , 
    .成员 biYPelsPerMeter, 整数型, , , 
    .成员 biClrUsed, 整数型, , , 
    .成员 biClrImportant, 整数型, , , 

数据类型 RECT, , 
    .成员 left, 整数型, , , 
    .成员 top, 整数型, , , 
    .成员 right, 整数型, , , 
    .成员 bottom, 整数型, , , 

数据类型 GUID, 公开, 
    .成员 Data1, 整数型, , , 
    .成员 Data2, 短整数型, , , 
    .成员 Data3, 短整数型, , , 
    .成员 Data4, 字节型, , "8", 

数据类型 GdiplusStartupInput, , 
    .成员 GdiplusVersion, 整数型, , , 
    .成员 DebugEventCallback, 整数型, , , 
    .成员 SuppressBackgroundThread, 整数型, , , 
    .成员 SuppressExternalCodecs, 整数型, , , 

数据类型 POINT, , -
    .成员 x, 整数型, , , 横坐标
    .成员 y, 整数型, , , 纵坐标

数据类型 ICONINFO, , 
    .成员 fIcon, 整数型, , , 
    .成员 hbmMask, 整数型, , , 
    .成员 hbmColor, 整数型, , , 
    .成员 yHotspot, 长整数型, , , 
    .成员 xHotspot, 整数型, , , 

数据类型 CURSORINFO, , 
    .成员 cbSize, 整数型, , , 
    .成员 flags, 整数型, , , 
    .成员 hCursor, 整数型, , , 
    .成员 ptScreenPos, POINTAPI, , , 可能为 POINTAPI 结构。

数据类型 POINTAPI, , 
    .成员 x, 空白型, , , 
    .成员 y, 空白型, , , 

.全局变量 全局_时钟周期, 整数型, , , 
.全局变量 全局_编辑模式, 整数型, , , 
.全局变量 全局_数据组, 字节集, , "0", 
.全局变量 全局_总帧数, 整数型, , , 

.DLL命令 SetLayeredWindowAttributes, 整数型, "", "SetLayeredWindowAttributes", , 此函数用于设置分层窗口透明度，常和 UpdateLayeredWindow 函数结合使用。
    .参数 hwnd, 整数型, , 指定分层窗口句柄
    .参数 crKey, 整数型, , 指定需要透明的背景颜色值，RGB色
    .参数 bAlpha, 字节型, , 设置透明度，0表示完全透明，255表示不透明
    .参数 dwFlags, 整数型, , 透明方式,LWA_ALPHA时：crKey参数无效，bAlpha参数有效；LWA_COLORKEY：窗体中的所有颜色为crKey的地方将变为透明，bAlpha参数无效。其常量值为1。LWA_ALPHA | LWA_COLORKEY：crKey的地方将变为全透明，而其它地方根据bAlpha参数确定透明度。

.DLL命令 GetWindowLongA, 整数型, "user32", "GetWindowLongA", , 
    .参数 hwnd, 整数型, , 窗口句柄及间接给出的窗口所属的窗口类。
    .参数 nlndex, 整数型, , 获取的属性类型,具体去msdn查询

.DLL命令 SetWindowLongA, 整数型, "user32", "SetWindowLongA", , 在窗口结构中为指定的窗口设置信息  指定数据的前一个值
    .参数 hwnd, 整数型, , hwnd，欲为其取得信息的窗口的句柄
    .参数 nIndex, 整数型, , nIndex，请参考GetWindowLong函数的nIndex参数的说明
    .参数 dwNewLong, 整数型, , dwNew由nIndex指定的窗口信息的新值

.DLL命令 CreateWaitableTimerA, 整数型, "", "CreateWaitableTimerA", , 创建一个可等待的计时器对象。如执行成功，返回可等待计时器对象的句柄；零表示出错。会设置GetLastError。即使返回一个有效的句柄，但倘若它指出同名的一个计时器对象已经存在，则GetLastError返回ERROR_ALREADY_EXISTS。
    .参数 lpTimerAttributes, 整数型, , SECURITY_ATTRIBUTES，指定一个结构，用于设置对象的安全特性。如将参数声明为ByVal As Long，并传递零值，就可使用对象的默认安全设置。
    .参数 bManualReset, 逻辑型, , 如果为真，表示创建一个人工重置计时器；如果为FALSE，则创建一个自动重置计时器。
    .参数 lpTimerName, 整数型, , 指定可等待计时器对象的名称。用vbNullString可创建一个未命名的计时器对象。如果已经存在拥有这个名字的一个可等待计时器，就直接打开现成的可等待计时器。这个名字可能不与一个现有的互斥体、事件、信号机或文件映射的名称相符。

.DLL命令 SetWaitableTimer, 整数型, "", "SetWaitableTimer", 公开, 启动一个可等待计时器
    .参数 hTimer, 整数型, , 指明要设置的定时器。
    .参数 pDueTime, 程序延时, , pDueTime和lPeriod两个参数是一道使用的。pDueTime参数用于指明定时器何时应该第一次报时，而lPeriod参数则用于指明此后定时器应该间隔多长时间报时一次.
    .参数 lPeriod, 整数型, , pDueTime和lPeriod两个参数是一道使用的。pDueTime参数用于指明定时器何时应该第一次报时，而lPeriod参数则用于指明此后定时器应该间隔多长时间报时一次.
    .参数 pfnCompletionRoutine, 整数型, , 
    .参数 lpArgToCompletionRoutine, 整数型, , 
    .参数 fResume, 逻辑型, , 

.DLL命令 MsgWaitForMultipleObjects, 整数型, "", "MsgWaitForMultipleObjects", 公开, 等候单个对象或一系列对象发出信号---标志着规定的超时已经过去，或特定类型的消息已抵达线程的输入队列。如返回条件已经满足，则立即返回
    .参数 nCount, 整数型, , 指定列表中的句柄数量
    .参数 pHandles, 整数型, 传址, 指定对象句柄组合中的第一个元素
    .参数 fWaitAll, 逻辑型, , 如果为TRUE，表示除非对象同时发出信号，否则就等待下去。如果为FALSE，表示任何对象发出信号即可。
    .参数 dwMilliseconds, 整数型, , 指定要等待的毫秒数。
    .参数 dwWakeMask, 整数型, , 带有 #QS_ 前缀的一个或多个常数，用于标识特定的消息类型。

.DLL命令 CloseHandle, 逻辑型, "kernel32", "CloseHandle", 公开, 关闭一个内核对象
    .参数 hObject, 整数型, , 欲关闭的一个对象的句柄;

.DLL命令 GetSaveFileNameA, 逻辑型, "Comdlg32", "GetSaveFileNameA", 公开, 该函数创建一个Save公共对话框，以便用户指定驱动器、目录和文件名。成功返回真,失败返回假
    .参数 Ipofn, OPENFILENAME, , 

.DLL命令 GetDC, 整数型, "user32.dll", "GetDC", , 获取DC,如果成功，返回指定窗口客户区的设备上下文环境；如果失败，返回值为Null。
    .参数 hWnd, 整数型, , 设备上下文环境被检索的窗口的句柄，如果该值为NULL，GetDC则检索整个屏幕的设备上下文环境。

.DLL命令 GetDeviceCaps, 整数型, "gdi32", "GetDeviceCaps", , 
    .参数 HDC, 整数型, , 设备上下文环境的句柄。
    .参数 nIndex, 整数型, , 指定返回项，该参数取下列一值。

.DLL命令 CreateCompatibleDC, 整数型, "gdi32.dll", "CreateCompatibleDC", , 该函数创建一个与指定设备兼容的内存设备上下文环境（DC）。通过GetDc()获取的HDC直接与相关设备沟通，而本函数创建的DC，则是与内存中的一个表面相关联。
    .参数 HDC, 整数型, , 现有设备上下文环境的句柄，如果该句柄为NULL，该函数创建一个与应用程序的当前显示器兼容的内存设备上下文环境。

.DLL命令 CreateCompatibleBitmap, 整数型, "gdi32", "CreateCompatibleBitmap", , 
    .参数 hdc, 整数型, , 设备环境句柄。
    .参数 nWidth, 整数型, , 指定位图的宽度，单位为像素。
    .参数 nHeight, 整数型, , 指定位图的高度，单位为像素。

.DLL命令 SelectObject, 整数型, "gdi32", "SelectObject", , 该函数选择一对象到指定的设备上下文环境中，该新对象替换先前的相同类型的对象。
    .参数 hdc, 整数型, , 设备上下文环境的句柄。
    .参数 hgdiobj, 整数型, , 被选择的对象的句柄，该指定对象必须由如下的函数创建。

.DLL命令 BitBlt, 逻辑型, "gdi32", "BitBlt", , 该函数对指定的源设备环境区域中的像素进行位块（bit_block）转换，以传送到目标设备环境。成功返回真,失败返回假
    .参数 hDestDC, 整数型, , 指向目标设备环境的句柄。
    .参数 x, 整数型, , 指定目标矩形区域左上角的X轴逻辑坐标。
    .参数 y, 整数型, , 指定目标矩形区域左上角的Y轴逻辑坐标。
    .参数 nWidth, 整数型, , 指定源在目标矩形区域的逻辑宽度。
    .参数 nHeight, 整数型, , 指定源在目标矩形区域的逻辑高度。
    .参数 hSrcDC, 整数型, , 指向源设备环境的句柄。
    .参数 xSrc, 整数型, , 指定源矩形区域左上角的X轴逻辑坐标。
    .参数 int, 整数型, , 指定源矩形区域左上角的Y轴逻辑坐标。
    .参数 dwRop, 整数型, , 指定光栅操作代码。这些代码将定义源矩形区域的颜色数据，如何与目标矩形区域的颜色数据组合以完成最后的颜色。

.DLL命令 ReleaseDC, 整数型, "user32", "ReleaseDC", , 释放设备上下文环境（DC）供其他应用程序使用,如果释放成功，则返回值为1；如果没有释放成功，则返回值为0。每次调用GetWindowDC和GetDC函数检索公用设备上下文环境之后，应用程序必须调用ReleaseDC函数来释放设备上下文环境。
    .参数 hWnd, 整数型, , 指向要释放的设备上下文环境所在的窗口的句柄。
    .参数 hDC, 整数型, , 指向要释放的设备上下文环境的句柄。

.DLL命令 RtlMoveMemory, 整数型, "", "RtlMoveMemory", , 复制内存
    .参数 Destination, 字节型, 传址, 指向移动目的地址的指针。
    .参数 Source, BITMAPINFOHEADER, , 指向要复制的内存地址的指针。
    .参数 Length, 整数型, , 指定要复制的字节数。

.DLL命令 CopyMemory_int2Bytes, 整数型, "", "RtlMoveMemory", 公开, 复制内存
    .参数 Destination, 字节集, 传址, 指向移动目的地址的指针。
    .参数 字节集指针, 整数型, , 指向要复制的内存地址的指针。
    .参数 数据长度, 整数型, , 指定要复制的字节数。

.DLL命令 CopyMemory_str, 空白型, "kernel32", "RtlMoveMemory", , 
    .参数 Destination, 文本型, 传址, 指向移动目的地址的指针。
    .参数 Source, 整数型, , 指向要复制的内存地址的指针。
    .参数 Length, 整数型, , 指定要复制的字节数。

.DLL命令 GetDIBits, 整数型, "", "GetDIBits", 公开, 起始扫描线与起点有关。除非将BITMAPINFOHEADER结构的biHeight字段设为负值，否则起点就位于左下角
    .参数 aHDC, 整数型, , 定义了与设备有关位图hBitmap的配置信息的一个设备场景的句柄
    .参数 hBitmap, 整数型, , 源位图的句柄。绝对不能将这幅位图选入设备场景
    .参数 nStartScan, 整数型, , 欲复制到DIB中的第一条扫描线的编号
    .参数 nNumScans, 整数型, , 欲复制的扫描线数量
    .参数 lpBits, 字节型, 传址, 指向一个缓冲区的指针。这个缓冲区将用于装载采用DIB格式的信息，但不取回数据（用ByVal传递零值）
    .参数 lpBI, 字节型, 传址, 
    .参数 wUsage, 整数型, , 

.DLL命令 DeleteObject, 逻辑型, "gdi32.dll", "DeleteObject", , 用这个函数删除GDI对象，比如画笔、刷子、字体、位图、区域以及调色板等等。对象使用的所有系统资源都会被释放
    .参数 HGDIOBJ, 整数型, , 一个GDI对象的句柄

.DLL命令 DeleteDC, 逻辑型, "gdi32", "DeleteDC", , 该函数删除指定的设备上下文环境（Dc）。如果一个设备上下文环境的句柄是通过调用GetDC函数得到的，那么应用程序不能删除该设备上下文环境，它应该调用ReleaseDC函数来释放该设备上下文环境。
    .参数 HDC, 整数型, , 设备上下文环境的句柄。

.DLL命令 GetWindowRect, 逻辑型, "user32", "GetWindowRect", , 
    .参数 hWnd, 整数型, , 窗口句柄。
    .参数 lpRect, RECT, 传址, 指向一个RECT结构的指针，该结构接收窗口的左上角和右下角的屏幕坐标。

.DLL命令 lstrcpy_bin, 整数型, "kernel32", "lstrcpyA", , 复制字符串
    .参数 lpString1, 字节集, 传址, 指向接收由参数lpString2指向字符串内容的缓冲区。缓冲区必须足够大来容纳字符串，还包括最后的NULL终止符。
    .参数 lpString2, 字节集, 传址, 指向待复制的以NULL为终止符的字符串。

.DLL命令 CreateThread, 整数型, "", "CreateThread", , 创建一个新线程。微软在Windows API中提供了建立新的线程的函数CreateThread。
    .参数 lpThreadAttributes, 整数型, , 指向SECURITY_ATTRIBUTES型态的结构的指针。在Windows 98中忽略该参数。在Windows NT中，NULL使用默认安全性，不可以被子线程继承，否则需要定义一个结构体将它的bInheritHandle成员初始化为TRUE
    .参数 dwStackSize, 整数型, , 设置初始栈的大小，以字节为单位，如果为0，那么默认将使用与调用该函数的线程相同的栈空间大小。任何情况下，Windows根据需要动态延长堆栈的大小。
    .参数 lpStartAddress, 子程序指针, , 指向线程函数的指针
    .参数 lpParameter, 整数型, , 向线程函数传递的参数
    .参数 dwCreationFlags, 整数型, , 线程标志 CREATE_SUSPENDED：创建一个挂起的线程，0：表示创建后立即激活。STACK_SIZE_PARAM_IS_A_RESERVATION：dwStackSize参数指定初始的保留堆栈 的大小，否则,dwStackSize指定提交的大小。该标记值在Windows 2000/NT and Windows Me/98/95上不支持。
    .参数 lpThreadId, 整数型, 传址, 保存新线程的id。

.DLL命令 GetExitCodeThread, 整数型, "kernel32.dll", "GetExitCodeThread", , 获取一个已中止线程的退出代码
    .参数 hThread, 整数型, , 想获取退出代码的一个线程的句柄
    .参数 lpExitCode, 整数型, , 用于装载线程退出代码的一个长整数变量。如线程尚未中断，则设为常数STILL_ACTIVE

.DLL命令 TerminateThread, 逻辑型, "", "TerminateThread", , 终止一个线程，用于强制终止线程。
    .参数 hThread, 整数型, , 被终止的线程的句柄
    .参数 dwExitCode, 整数型, , 退出码。填0

.DLL命令 GlobalLock, 整数型, "kernel32.dll", "GlobalLock", , 锁定可移动内存，成功返回一个内存块的指针,否则返回0
    .参数 hMem, 整数型, , 内存块句柄,一般是先前用GlobalAlloc函数申请到的可移动内存块.

.DLL命令 CreateStreamOnHGlobal, 整数型, "ole32", "CreateStreamOnHGlobal", , 从指定内存创建流对象。
    .参数 hGlobal, 整数型, , 由GlobalAlloc函数分配的内存句柄。
    .参数 fDeleteOnRelease, 逻辑型, , 该参数指明上一个参数制定的内存在该对象被释放后是否也自动释放。如果该参数设定为FALSE，那么调用者必须显式的释放hGlobal。如果该参数设置为TRUE，则hGlobal最终会自动释放。
    .参数 ppstm, 整数型, 传址, IStream指针的地址，该指针在该函数执行后指向新创建的流对象。该参数不能为NULL。

.DLL命令 GlobalAlloc, 整数型, "kernel32.dll", "GlobalAlloc", , 申请在堆中分配一块内存，成功返回值是一个指向内存块指针或内存块句柄,否则返回0.
    .参数 uFlags, 整数型, , 分配属性(方式)
    .参数 dwBytes, 整数型, , 分配的字节数

.DLL命令 CLSIDFromString, 整数型, "ole32", "CLSIDFromString", , 
    .参数 lpsz, 字节集, , 宽字节字符集指针。注意一定是宽字节字符集的。 
    .参数 pclsid, GUID, , CLSID指针。也就是指向16B缓冲区的指针。

.DLL命令 MultiByteToWideChar, 整数型, "", "MultiByteToWideChar", , 该函数映射一个字符串到一个宽字符（unicode）的字符
    .参数 CodePage, 整数型, , 指定执行转换的字符集，这个参数可以为系统已安装或有效的任何字符集所给定的值。
    .参数 dwFlags, 整数型, , 一组位标记用以指出是否未转换成预作或宽字符（若组合形式存在），是否使用象形文字替代控制字符，以及如何处理无效字符。
    .参数 lpMultiByteStr, 文本型, , 指向将被转换字符串的字符。
    .参数 cchMultiByte, 整数型, , 指定由参数lpMultiByteStr指向的字符串中字节的个数。如果lpMultiByteStr指定的字符串以空字符终止，可以设置为-1（如果字符串不是以空字符中止，设置为-1可能失败，可能成功），此参数设置为0函数将失败。
    .参数 lpWideCharStr, 字节集, , 指向接收被转换字符串的缓冲区。
    .参数 cchWideChar, 整数型, , 指定由参数lpWideCharStr指向的缓冲区的宽字符个数。若此值为零，函数返回缓冲区所必需的宽字符数，在这种情况下，lpWideCharStr中的缓冲区不被使用。

.DLL命令 GdiplusStartup, 整数型, "gdiplus.dll", "GdiplusStartup", 公开, GDI启动 图像转换类
    .参数 token, 整数型, 传址, 第一个参数是指向一个32位的无符号整型的指针，也就是指向一个汇编中的DWORD变量的指针，用于接受GDI+的TOKEN.TOKEN可以暂时理解成一个句柄，就像窗口的句柄类似。这个参数在调用GdiplusShutdown的时候用到。这个函数在结束GDI+编程后调用，起作用是释放GDI+的资源。
    .参数 inputbuf, GdiplusStartupInput, , 
    .参数 outputbuf, 整数型, , 

.DLL命令 GlobalUnlock, 逻辑型, "kernel32.dll", "GlobalUnlock", , 解锁指定的内存块
    .参数 hMem, 整数型, , 可移动内存块句柄,一般是先前用GlobalAlloc函数申请到的内存块.

.DLL命令 lstrcpyn, 整数型, "kernel32.dll", "lstrcpyn", 公开, 取指针地址
    .参数 lpString1, 通用型, 传址, 指向一个缓冲区，以存储第二参数的内容。需足够长以容纳第三参数设定的TCHAR值，以及NULL结束符“\0”；
    .参数 lpString2, 通用型, 传址, 指向以NULL结尾"\0"的字符串；
    .参数 iMaxLength, 整数型, , 指定从第二参数复制至第一参数内容的大小，包括NULL结束符"\0"（谨记bytes字节数对应ANSI 版本以及WCHAR值对应Unicode版本）。

.DLL命令 GDIpCreateBitmapFromStream, 整数型, "gdiplus.dll", "GdipCreateBitmapFromStream", , 图像转换类
    .参数 stream, 整数型, , 图像转换类
    .参数 bitmap, 整数型, 传址, 

.DLL命令 GdipSaveImageToStream, 整数型, "GdiPlus.dll", "GdipSaveImageToStream", , 
    .参数 image, 整数型, , 
    .参数 stream, 整数型, , 
    .参数 clsidEncoder, GUID, , 
    .参数 encoderParams, 整数型, , 

.DLL命令 GetHGlobalFromStream, 整数型, "ole32", "GetHGlobalFromStream", , 
    .参数 pstm, 整数型, , 0
    .参数 phglobal, 整数型, 传址, 

.DLL命令 GlobalSize, 整数型, "kernel32.dll", "GlobalSize", , 获取指定内存块的大小
    .参数 hMem, 整数型, , 指向一个内存块的指针,一般是先前用GlobalAlloc函数或GlobalReAlloc函数返回的值.

.DLL命令 GlobalFree, 整数型, "kernel32.dll", "GlobalFree", , 释放掉,先前申请一块固定的内存块
    .参数 hMem, 整数型, , 指向一个内存块的指针,一般是先前用GlobalAlloc函数申请到的内存块.

.DLL命令 GdipDisposeImage, 整数型, "GdiPlus.dll", "GdipDisposeImage", , 
    .参数 Image, 整数型, , 

.DLL命令 GdiplusShutdown, 空白型, "gdiplus.dll", "GdiplusShutdown", 公开, _GDI关闭
    .参数 token, 整数型, , 

.DLL命令 SetTimer, 逻辑型, "user32.dll", "SetTimer", , 用指定的暂停数值产生一个定时器，一般用WM_TIMER来设置定时器
    .参数 句柄, 整数型, , 指定窗口句柄,此参数不为零时lpTimerFunc参数必须为空.如果此参数为NULL,那么nIDEvent参数将被忽略.
    .参数 标识, 整数型, , 定时器ID，多个定时器时，可以通过该ID判断是哪个定时器，如果没有指定的ID定时器，那么一个新的定时器被产生．
    .参数 周期, 整数型, , 指定时间间隔的数值(以毫秒为单位)．
    .参数 事件, 子程序指针, , 回调函数(指定调用的子程序或函数,可以为空).

.DLL命令 CallWindowProcA, 整数型, "user32.dll", "CallWindowProcA", , 呼叫窗口函数地址
    .参数 lpPrevWndFunc, 整数型, , 前一窗口函数地址
    .参数 hWnd, 整数型, , 窗口句柄
    .参数 Msg, 整数型, , 消息值
    .参数 wParam, 整数型, , 附加参数1
    .参数 lParam, 整数型, , 附加参数2

.DLL命令 FindWindowA, 整数型, "user32.dll", "FindWindowA", , 寻找窗口句柄
    .参数 lpClassName, 文本型, , 窗口类名
    .参数 lpWindowName, 文本型, , 窗口标题

.DLL命令 CreateMenu, 整数型, "user32", "CreateMenu", , CreateMenu函数创建一个弹出式菜单。此菜单最初是空的，但可用函数InsertMenuItem，AppendMenu，和lnsertMenu来填入菜单项。

.DLL命令 AppendMenu, 整数型, "user32", "AppendMenuA", , 一种可以在指定的菜单条、下拉式菜单、子菜单或快捷菜单的末尾追加一个新菜单项的函数。该函数在指定的菜单条、下拉式菜单、子菜单或快捷菜单的末尾追加一个新菜单项。此函数可指定菜单项的内容、外观和性能。函数AppendMenu己被lnsertMenultem取代。但如果不需要lnsertMenultem的扩展特性，仍可使用AppendMenu。
    .参数 hMenu, 整数型, , 将被修改的菜单条、下拉式菜单、子菜单、或快捷菜单的句柄。
    .参数 wFlags, 整数型, , 控制新菜单项的外观和性能的标志。此参数可以是备注里所列值的组合。
    .参数 wIDNewItem, 整数型, , 指定新菜单项的标识符，或者当uFlags设置为MF_POPUP时，表示下拉式菜单或子菜单的句柄。
    .参数 lpNewItem, 文本型, , 指定新菜单项的内容。此参数的含义取决于参数uFlags是否包含MF_BITMAP, MF_OWNERDRAW或MF_STRING标志，

.DLL命令 CreatePopupMenu, 整数型, "user32", "CreatePopupMenu", , 如果函数调用成功，返回值是新创建菜单的句柄。如果函数调用失败，返回值是NULL。若想获得更多的错误信息，请调用GetLastError函数。该函数创建一个下拉式菜单、子菜单或快捷菜单。此菜单最初是空的，但可用函数InsertMenultem来插入或追加菜单项。也可用函数InsertMenu来插入菜单项，用AppendMenu来追加菜单项。

.DLL命令 SetMenu, 逻辑型, "user32", "SetMenu", , 如果函数调用成功，返回非零值；如果函数调用失败，返回值是零。若想获得更多的错误信息，请调用GetLastError函数。窗口被重画来反映菜单的修改。函数SetMenu替换原来的菜单（如果存在），但并不将其销毁。应用程序必须调用函数DestroyMenu来销毁菜单。
    .参数 hWnd, 整数型, , 菜单被分配到其中的窗口的句柄。
    .参数 hMenu, 整数型, , 新菜单的句柄。如果菜单参数为NULL，则窗口的当前菜单被删除。

.DLL命令 TrackPopupMenu, 整数型, "user32.dll", "TrackPopupMenu", , 在屏幕的任意地方显示一个弹出式菜单
    .参数 hMenu, 整数型, , 弹出式菜单的句柄
    .参数 uFlags, 整数型, , 位置标志和鼠标追踪标志的组合
    .参数 x, 整数型, , 这个点指定了弹出式菜单在屏幕坐标系统中的位置
    .参数 y, 整数型, , 这个点指定了弹出式菜单在屏幕坐标系统中的位置
    .参数 NReserved, 整数型, , 未使用，设为零
    .参数 HWnd, 整数型, , 用于接收弹出式菜单命令的窗口的句柄。应该使用窗体的窗口句柄――窗体中有一个菜单能象弹出式菜单那样接收相同的命令ID集
    .参数 PrcRect, 空白型, , 用屏幕坐标定义的一个矩形，如用户在这个矩形的范围内单击，则弹出式菜单不会关闭。如单击弹出式菜单之外的任何一个地方，则会关闭菜单。可以设为NULL

.DLL命令 GetCursorPos, 整数型, "user32", "GetCursorPos", , 如果成功，返回值非零；如果失败，返回值为零。若想获得更多错误信息，请调用GetLastError函数。
    .参数 lpPoint, POINT, , 坐标结构

.DLL命令 GetMenuItemID, 整数型, "user32", "GetMenuItemID", , 
    .参数 hMenu, 整数型, , 0
    .参数 nPos, 整数型, , 0

.DLL命令 GetMenuStringA, 整数型, "user32", "GetMenuStringA", , 如果函数调用成功，返回值是拷贝到缓冲区的字符数，不包括末尾‘\0’结束符：如果函数调用失败，返回值是零。
    .参数 hMenu, 整数型, , 菜单句柄。
    .参数 uIDItem, 整数型, , 指定将被修改的菜单项，其含义由参数uFlag决定。
    .参数 lpString, 文本型, , 指向缓冲区的指针，该缓冲区接受以`\0’结束的字符串。如果此参数为NULL，则函数返回菜单字符串的长度。
    .参数 nMaxCount, 整数型, , 指定将被拷贝的字符串的最大字符数。如果字符串长度比此参数指定的最大值还大，则多余的字符被截去。如果此参数为0，则函数退回菜单字符串的长度。
    .参数 uFlag, 整数型, , 指定参数ulDltem如何被解释。

.DLL命令 ModifyMenuA, 逻辑型, "user32", "ModifyMenuA", , ModifyMenu，该参数修改已存在的菜单项，并指定菜单项的内容、外观和性能。
    .参数 hMnu, 整数型, , 将被修改的菜单的句柄。
    .参数 uPosition, 整数型, , 指定将被修改的菜单项，其含义由参数UFlags决定。
    .参数 uFlags, 整数型, , 指定控制参数uPosition的解释的标志、菜单项的内容、外观和性能。此参数必须为下列值之一和列于备注里的一个值的组合。
    .参数 uIDNewItem, 整数型, , 指定被修改菜单项的标识符，或者当参数uFlags设置为MF_POPUP时，指定下拉式菜单或子菜单的句柄。
    .参数 lpNewItem, 文本型, , 指定被修改菜单项的内容。其含义依赖于参数UFlags是否包含标志MF_BITMAP,MF_OWNERDRAW或MF_STRING。

.DLL命令 GetLastError, 整数型, "", "GetLastError", , 

.DLL命令 GetMenuItemCount, 整数型, "user32", "GetMenuItemCount", , 
    .参数 hMenu, 整数型, , 0

.DLL命令 GetSubMenu, 整数型, "user32", "GetSubMenu", , 
    .参数 hMenu, 整数型, , 0
    .参数 nPos, 整数型, , 0

.DLL命令 GetMenuState, 整数型, "user32", "GetMenuState", , 
    .参数 hMenu, 整数型, , 0
    .参数 uId, 整数型, , 0
    .参数 uFlags, 整数型, , 0

.DLL命令 GetCursorInfo, 整数型, "user32", "GetCursorInfo", , 取整个桌面任意位置的鼠标句柄
    .参数 piconinfo, CURSORINFO, 传址, CURSORINFO 里嵌套一个 point类型   .hcursor '鼠标句柄

.DLL命令 DrawIcon, 整数型, "user32", "DrawIcon", , 如果函数成功，返回值是非零；如果函数失效，返回值是零。想获得更多的错误信息，请调用GetLastError函数。
    .参数 hdc, 整数型, , 窗口设备上下文的句柄。
    .参数 x, 整数型, , 指定图标左上角的逻辑X坐标。
    .参数 y, 整数型, , 指定图标左上角的逻辑Y坐标。
    .参数 hIcon, 整数型, , 被绘制图标的句柄。图标资源必须已经通过Loadlcon或Loadlmage函数被装载过。

.DLL命令 SetMenuItemBitmaps, 逻辑型, "user32", "SetMenuItemBitmaps", , 成功真 失败返回假
    .参数 hMenu, 整数型, , 菜单句柄
    .参数 uPosition, 整数型, , 指定将被修改的菜单项，其含义由参数UFlags决定。
    .参数 uFlags, 整数型, , 如果第三个参数的取值为MF_BYPOSITION，即使用位置索引，那么第二个参数为菜单项位置索引；如果第三个参数的取值为MF_BYCOMMAND，那么第二个参数为菜单项标示，应该使用该菜单项的ID
    .参数 hBitmapUnchecked, 整数型, , CBitmap类的指针，用来设置与菜单项关联的两个位图，菜单项未被选中时的位图
    .参数 hBitmapChecked, 整数型, , CBitmap类的指针，用来设置与菜单项关联的两个位图，菜单项被选中之后的显示的位图。

.DLL命令 KillTimer, 逻辑型, "user32.dll", "KillTimer", , 用指定的暂停数值产生一个定时器，一般用WM_TIMER来设置定时器
    .参数 句柄, 整数型, , 对与指定的定时器有关的窗囗句柄。
    .参数 标识, 整数型, , 指定要破坏的定时器。1.如果被传给 SetTimer 的窗囗柄是有效的，这一个叁数一定相同于被传给 SetTimer 的 nIDEvent 数值。 2.如果应用程序用对零的 hWnd 组呼叫 SetTimer ，这一个叁数一定是被 SetTimer 返回的定时器识别符。

.DLL命令 SetCapture, 整数型, "user32", "SetCapture", , 捕获鼠标
    .参数 hWnd, 整数型, , 0

.DLL命令 ReleaseCapture, 逻辑型, "user32", "ReleaseCapture", , 释放鼠标

.DLL命令 lstrlenA, 整数型, "kernel32", "lstrlenA", , 
    .参数 lpString, 整数型, , 0

.窗口程序集 程序集_启动窗口, , , 

.程序集变量 程序集_动画, 未知类型0x20003, , , 
.程序集变量 程序集_尺寸, 整数型, , , 记录加入数组的图片总大小
.程序集变量 程序集_路径, 文本型, , , 超过预设内存大小后写到本地的路径
.程序集变量 程序集_帧信息, 未知类型0x20002, , "0", 
.程序集变量 窗口信息, 整数型, , , 
.程序集变量 程序集_帧, 整数型, , , 每秒要录制多少帧
.程序集变量 程序集_是否录制鼠标, 逻辑型, , , 看名字就能看出来什么功能
.程序集变量 程序集_录制区域, RECT, , , 要录制的区域,有全屏和图片框的位置
.子程序 __启动窗口_创建完毕, 空白型, , 软件制作,接单QQ 121007124
.局部变量 获取版本, 文本型, , , 
.局部变量 局部_动画信息, 未知类型0x20001, , , 
.局部变量 局部_任务栏句柄, 整数型, , , 
.局部变量 局部_矩形, RECT, , , 

 ' 置错误提示管理 (&程序错误管理)
载入 (窗口_进度, _启动窗口, 假)
载入 (窗口_预览, _启动窗口, 假)
载入 (窗口_设置, _启动窗口, 假)
调整层次 (#最高层)
菜单_创建 ()
恢复窗口位置 ()
赋值 (窗口信息, SetWindowLongA (取窗口句柄 (), #GWL_WNDPROC, 到整数 (&窗口消息处理)))
禁止按钮 ()
子程序_创建数据库 ()
子程序_设置透明 ()
赋值 (程序集_是否录制鼠标, 等于 (读配置 (“录制鼠标”, 1), “1”))

.子程序 窗口消息处理, 整数型, , 
.参数 窗口句柄, 整数型, , 
.参数 消息值, 整数型, , 
.参数 参数1, 整数型, , 
.参数 参数2, 整数型, , 

.局部变量 i, 整数型, , , 
.局部变量 局部_公用, 整数型, , , 

.判断开始 (并且 (等于 (消息值, 274), 或者 (等于 (参数1, 61488), 等于 (参数1, 61490)))) ' 点击最大化按钮  和双击标题栏
    返回 (0) ' 不知道什么情况,有时候最大化还原后标题栏也透明了,无法点击,所以干脆屏蔽掉最大化
     ' 输出调试文本 (“点击按钮”)
.判断 (并且 (等于 (消息值, 274), 或者 (等于 (参数1, 61730), 等于 (参数1, 61728)))) ' 双击还原  和点击按钮还原
     ' 输出调试文本 (“双击还原”)
.判断 (并且 (等于 (消息值, 273), 等于 (参数2, 0)))
    .判断开始 (并且 (大于或等于 (参数1, 3), 小于或等于 (参数1, 6))) ' 那几个选择帧数的菜单项
        .变量循环首 (3, 6, 1, i)
            .判断开始 (等于 (i, 参数1))
                菜单_置状态 (i, 8) ' 相当于单选的状态
                写配置 (“菜单帧”, 参数1)
            .默认
                菜单_置状态 (i, 0) ' 相当于单选的状态
            .判断结束
            
        .变量循环尾 ()
        赋值 (程序集_帧, 到整数 (菜单_取标题 (参数1)))
    .判断 (等于 (参数1, 9)) ' 设置
        赋值 (窗口_设置., 真)
    .判断 (等于 (参数1, 1)) ' 新建
        子程序_清空 ()
    .判断 (等于 (参数1, 8)) ' 全屏
         ' 菜单_添加图标 (#菜单_录制, 参数1)
        赋值 (局部_公用, 选择 (等于 (菜单_取状态 (参数1), 8), 0, 8))
        菜单_置状态 (参数1, 局部_公用)
        写配置 (“菜单全屏”, 局部_公用)
    .判断 (等于 (参数1, 12)) ' 正序保存
        启动线程_ (&子程序_保存, #常量_正序)
    .判断 (等于 (参数1, 13)) ' 倒序保存
        启动线程_ (&子程序_保存, #常量_倒序)
    .判断 (等于 (参数1, 14)) ' 删除当前帧
        _删除当前帧_被选择 ()
    .判断 (等于 (参数1, 15)) ' 删除第一帧到当前帧
        _删除从当前帧到开始_被选择 ()
    .判断 (等于 (参数1, 16)) ' 删除从当前帧最后一帧
        _删除从当前帧到结束_被选择 ()
    .默认
        
    .判断结束
    
.判断 (等于 (消息值, #WM_MENUCHAR))
     ' 输出调试文本 (到文本 (消息值) ＋ “ | ” ＋ 到文本 (参数1) ＋ “ | ” ＋ 到文本 (参数2))
    
.判断 (等于 (消息值, #WM_DRAWITEM))
    输出调试文本 (相加 (到文本 (消息值), “ | ”, 到文本 (参数1), “ | ”, 到文本 (参数2)))
    
.判断 (等于 (消息值, #WM_MEASUREITEM))
    输出调试文本 (相加 (到文本 (消息值), “ | ”, 到文本 (位与 (参数2, 65536)), “ | ”, 到文本 (右移 (参数2, 16))))
    
.默认
    
.判断结束
返回 (CallWindowProcA (窗口信息, 窗口句柄, 消息值, 参数1, 参数2))

.子程序 子程序_创建数据库, 空白型, , 
.局部变量 局部_字段, 字段信息, , "1", 

赋值 (程序集_路径, 取临时文件名 ())
赋值 (局部_字段 [1].名称, “图片”)
赋值 (局部_字段 [1].类型, #字节集型)
.如果真 (或者 (等于 (创建 (程序集_路径, 局部_字段), 假), 等于 (打开 (程序集_路径, “图片”, , , , , ), 假)))
    信息框 (“初始化失败”, 0, , )
    结束 ()
.如果真结束


.子程序 程序错误管理, 空白型, , 软件制作,接单QQ 121007124
.参数 错误代码, 整数型, , 
.参数 错误文本, 文本型, , 

信息框 (相加 (#常量_版权, #换行符, #换行符, “卧槽,程序出错了,看来还是有bug啊,欢迎提交bug,QQ121007124”, #换行符, #换行符, “错误代码：”, 到文本 (错误代码), #换行符, “错误文本：”, 错误文本), #信息图标, #常量_版权, _启动窗口)
结束 ()

.子程序 恢复窗口位置, 空白型, , 软件制作,接单QQ 121007124
.局部变量 rect, RECT, , , 
.局部变量 i, 整数型, , , 
.局部变量 局部_录制区域, 整数型, , , 

赋值 (rect.right, 到整数 (读配置 (“宽度”, 480)))
赋值 (rect.bottom, 到整数 (读配置 (“高度”, 340)))
赋值 (rect.left, 到整数 (读配置 (“左边”, )))
.如果真 (小于 (rect.left, 0))
    赋值 (rect.left, 相除 (相减 (取屏幕宽度 (), _启动窗口.), 2))
.如果真结束
赋值 (rect.top, 到整数 (读配置 (“顶边”, )))
.如果真 (小于 (rect.top, 0))
    赋值 (rect.top, 相除 (相减 (取屏幕高度 (), _启动窗口.), 2))
.如果真结束
移动 (rect.left, rect.top, rect.right, rect.bottom)
菜单_置状态 (到整数 (读配置 (“菜单帧”, 4)), 8)
赋值 (局部_录制区域, 到整数 (读配置 (“菜单全屏”, )))
菜单_置状态 (8, 局部_录制区域)
.判断开始 (等于 (局部_录制区域, 8))
    赋值 (程序集_录制区域.left, 0)
    赋值 (程序集_录制区域.top, 0)
    赋值 (程序集_录制区域.right, 取屏幕宽度 ())
    赋值 (程序集_录制区域.bottom, 取屏幕高度 ())
.默认
    
.判断结束
赋值 (程序集_帧, 到整数 (菜单_取标题 (4)))

.子程序 __启动窗口_尺寸被改变, 空白型, , 
0.移动 (相加 (., .), 取用户区宽度 (), 相减 (取用户区高度 (), ., .))

.子程序 时钟事件_录制, 空白型, , 
.局部变量 rect, RECT, , , 
.局部变量 局部_图片, 字节集, , , 
.局部变量 局部_帧信息, 未知类型0x20002, , , 
.局部变量 上次数据, 字节集, 静态, , 
.局部变量 局部_尺寸, 整数型, , , 

.判断开始 (等于 (菜单_取状态 (8), 8))
    赋值 (rect, 程序集_录制区域) ' 全屏的话就是固定的,所以不用重新取
.默认
    GetWindowRect (取窗口句柄 (), rect) ' 因为窗口有可能会移动,所以 每次截图前都要取一下位置
.判断结束
赋值 (局部_图片, 截图 (rect, 2, 程序集_是否录制鼠标)) ' 最好要转换格式,不然录制一张图片会很大 打图片的话 写入读出数据库都会慢很多
赋值 (局部_尺寸, 取字节集长度 (局部_图片))
赋值 (程序集_尺寸, 相加 (程序集_尺寸, 局部_尺寸)) ' 记录一下大小
赋值 (局部_帧信息., 相除 (全局_时钟周期, 10)) ' 单位为  1/100秒,所以要1000毫秒除以10
赋值 (局部_帧信息., 相减 (rect.right, rect.left)) ' 确定录制的宽高 这里有点中英文结合  看起来还真不是特别好看
赋值 (局部_帧信息., 相减 (rect.bottom, rect.top)) ' 宽度=右边-左边  高度=底边-顶边
赋值 (局部_帧信息., #)
赋值 (局部_帧信息., #绿色)
.判断开始 (并且 (等于 (局部_图片, 上次数据), 大于 (取数组成员数 (程序集_帧信息), 0)))
    赋值 (程序集_尺寸, 相减 (程序集_尺寸, 局部_尺寸)) ' 不写出数据就把尺寸给减掉刚刚加的
    赋值 (程序集_帧信息 [取数组成员数 (程序集_帧信息)]., 相加 (程序集_帧信息 [取数组成员数 (程序集_帧信息)]., 相除 (全局_时钟周期, 10)))
     ' 如果截图的数据跟上一次截图一样,那就只把图片的帧延时给增加,不把截图数据加到gif数据里
    赋值 (., 相加 (“当前帧数:”, 到文本 (全局_总帧数), “  延时:”, 到文本 (程序集_帧信息 [取数组成员数 (程序集_帧信息)].)))
    返回 ()
.判断 (或者 (大于或等于 (程序集_尺寸, 相乘 (1024, 1024, 到整数 (窗口_设置..内容))), 窗口_设置..选中)) ' 加入到数组成员实际是加入到内存中,如果内存里的数据大于5M,那就写到本地
    .如果真 (或者 (等于 (加空记录 (), 假), 等于 (写 (“图片”, 局部_图片), 假)))
        输出调试文本 (“加入失败”)
    .如果真结束
    
    输出调试文本 (相加 (“写到本地 | ”, 到文本 (取整 (相除 (程序集_尺寸, 1024, 1024))), “/MB | 每张图:”, 到文本 (取整 (相除 (局部_尺寸, 1024))), “/KB”))
.默认
    加入成员 (全局_数据组, 局部_图片) ' 把截图数据写到内存
    输出调试文本 (相加 (“写到内存 | ”, 到文本 (取整 (相除 (程序集_尺寸, 1024, 1024))), “/MB | 每张图:”, 到文本 (取整 (相除 (局部_尺寸, 1024))), “/KB”))
.判断结束
加入成员 (程序集_帧信息, 局部_帧信息) ' 每次截图都把帧信息加到数组,然后在生成图片的时候在取出来
赋值 (全局_总帧数, 相加 (全局_总帧数, 1))
赋值 (上次数据, 局部_图片)
赋值 (., 相加 (“当前帧数:”, 到文本 (全局_总帧数), “  延时:”, 到文本 (程序集_帧信息 [取数组成员数 (程序集_帧信息)].)))
 ' 标题 ＝ “当前帧数:” ＋ 到文本 (取数组成员数 (全局_数据组)) ＋ “  延时:” ＋ 到文本 (全局_时钟周期 ÷ 10)

.子程序 子程序_保存, 逻辑型, , 软件制作,接单QQ 121007124
.参数 参数一, 整数型, , 

.局部变量 局部_图片数据, 字节集, , , 从数组或数据库取出来的图片
.局部变量 局部_动画信息, 未知类型0x20001, , , 
.局部变量 局部_文件路径, 文本型, , , 保存的路径
.局部变量 i, 整数型, , , 
.局部变量 局部_帧计次, 整数型, , , 我在计次循环里自己做了一个计次,各位"大神"不要笑话我
.局部变量 局部_结果, 逻辑型, , , 
.局部变量 局部_递增, 整数型, , , -1往前跳  1 往后跳, 只能赋值 1 或 -1
.局部变量 局部_开始, 整数型, , , 要么从1开始  要么从数组的最大成员数开始
.局部变量 局部_结束, 整数型, , , 要么到1结束  要么到数组的最大成员数结束
.局部变量 局部_计次, 整数型, , , 暂时不知道拿什么来计次了,进度条也要一个计次...

赋值 (局部_文件路径, 保存文件 ()) ' 这里载入了一个窗口,现在我是在线程内调用组件,有可能会崩溃,懒得改了
.如果真 (等于 (局部_文件路径, “”))
    返回 (假)
.如果真结束
赋值 (局部_动画信息., 全局_总帧数)
赋值 (局部_动画信息., 相减 (程序集_录制区域.right, 程序集_录制区域.left))
赋值 (局部_动画信息., 相减 (程序集_录制区域.bottom, 程序集_录制区域.top))
赋值 (局部_动画信息., 真)
赋值 (局部_动画信息., 真)
.判断开始 ()

.子程序 子程序_加入动画帧, 空白型, , 
.参数 图片数据, 字节集, , 
.参数 帧索引, 整数型, ,  ' 帧信息的话,不能用循环的计次,否则有数据写到本地,那么读取的帧信息会不准确
.参数 进度计次, 整数型, , 

程序集_动画.未知支持库函数_3 (程序集_帧信息 [帧索引], , 图片数据) ' 帧信息的话,不能用循环的计次,否则有数据写到本地,那么读取的帧信息会不准确
赋值 (窗口_进度..位置, 取整 (相乘 (相除 (进度计次, 全局_总帧数), 窗口_进度..最大位置)))
 ' 输出调试文本 (到文本 (窗口_进度.进度条1.最大位置) ＋ “最大位置 | 当前位置:” ＋ 到文本 (窗口_进度.进度条1.位置))

.子程序 __启动窗口_将被销毁, 空白型, , 
.局部变量 i, 整数型, , , 
.局部变量 局部_菜单状态, 文本型, , , 

子程序_清空 ()
程序集_动画.未知支持库函数_1 () ' 释放内存资源,一定要释放,不然内存里会堆很多垃圾
删除文件 (程序集_路径) ' 删除数据库文件,每次启动都重新在临时文件夹里创建一个新的数据库,每次关闭都删除这个数据库
写配置 (“左边”, _启动窗口.)
写配置 (“顶边”, _启动窗口.)
写配置 (“宽度”, _启动窗口.)
写配置 (“高度”, _启动窗口.)

.子程序 子程序_清空, 空白型, , 清空内存和本地里的数据,不然在点录制的时候会把之前录制的数据带上
0.置标题 (“录制”)
清除数组 (全局_数据组)
清除数组 (程序集_帧信息)
KillTimer (取窗口句柄 (), #时钟_录制)
连续赋值 (0, 程序集_尺寸, 全局_总帧数)
清空 ()
赋值 (., 相加 (“当前帧数:”, 到文本 (取数组成员数 (全局_数据组))))
禁止按钮 ()

.子程序 禁止按钮, 空白型, , 软件制作,接单QQ 121007124
.局部变量 i, 整数型, , , 

.计次循环首 (相减 (取按钮数 (), 1), i) ' 除去第一个按钮不禁止
    .判断开始 (等于 (全局_总帧数, 0))
        i.加入状态 (#禁止) ' 索引从0开始,第一个不禁止,那索引就是1开始
    .默认
        i.去除状态 (#禁止)
    .判断结束
    
.计次循环尾 ()
 ' 这里是判断是不是已经录制,如果没录制的话,那这些按钮都设置为禁止

.子程序 _工具条1_被单击, 空白型, , 
.参数 按钮索引, 整数型, , 

.局部变量 局部_标题, 文本型, , , 

赋值 (局部_标题, 按钮索引.取标题 ())
.判断开始 (等于 (按钮索引, 0))
    .判断开始 (等于 (局部_标题, “录制”))
        .判断开始 (等于 (菜单_取状态 (8), 8)) ' 如果全屏是选中状态,那就设置录制区域为全屏
            .如果真 (窗口_设置..选中) ' 如果选中了自动隐藏窗口,我这里用的是最小化, 可以改成可视=假
                赋值 (_启动窗口., 2)
            .如果真结束
            赋值 (程序集_录制区域.left, 0)
            赋值 (程序集_录制区域.top, 0)
            赋值 (程序集_录制区域.right, 取屏幕宽度 ())
            赋值 (程序集_录制区域.bottom, 取屏幕高度 ())
        .默认
            GetWindowRect (取窗口句柄 (), 程序集_录制区域) ' 否则录制区域就是图片框的位置
        .判断结束
        赋值 (全局_时钟周期, 相除 (1000, 程序集_帧))
        SetTimer (取窗口句柄 (), #时钟_录制, 全局_时钟周期, &时钟事件_录制) ' 启动一个时钟,标志是1001
        0.置标题 (“停止”)
    .默认
        0.置标题 (“录制”)
        KillTimer (取窗口句柄 (), #时钟_录制) ' 关闭时钟
        禁止按钮 ()
    .判断结束
    
.判断 (等于 (局部_标题, “清空”))
    子程序_清空 ()
.判断 (等于 (局部_标题, “预览”))
    子程序_调整进度窗口位置 ()
    赋值 (窗口_预览., 相加 (“一共有”, 到文本 (全局_总帧数), “帧”))
    赋值 (窗口_预览., 真)
.判断 (等于 (局部_标题, “保存”))
    启动线程_ (&子程序_保存, #常量_正序)
.判断 (等于 (局部_标题, “编辑”))
    赋值 (全局_编辑模式, #常量_正序)
    载入 (窗口_编辑, _启动窗口, 假)
.默认
    
.判断结束


.子程序 _工具条1_被下拉, 空白型, , 
.参数 按钮索引, 整数型, , 
.参数 下拉横座标, 整数型, , 
.参数 下拉纵座标, 整数型, , 

.局部变量 局部_标题, 文本型, , , 

赋值 (局部_标题, 按钮索引.取标题 ())
.判断开始 (或者 (等于 (局部_标题, “录制”), 等于 (局部_标题, “停止”)))
    菜单_弹出 (#菜单_录制, )
.判断 (等于 (局部_标题, “保存”))
    菜单_弹出 (#菜单_保存, )
.默认
    
.判断结束


.子程序 子程序_设置透明, 整数型, , 返回原来的窗口信息
.局部变量 局部_窗口信息, 整数型, , , 取消透明的时候会用到这个

赋值 (局部_窗口信息, GetWindowLongA (取窗口句柄 (), #GWL_EXSTYLE))
SetWindowLongA (取窗口句柄 (), #GWL_EXSTYLE, 位或 (局部_窗口信息, #OFN_EXPLORER))
赋值 (.背景颜色, 选择 (窗口_设置..选中, #品红, 1))
SetLayeredWindowAttributes (取窗口句柄 (), .背景颜色, 0, #LWA_COLORKEY)
返回 (局部_窗口信息)
 ' SetWindowLongA (取窗口句柄 (), #GWL_EXSTYLE, 局部_窗口信息)  ' 取消透明

.窗口程序集 程序集_窗口_预览, , , 

.程序集变量 程序集_顺序, 整数型, , , 
.程序集变量 程序集_计数, 整数型, , , 
.程序集变量 程序集_正负, 整数型, , , +1 或者 -1
.子程序 时钟事件_预览, 空白型, , 
.局部变量 局部_图片, 字节集, , , 

赋值 (程序集_计数, 相加 (程序集_计数, 程序集_正负)) ' 这里的计数是代表倒序还是正序,正序的话 程序集_正负就是1 否则就是-1
.如果真 (或者 (小于 (程序集_计数, 1), 大于 (程序集_计数, 全局_总帧数))) ' 基本的判断,不然数组下标可能会越界
    KillTimer (取窗口句柄 (), #时钟_预览)
    赋值 (., 相加 (“一共有”, 到文本 (全局_总帧数), “帧     当前播放第”, 到文本 (相减 (程序集_计数, 程序集_正负)), “帧,已播放完毕”))
    返回 ()
.如果真结束
.如果真 (小于或等于 (程序集_计数, 取数组成员数 (全局_数据组))) ' 如果计数小于数组成员数,表示图片是在内存,从内存里读取,也就是从数组里读取
    输出调试文本 (相加 (“读取内存图片 | ”, 到文本 (程序集_计数)))
    赋值 (.底图, 全局_数据组 [程序集_计数])
    赋值 (., 相加 (“一共有”, 到文本 (全局_总帧数), “帧     当前播放第”, 到文本 (程序集_计数), “帧”))
    返回 () ' 返回,不在判断下一个如果真,不要这个返回也可以,不过程序会多走下面的 如果真
.如果真结束
.如果真 (并且 (大于 (程序集_计数, 取数组成员数 (全局_数据组)), 小于或等于 (程序集_计数, 全局_总帧数))) ' 如果计数大于数组成员数,而且小于总帧数,表示图片是在本地,数据库里读取
    输出调试文本 (相加 (“读取本地图片 | ”, 到文本 (程序集_计数)))
    赋值 (局部_图片, 读 (“图片”))
    跳过 (程序集_正负)
    .如果真 (尾记录后 ()) ' 这里是正序播放, 如果是最后一张图片,那就不继续读数据库,并且关闭时钟,
        KillTimer (取窗口句柄 (), #时钟_预览)
        赋值 (., 相加 (“一共有”, 到文本 (全局_总帧数), “帧     当前播放第”, 到文本 (全局_总帧数), “帧,已播放完毕”))
        到首记录 () ' 正序播放完后把数据库的指针指向第一条记录
        返回 ()
    .如果真结束
    .如果真 (首记录前 ()) ' 这里是倒序播放, 如果是第一张图片,那就不继续读数据库,并且关闭时钟,
        KillTimer (取窗口句柄 (), #时钟_预览)
        赋值 (., 相加 (“一共有”, 到文本 (全局_总帧数), “帧     当前播放第1帧,已播放完毕”))
        到尾记录 () ' 倒序播放完后把数据库的指针指向最后一条记录
        返回 ()
    .如果真结束
    赋值 (.底图, 局部_图片)
    赋值 (., 相加 (“一共有”, 到文本 (全局_总帧数), “帧     当前播放第”, 到文本 (程序集_计数), “帧”))
.如果真结束


.子程序 子程序_调整进度窗口位置, 空白型, , 软件制作,接单QQ 121007124
 ' 这里是数学题,计算预览窗口的位置和宽高,我就不多做讲解
_启动窗口.移动 (..左边, _启动窗口..顶边, _启动窗口..宽度, _启动窗口..高度)
窗口_预览.移动 (相加 (_启动窗口., 相除 (相减 (_启动窗口., 窗口_预览.), 2)), 相加 (_启动窗口., 相除 (相减 (_启动窗口., 窗口_预览.), 2)), _启动窗口., _启动窗口.)

.子程序 _工具条1_被单击, 空白型, , 
.参数 按钮索引, 整数型, , 

.局部变量 局部_标题, 文本型, , , 

赋值 (局部_标题, 按钮索引.取标题 ())
.判断开始 (等于 (局部_标题, “正序”))
    赋值 (程序集_顺序, #常量_正序)
    赋值 (程序集_计数, 0)
    赋值 (程序集_正负, 1)
    SetTimer (取窗口句柄 (), #时钟_预览, 全局_时钟周期, &时钟事件_预览)
    到首记录 ()
.判断 (等于 (局部_标题, “倒序”))
    赋值 (程序集_顺序, #常量_倒序)
    赋值 (程序集_计数, 全局_总帧数)
    赋值 (程序集_正负, -1)
    SetTimer (取窗口句柄 (), #时钟_预览, 全局_时钟周期, &时钟事件_预览)
    到尾记录 ()
.判断 (等于 (局部_标题, “暂停”))
    按钮索引.置标题 (“继续”)
    KillTimer (取窗口句柄 (), #时钟_预览)
.判断 (等于 (局部_标题, “继续”))
    按钮索引.置标题 (“暂停”)
    SetTimer (取窗口句柄 (), #时钟_预览, 全局_时钟周期, &时钟事件_预览)
.判断 (等于 (局部_标题, “保存”))
    启动线程_ (&子程序_保存, #常量_正序)
.默认
    
.判断结束


.子程序 _工具条1_被下拉, 空白型, , 
.参数 按钮索引, 整数型, , 
.参数 下拉横座标, 整数型, , 
.参数 下拉纵座标, 整数型, , 

.判断开始 (等于 (按钮索引, 3))
    菜单_弹出 (#菜单_保存, )
.默认
    
.判断结束


.子程序 _窗口_预览_可否被关闭, 逻辑型, , 
赋值 (窗口_预览., 假)
KillTimer (取窗口句柄 (), #时钟_预览)
返回 (假)

.子程序 _窗口_预览_尺寸被改变, 空白型, , 
0.移动 (., 取用户区宽度 (), 相减 (取用户区高度 (), .))

.窗口程序集 窗口程序集_窗口_进度, , , 

.子程序 子程序_移动进度条位置, 空白型, , 
赋值 (窗口_进度., .宽度)
赋值 (窗口_进度., .高度)
赋值 (窗口_进度., 相加 (_启动窗口., 相除 (相减 (_启动窗口., 窗口_进度.), 2)))
赋值 (窗口_进度., 相加 (_启动窗口., 相除 (相减 (_启动窗口., 窗口_进度.), 2)))

.窗口程序集 程序集_窗口_编辑, , , 

.程序集变量 画板, 画板, , "50", 一页最多显示50帧,懒得计算位置了,数学不好
.程序集变量 画板事件, 画板, , , 当前操作的画板
.程序集变量 程序集_已经改动, 逻辑型, , , 只要删除一帧,那这个变量就是真
.程序集变量 程序集_已按下, 逻辑型, , , 模拟滑块条用的
.程序集变量 程序集_原帧信息, 未知类型0x20002, , "0", 记录一下原来的帧信息
.子程序 _窗口_编辑_创建完毕, 空白型, , 
到首记录 ()
赋值 (程序集_原帧信息, _启动窗口.)
赋值 (.背景颜色, 6710886)
重定义数组 (画板, 假, 全局_总帧数)
复制组件 ()
赋值 (., 相加 (“总帧数:”, 到文本 (全局_总帧数), “      当前剩余帧数:”, 到文本 (取数组成员数 (画板))))
.如果真 (小于 (取数组成员数 (画板), 4)) ' 计算窗口宽度,最小一帧,一帧就显示两个画板的宽度 最大4帧,显示4个画板的宽度
    .判断开始 (等于 (取数组成员数 (画板), 1))
        赋值 (., 相加 (相乘 (取数组成员数 (画板), 400), 6))
    .默认
        赋值 (., 相加 (相乘 (取数组成员数 (画板), 200), 6))
    .判断结束
    
.如果真结束
赋值 (窗口_编辑., 相加 (_启动窗口., 相除 (相减 (_启动窗口., 窗口_编辑.), 2)))
赋值 (窗口_编辑., 相加 (_启动窗口., 相除 (相减 (_启动窗口., 窗口_编辑.), 2)))
 ' 窗口居中在启动窗口

.子程序 复制组件, 空白型, , 
.局部变量 i, 整数型, , , 

.计次循环首 (取数组成员数 (画板), i)
    复制窗口组件 (画板 [i])
    .判断开始 (等于 (全局_编辑模式, #常量_正序))
        内部_初始化组件信息 (画板 [i], i, 1)
    .默认
        内部_初始化组件信息 (画板 [i], 相减 (相加 (全局_总帧数, 1), i), -1)
    .判断结束
    
.计次循环尾 ()
 ' 输出调试文本 (取数组成员数 (画板))
赋值 (.宽度, 相乘 (取数组成员数 (画板), 200))

.子程序 内部_初始化组件信息, 空白型, , 
.参数 画板组件, 画板, , 
.参数 索引, 整数型, , 画板索引,也就是计次循环里的计次
.参数 跳转顺序, 整数型, , 只能是1 或 -1

连续赋值 (真, 画板组件.可视, 画板组件.自动重画)
赋值 (画板组件.左边, 相乘 (相减 (索引, 1), .宽度))
.判断开始 (小于或等于 (索引, 取数组成员数 (全局_数据组))) ' 如果索引小于数组成员数 那么表示数据存在内存
    输出调试文本 (相加 (“从内存读取,第 ”, 到文本 (索引), “ 张”))
    赋值 (画板组件.底图, 全局_数据组 [索引])
.默认
    赋值 (画板组件.底图, 读 (“图片”)) ' 如果索引大于数组成员数  那就意味着数据存在本地
    输出调试文本 (相加 (“从本地读取,第 ”, 到文本 (索引), “ 张”))
    跳过 (跳转顺序)
.判断结束
画板组件.置写出位置 (10, 10)
画板组件.写出 (“第 ”)
赋值 (画板组件.文本颜色, #红色)
画板组件.写出 (到文本 (索引))
赋值 (画板组件.文本颜色, #黑色)
画板组件.写出 (“ 帧  延时:”)
赋值 (画板组件.文本颜色, #红色)
画板组件.写出 (到文本 (相乘 (_启动窗口. [索引], , 10)))
赋值 (画板组件.文本颜色, #黑色)
画板组件.写出 (“毫秒”)
赋值 (画板组件.标记, 到文本 (索引))
 ' 后面这一大堆没技术含量,一看应该就能看懂

.子程序 _画板1_鼠标右键被放开, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

赋值 (画板事件, 取事件组件 ()) ' 要取发生事件的组件,否则弹出菜单不知道操作哪个组件
菜单_弹出 (#菜单_编辑, )

.子程序 _画板1_被双击, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

赋值 (画板事件, 取事件组件 ()) ' 要取发生事件的组件,否则弹出菜单不知道操作哪个组件
.如果真 (等于 (是否已创建 (窗口_显示编辑帧), 假))
    载入 (窗口_显示编辑帧, 窗口_编辑, 假)
.如果真结束
赋值 (窗口_显示编辑帧..图片, 画板事件.底图)
赋值 (窗口_显示编辑帧., 真)
赋值 (窗口_显示编辑帧., 相加 (“一共有”, 到文本 (取数组成员数 (画板)), “帧     当前帧: 第”, 画板事件.标记, “帧”))

.子程序 _删除当前帧_被选择, 空白型, , 
.局部变量 标记数字, 整数型, , , 

赋值 (标记数字, 到整数 (画板事件.标记))
画板.销毁 ( [标记数字], )
子程序_移动画板位置 (相加 (标记数字, 1), 200)

.子程序 子程序_移动画板位置, 空白型, , 算法有点乱,懒得备注了,总的来说就是 删除某个帧之后,把后面的画板往前面移动,不能删除后就留空白在那
.参数 参数_画板位置, 整数型, , 
.参数 参数_移动位置, 整数型, , 
.参数 参数_删除位置, 整数型, 可空, 
.参数 参数_是否倒序, 逻辑型, 可空, 

.局部变量 i, 整数型, , , 

.如果真 (是否为空 (参数_是否倒序))
    .变量循环首 (参数_画板位置, 取数组成员数 (画板), 1, i)
        赋值 (画板 [i], 左边, 相减 (画板 [i], 左边, 参数_移动位置))
        赋值 (画板 [i], 标记, 到文本 (相减 (i, 相除 (参数_移动位置, 200))))
    .变量循环尾 ()
.如果真结束
赋值 (.宽度, 相减 (.宽度, 参数_移动位置))
.判断开始 (等于 (参数_删除位置, 0))
    删除成员 (画板, 相减 (参数_画板位置, 1), 1) ' 只要画板删 我也跟着删,帧信息的数组是跟总帧数是一样的,而画板的成员数也是跟总帧数一样的
    删除成员 (程序集_原帧信息, 相减 (参数_画板位置, 1), 1)
.判断 (等于 (参数_是否倒序, 假))
    删除成员 (画板, 参数_删除位置, 相除 (参数_移动位置, 200))
    删除成员 (程序集_原帧信息, 参数_删除位置, 相除 (参数_移动位置, 200))
.默认
    删除成员 (画板, 参数_删除位置, 取数组成员数 (画板))
    删除成员 (程序集_原帧信息, 参数_删除位置, 取数组成员数 (画板))
.判断结束
赋值 (., 相加 (“总帧数:”, 到文本 (全局_总帧数), “      当前剩余帧数:”, 到文本 (取数组成员数 (画板))))
.如果真 (小于或等于 (取数组成员数 (画板), 4))
    赋值 (.左边, 0)
.如果真结束
赋值 (程序集_已经改动, 真)
赋值 (.禁止, 假)

.子程序 _删除从当前帧到结束_被选择, 空白型, , 
.局部变量 删除位置, 整数型, , , 
.局部变量 i, 整数型, , , 

赋值 (删除位置, 到整数 (画板事件.标记))
.变量循环首 (删除位置, 取数组成员数 (画板), 1, i)
    画板.销毁 ( [i], )
.变量循环尾 ()
子程序_移动画板位置 (i, 相乘 (相加 (相减 (取数组成员数 (画板), 删除位置), 1), 200), 删除位置, 真)

.子程序 _删除从当前帧到开始_被选择, 空白型, , 
.局部变量 删除次数, 整数型, , , 
.局部变量 i, 整数型, , , 

赋值 (删除次数, 到整数 (画板事件.标记))
.计次循环首 (删除次数, i)
    画板.销毁 ( [i], )
.计次循环尾 ()
子程序_移动画板位置 (i, 相乘 (相减 (i, 1), 200), 1, )

.子程序 子程序_保存已编辑图片, 空白型, , 
.局部变量 i, 整数型, , , 
.局部变量 局部_数量, 整数型, , , 

清空 () ' 清空数据库
赋值 (_启动窗口., 程序集_原帧信息) ' 只要到保存这里,才给启动窗口的帧信息赋值
赋值 (局部_数量, 取数组成员数 (画板))
.如果真 (小于或等于 (局部_数量, 取数组成员数 (全局_数据组))) ' 当前数量小于原来的数组,表示 原来的数组能存下这么多数据
    重定义数组 (全局_数据组, 假, 局部_数量) ' 重新定义数组数量
.如果真结束
.计次循环首 (局部_数量, i)
    .判断开始 (小于或等于 (i, 取数组成员数 (全局_数据组))) ' 写回原来的数组,上面重新定义了,如果当前帧数比原来的数组多,那就不会重新定义数组
        赋值 (全局_数据组 [i], 画板 [i], 底图) ' 把新的数据添加到原来的数组,这个逻辑慢慢理一下就能懂了
    .默认
        加空记录 ()
        写 (“图片”, 画板 [i], 底图) ' 如果有多出来的 写到本地
    .判断结束
    
.计次循环尾 ()
赋值 (全局_总帧数, 取数组成员数 (画板)) ' 因为删除了部分数据,所以要重新给帧数赋值
赋值 (_启动窗口., 相加 (“当前帧数:”, 到文本 (全局_总帧数)))

.子程序 _窗口_编辑_可否被关闭, 逻辑型, , 
.局部变量 局部_临时变量, 整数型, , , 
.局部变量 i, 整数型, , , 

.如果真 (等于 (程序集_已经改动, 假))
    返回 (真)
.如果真结束
赋值 (局部_临时变量, 信息框 (相加 (#常量_版权, #换行符, #换行符, “你已做了修改,尚未保存,是否保存”, #换行符, #换行符, “点击是保存并退出”, #换行符, “点击否不保存并退出”, #换行符, “点击取消,则返回编辑界面继续操作”), 相加 (#取消是否钮, #信息图标), #常量_版权, 窗口_编辑))
.判断开始 (等于 (局部_临时变量, #是钮))
    子程序_保存已编辑图片 ()
.判断 (等于 (局部_临时变量, #取消钮))
    返回 (假)
.默认
    .计次循环首 (取数组成员数 (画板), i)
        画板.销毁 ( [i], ) ' 不知道不销毁会不会增加内存垃圾
    .计次循环尾 ()
    清除数组 (画板)
    连续赋值 (假, 程序集_已经改动, 程序集_已按下)
    返回 (真)
.判断结束


.子程序 _窗口_编辑_尺寸被改变, 空白型, , 
10.移动 (相加 (.顶边, .高度, 20), 相减 (取用户区宽度 (), 20), )
.移动 (.左边, 相加 (.顶边, 相除 (相减 (.高度, .高度), 2)), , )

.子程序 _图片框1_鼠标左键被按下, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

赋值 (程序集_已按下, 真)
SetCapture (取窗口句柄 ()) ' 捕获鼠标

.子程序 _图片框1_鼠标左键被放开, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

赋值 (程序集_已按下, 假)
ReleaseCapture () ' 释放鼠标

.子程序 _图片框1_鼠标位置被移动, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

.局部变量 局部_左边, 整数型, , , 

.如果真 (等于 (程序集_已按下, 假))
    返回 ()
.如果真结束
赋值 (局部_左边, 相减 (取鼠标水平位置 (), 窗口_编辑., 相除 (.宽度, 2)))
.判断开始 (小于或等于 (局部_左边, .左边))
    赋值 (局部_左边, .左边)
.判断 (大于或等于 (局部_左边, .宽度))
    赋值 (局部_左边, .宽度)
.默认
    
.判断结束
.如果真 (等于 (局部_左边, .左边))
    返回 ()
.如果真结束
赋值 (.左边, 局部_左边)
赋值 (局部_左边, 相减 (局部_左边, .左边))
滑块条_位置被滑动 (局部_左边)

.子程序 滑块条_位置被滑动, 空白型, , 
.参数 当前位置, 整数型, , 

.局部变量 局部_总长度, 双精度小数型, , , 

.如果真 (大于 (取数组成员数 (画板), 4))
    赋值 (局部_总长度, 相减 (相乘 (取数组成员数 (画板), .宽度), 相乘 (.宽度, 4)))
    赋值 (.左边, 负 (取整 (相乘 (相除 (当前位置, 相减 (.宽度, .左边)), 局部_总长度))))
    输出调试文本 (相加 (到文本 (当前位置), “ | ”, 到文本 (.左边)))
.如果真结束


.子程序 _标签2_鼠标左键被按下, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

.局部变量 局部_左边, 双精度小数型, , , 

赋值 (局部_左边, 相减 (取鼠标水平位置 (), 窗口_编辑., 相除 (.宽度, 2)))
赋值 (.左边, 局部_左边)
滑块条_位置被滑动 (局部_左边)

.子程序 _按钮_保存_被单击, 空白型, , 
子程序_保存已编辑图片 ()

.子程序 _按钮_取消_被单击, 空白型, , 
赋值 (程序集_已经改动, 假)
销毁 ()

.程序集 程序集_杂项, , , 

.子程序 截图, 字节集, , 
.参数 rect, RECT, , 
.参数 转换格式, 整数型, 可空, 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；默认不转换
.参数 是否录制鼠标, 逻辑型, 可空, 默认不录制鼠标

.局部变量 Width, 整数型, , , 
.局部变量 FileSize, 整数型, , , 
.局部变量 Head, 字节集, , , 
.局部变量 Data, 字节集, , , 
.局部变量 dc, 整数型, , , 
.局部变量 BitCount, 整数型, , , 
.局部变量 hdc, 整数型, , , 
.局部变量 Bitmap, 整数型, , , 
.局部变量 hgdiobj, 整数型, , , 
.局部变量 BitmapHead, BITMAPINFOHEADER, , , 
.局部变量 piconinfo, CURSORINFO, , , 

赋值 (dc, GetDC (0)) ' 打开设备场景
赋值 (BitCount, GetDeviceCaps (dc, #BITSPIXEL)) ' 获取设备场景信息
赋值 (hdc, CreateCompatibleDC (dc)) ' '创建一个内存场景,相当于创建画布,以后画画就画到这里
赋值 (Bitmap, CreateCompatibleBitmap (dc, 相减 (rect.right, rect.left), 相减 (rect.bottom, rect.top))) ' 创建一个位图
赋值 (hgdiobj, SelectObject (hdc, Bitmap)) ' 进入设备场景
BitBlt (hdc, 0, 0, 相减 (rect.right, rect.left), 相减 (rect.bottom, rect.top), dc, rect.left, rect.top, #SRCCOPY) ' 复制位图到内存场景
.如果真 (是否录制鼠标)
    赋值 (piconinfo.cbSize, 20)
    GetCursorInfo (piconinfo) ' 获取鼠标信息  坐标和鼠标句柄
    DrawIcon (hdc, 相减 (piconinfo.ptScreenPos.x, rect.left), 相减 (piconinfo.ptScreenPos.y, rect.top), piconinfo.hCursor) ' 在内存场景上画出鼠标样子
.如果真结束
SelectObject (hdc, hgdiobj) ' 选入设备场景
赋值 (BitmapHead.biSize, 40)
赋值 (BitmapHead.biWidth, 相减 (rect.right, rect.left))
赋值 (BitmapHead.biHeight, 相减 (rect.bottom, rect.top))
赋值 (BitmapHead.biPlanes, 1)
赋值 (BitmapHead.biBitCount, BitCount)
赋值 (Width, 左移 (右移 (相加 (相乘 (相减 (rect.right, rect.left), BitCount), 31), 5), 2))
赋值 (Data, 取空白字节集 (相加 (BitmapHead.biSize, 相乘 (Width, 相减 (rect.bottom, rect.top)))))
RtlMoveMemory (Data [1], BitmapHead, BitmapHead.biSize) ' 从内存把画布取出来
.如果真 (并且 (大于或等于 (取字节集长度 (Data), 相加 (BitmapHead.biSize, 1)), 不等于 (取字节集长度 (Data), 0)))
    .如果 (不等于 (GetDIBits (hdc, Bitmap, 0, 相减 (rect.bottom, rect.top), Data [相加 (BitmapHead.biSize, 1)], Data [1], 0), 0))
        赋值 (FileSize, 相加 (14, 相乘 (Width, 相减 (rect.bottom, rect.top))))
        赋值 (Data, 相加 (到字节集 (“BM”), 到字节集 (FileSize), { 0, 0, 0, 0, 54, 0, 0, 0 }, Data))
    .否则
        赋值 (Data, {  })
    .如果结束
    
.如果真结束
ReleaseDC (0, dc) ' 释放设备场景
DeleteObject (Bitmap) ' 删除一个对象,这里是删除位图对象
DeleteDC (hdc) ' 删除设备场景  相当于删除画布
 ' 返回 (Data)
返回 (图片_转换 (Data, 转换格式))

.子程序 图片_转换, 字节集, , 转换后的图片数据
.参数 图像数据, 字节集, , 被转换的图像数据；
.参数 转换格式, 整数型, , 要转换成的图像格式：1=bmp；2=jpg；3=gif；4=tiff；5=png；

.局部变量 Clsid, GUID, , , 
.局部变量 pStr, 文本型, , , 
.局部变量 hMem, 整数型, , , 
.局部变量 Stream, 整数型, , , 
.局部变量 lpvoid, 整数型, , , 
.局部变量 pStream, 整数型, , , 
.局部变量 bitmap, 整数型, , , 
.局部变量 DataStream, 整数型, , , 
.局部变量 hMemDataStream, 整数型, , , 
.局部变量 pDataStream, 整数型, , , 
.局部变量 nStreamSize, 整数型, , , 
.局部变量 GpInput, GdiplusStartupInput, , , 
.局部变量 GpToken, 整数型, , , 
.局部变量 局部_后缀名, 文本型, , , 
.局部变量 局部_返回数据, 字节集, , , 

.如果真 (小于 (取字节集长度 (图像数据), 3))
    返回 ({  })
.如果真结束
赋值 (GpInput.GdiplusVersion, 1)
GdiplusStartup (GpToken, GpInput, 0) ' 启动GDI+
.判断开始 (等于 (转换格式, 1)) ' bmp
    赋值 (pStr, “{557CF400-1A04-11D3-9A73-0000F81EF32E}”)
    赋值 (局部_后缀名, “.bmp”)
.判断 (等于 (转换格式, 2)) ' jpg
    赋值 (pStr, “{557CF401-1A04-11D3-9A73-0000F81EF32E}”)
    赋值 (局部_后缀名, “.jpg”)
.判断 (等于 (转换格式, 3)) ' gif
    赋值 (pStr, “{557CF402-1A04-11D3-9A73-0000F81EF32E}”)
    赋值 (局部_后缀名, “.gif”)
.判断 (等于 (转换格式, 4)) ' tiff
    赋值 (pStr, “{557CF405-1A04-11D3-9A73-0000F81EF32E}”)
    赋值 (局部_后缀名, “.tiff”)
.判断 (等于 (转换格式, 5)) ' png
    赋值 (pStr, “{557CF406-1A04-11D3-9A73-0000F81EF32E}”)
    赋值 (局部_后缀名, “.png”)
.默认
    返回 (图像数据)
.判断结束

CLSIDFromString (A2W (pStr), Clsid)
赋值 (hMem, GlobalAlloc (2, 取字节集长度 (图像数据))) ' 分配内存
CreateStreamOnHGlobal (hMem, 假, Stream)

赋值 (lpvoid, GlobalLock (hMem))
写到内存 (图像数据, lpvoid, 取字节集长度 (图像数据))
GlobalUnlock (hMem)

赋值 (pStream, lstrcpyn (Stream, Stream, 0))
GDIpCreateBitmapFromStream (取字节集数据 (指针到字节集 (pStream, 4), #整数型, ), bitmap)

CreateStreamOnHGlobal (0, 真, DataStream)
赋值 (pStream, lstrcpyn (DataStream, DataStream, 0))
赋值 (pStream, 取字节集数据 (指针到字节集 (pStream, 4), #整数型, ))

GdipSaveImageToStream (bitmap, pStream, Clsid, 0)
GetHGlobalFromStream (pStream, hMemDataStream)
赋值 (pDataStream, GlobalLock (hMemDataStream))
赋值 (nStreamSize, GlobalSize (hMemDataStream))
.如果真 (不等于 (pDataStream, 0))
    赋值 (局部_返回数据, 取空白字节集 (nStreamSize))
    CopyMemory_int2Bytes (局部_返回数据, pDataStream, nStreamSize)
.如果真结束
Release (Stream)
Release (DataStream)
GlobalUnlock (hMemDataStream)
GlobalFree (hMemDataStream)
GdipDisposeImage (bitmap)
GlobalFree (hMem)
GdiplusShutdown (GpToken) ' GDI关闭 +
返回 (局部_返回数据)

.子程序 Release, 整数型, , 
.参数 this_, 整数型, , 

.局部变量 index, 整数型, , , 

赋值 (index, 2)
置入代码 ({ 139, 69, 8, 139, 0, 107, 77, 252, 4, 3, 193, 131, 196, 4, 93, 255, 32 })
返回 (0)

.子程序 A2W, 字节集, , 将Ansi码转换为Unicode码；成功返回转换后的字节集；
.参数 Ansi编码, 文本型, , Ansi文本

.局部变量 局部_结果, 字节集, , , 
.局部变量 局部_长度, 整数型, , , 

.如果真 (等于 (Ansi编码, “”))
    返回 ({  })
.如果真结束
赋值 (局部_长度, MultiByteToWideChar (936, 0, Ansi编码, -1, {  }, 0))
赋值 (局部_结果, 取空白字节集 (相乘 (局部_长度, 2)))
MultiByteToWideChar (936, 0, Ansi编码, -1, 局部_结果, 相乘 (局部_长度, 2))
返回 (局部_结果)

.子程序 图标_取句柄, 整数型, 公开, 取图标句柄,成功返回图标句柄,失败返回0
.参数 图片数据, 字节集, , 欲添加为菜单图标的资源

.局部变量 对象, 对象, 静态, "0", 
.局部变量 局部_成员数, 整数型, , , 

赋值 (局部_成员数, 相加 (取数组成员数 (对象), 1))
重定义数组 (对象, 真, 局部_成员数)
.如果真 (对象.创建图片对象 ( [局部_成员数], 图片数据))
    返回 (对象.读数值属性 ( [局部_成员数], “handle”, ))
.如果真结束
返回 (0)

.子程序 图标_取句柄1, 整数型, 公开, 取图标句柄,成功返回图标句柄,失败返回0
.参数 图片数据, 字节集, , 欲添加为菜单图标的资源

.局部变量 对象, 对象, , , 

.如果真 (对象.创建图片对象 (图片数据))
    返回 (对象.读数值属性 (“handle”, ))
.如果真结束
返回 (0)

.子程序 保存文件, 文本型, , 成功打开返回文件路径,失败返回空文本
.局部变量 局部_结构, OPENFILENAME, , , 
.局部变量 局部_路径, 逻辑型, , , 

赋值 (局部_结构.结构大小, 76)
赋值 (局部_结构.窗口句柄, _启动窗口.取窗口句柄 ())
赋值 (局部_结构.实例句柄, 0)
赋值 (局部_结构.文件标题, “文件标题”)
赋值 (局部_结构.过滤器, 相加 (到字节集 (“GIF格式文件(*.gif)”), { 0, 0, 0 }))
赋值 (局部_结构.文件名, 取空白字节集 (255))
lstrcpy_bin (局部_结构.文件名, 相加 (到字节集 (“福仔制作-GIF录制小工具”), { 0, 0 }))
赋值 (局部_结构.初始目录, 取运行目录 ())
赋值 (局部_结构.默认扩展名, “gif”)
赋值 (局部_结构.标题, “保存GIF图片”)
赋值 (局部_结构.文件名最大长度, 255)
 ' 局部_结构.标志 ＝ 位或 (#OFN_EXPLORER, #OFN_OVERWRITEPROMPT)  ' #OFN_EXPLORER = 524288  #OFN_OVERWRITEPROMPT = 2
赋值 (局部_路径, GetSaveFileNameA (局部_结构))
返回 (选择 (局部_路径, 到文本 (局部_结构.文件名), “”))

.子程序 程序_延时, 空白型, , 不占用cpu，窗口不卡死，不影响其它代码执行,,从精易模块拿出来的,不懂的话可以引用模块,然后用模块里的命令
.参数 延时间隔, 整数型, , 单位毫秒

.局部变量 局_时间句柄, 整数型, , , 
.局部变量 局_时间, 程序延时, , , 

赋值 (局_时间.成员_时间, 相乘 (-10, 延时间隔, 1000))
赋值 (局_时间句柄, CreateWaitableTimerA (0, 假, 0))
SetWaitableTimer (局_时间句柄, 局_时间, 0, 0, 0, 假)
.判断循环首 (不等于 (MsgWaitForMultipleObjects (1, 局_时间句柄, 假, -1, 255), 0))
    处理事件 ()
.判断循环尾 ()
CloseHandle (局_时间句柄)

.子程序 _指针到文本, 文本型, 公开, 
.参数 文本指针, 整数型, , 

.局部变量 长度, 整数型, , , 
.局部变量 文本, 文本型, , , 

赋值 (长度, lstrlenA (文本指针))
赋值 (文本, 取空白文本 (长度))
CopyMemory_str (文本, 文本指针, 长度)
返回 (文本)

.子程序 销毁线程, 逻辑型, , 强制终止线程
.参数 线程句柄, 整数型, , 线程句柄

.局部变量 lpExitCode, 整数型, , , 

GetExitCodeThread (线程句柄, lpExitCode)
返回 (TerminateThread (线程句柄, lpExitCode))

.子程序 启动线程_, 整数型, , 
.参数 欲执行子程序, 子程序指针, , 
.参数 参数1, 整数型, 可空, 

返回 (CreateThread (0, 0, 欲执行子程序, 参数1, 0, 0))

.子程序 程序_Call, 整数型, , 调用子程序
.参数 子程序指针, 整数型, , 
.参数 参数1, 整数型, , 
.参数 参数2, 整数型, , 

置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
返回 (0)

.子程序 写配置, 逻辑型, , 
.参数 配置项名, 文本型, , 
.参数 写入内容, 整数型, , 

返回 (写配置项 (相加 (取运行目录 (), “\gif配置.ini”), “配置”, 配置项名, 到文本 (写入内容)))

.子程序 读配置, 文本型, , 
.参数 配置项名, 文本型, , 
.参数 默认内容, 整数型, 可空, 

返回 (读配置项 (相加 (取运行目录 (), “\gif配置.ini”), “配置”, 配置项名, 到文本 (默认内容)))

.程序集 程序集_菜单, , , 

.程序集变量 程序集_主菜单, 整数型, , , 
.程序集变量 程序集_录制菜单, 整数型, , , 
.程序集变量 程序集_保存菜单, 整数型, , , 这几个看名字就能看出来什么意思
.程序集变量 程序集_编辑菜单, 整数型, , , 
.程序集变量 匿名程序集变量_26717, 空白型, , , 
.程序集变量 程序集_菜单计数, 整数型, , , 记录已经创建多少个菜单,我懒,所以用1 2 3 4 这样的来区分菜单,创建10个菜单,那么第10个菜单的索引就是10  其他一样
.子程序 菜单_创建, 整数型, , 返回菜单句柄
.局部变量 局部_录制菜单标题, 文本型, , "0", 
.局部变量 局部_保存菜单标题, 文本型, , "0", 
.局部变量 局部_编辑按钮菜单标题, 文本型, , "0", 
.局部变量 局部_编辑菜单标题, 文本型, , "0", 

赋值 (程序集_主菜单, CreateMenu ()) ' 新建一个弹出式菜单,这个作为主菜单
赋值 (程序集_录制菜单, CreateMenu ()) ' 新建一个弹出式菜单,
赋值 (程序集_保存菜单, CreateMenu ()) ' 新建一个弹出式菜单
赋值 (程序集_编辑菜单, CreateMenu ()) ' 新建一个弹出式菜单

赋值 (局部_录制菜单标题, { “新建(&V)”, “-”, “”, “”, “”, “”, “-”, “全屏幕(&X)”, “设置(&Z)”, “-”, “关于(&H)” })
赋值 (局部_录制菜单标题 [3], 相加 (读配置 (“帧1”, 3), “帧/s”))
赋值 (局部_录制菜单标题 [4], 相加 (读配置 (“帧2”, 5), “帧/s”))
赋值 (局部_录制菜单标题 [5], 相加 (读配置 (“帧3”, 10), “帧/s”))
赋值 (局部_录制菜单标题 [6], 相加 (读配置 (“帧4”, 15), “帧/s”))
赋值 (局部_保存菜单标题, { “正序保存”, “倒序保存” })
赋值 (局部_编辑菜单标题, { “删除当前帧”, “删除第一帧到当前帧”, “删除从当前帧最后一帧” })
内部_创建菜单 (程序集_录制菜单, 局部_录制菜单标题)
内部_创建菜单 (程序集_保存菜单, 局部_保存菜单标题)
内部_创建菜单 (程序集_编辑菜单, 局部_编辑菜单标题)
AppendMenu (程序集_主菜单, #MF_POPUP, 程序集_录制菜单, “录制菜单”) ' 把新建的弹出式菜单添加到主菜单上
AppendMenu (程序集_主菜单, #MF_POPUP, 程序集_保存菜单, “保存菜单”) ' 把新建的弹出式菜单添加到主菜单上
AppendMenu (程序集_主菜单, #MF_POPUP, 程序集_编辑菜单, “录制菜单”) ' 把新建的弹出式菜单添加到主菜单上
SetMenu (_启动窗口.取窗口句柄 (), 0) ' 这里的第二个参数如果给的是主菜单句柄,那菜单会显示在窗口上,我这里不让他显示
返回 (程序集_主菜单)

.子程序 内部_创建菜单, 空白型, , 给一个菜单句柄,句柄是创建菜单返回的句柄,然后把菜单项添加到这个菜单句柄下
.参数 菜单句柄, 整数型, , 添加到哪个菜单项里
.参数 菜单标题, 文本型, 数组, 懒了,直接用数组的方式做标题了,也可以自己修改成一个一个添加

.局部变量 i, 整数型, , , 

.计次循环首 (取数组成员数 (菜单标题), i)
    赋值 (程序集_菜单计数, 相加 (程序集_菜单计数, 1))
    .判断开始 (或者 (等于 (删全部空 (菜单标题 [i]), “-”), 等于 (删全部空 (菜单标题 [i]), “”))) ' 如果是空 或者是 - ,那就是分隔条
        AppendMenu (菜单句柄, #MF_SEPARATOR, 程序集_菜单计数, “”) ' 第二个参数参考常量 或者查 MSDN
    .默认
        AppendMenu (菜单句柄, #MF_ENABLED, 程序集_菜单计数, 菜单标题 [i])
    .判断结束
     ' AppendMenu 第二个参数参考常量里的数据,收集得不全,还缺什么的自己去MSDN查
     ' 关于菜单的API 这个源码收集了不少常量,可以去看看,根据需要自己改值,不同的值,出来的效果是不一样的
     ' 第三个参数是根据第二个参数来决定给什么值,具体自己看参数帮助,我感觉我写得挺详细的了
     ' 我这里定义为菜单ID,一个标志,我就不用菜单数值了,我懒得判断,所以 就用顺序的 1234这样
     ' 第四个参数,应该一眼就看出来了,是菜单的标题
.计次循环尾 ()

.子程序 菜单_弹出, 整数型, , 非0表示成功
.参数 菜单索引, 整数型, , 只做了3个菜单,1是录制菜单,2是保存菜单,3是编辑菜单,其他不处理
.参数 弹出位置, POINT, 可空, 默认鼠标位置

.局部变量 局部_菜单句柄, 整数型, , , 

.如果真 (是否为空 (弹出位置))
    GetCursorPos (弹出位置) ' 取一下鼠标的 XY坐标
.如果真结束
.判断开始 (等于 (菜单索引, #菜单_录制))
    赋值 (局部_菜单句柄, 程序集_录制菜单)
.判断 (等于 (菜单索引, #菜单_保存))
    赋值 (局部_菜单句柄, 程序集_保存菜单)
.判断 (等于 (菜单索引, #菜单_编辑))
    赋值 (局部_菜单句柄, 程序集_编辑菜单)
.默认
    返回 (0)
.判断结束
返回 (TrackPopupMenu (局部_菜单句柄, #TPM_LEFTALIGN, 弹出位置.x, 弹出位置.y, 0, _启动窗口.取窗口句柄 (), 0)) ' 弹出菜单

.子程序 菜单_添加图标, 逻辑型, 公开, 在指定定的菜单处加入图标
.参数 主菜单索引, 整数型, , 只做了3个菜单,1是录制菜单,2是保存菜单,3是编辑菜单,其他不处理
.参数 菜单索引, 整数型, , 子菜单索引

.局部变量 局部_菜单句柄, 整数型, , , 
.局部变量 局部_图标句柄, 整数型, , , 

.判断开始 (等于 (菜单索引, #菜单_录制))
    赋值 (局部_菜单句柄, 程序集_录制菜单)
.判断 (等于 (菜单索引, #菜单_保存))
    赋值 (局部_菜单句柄, 程序集_保存菜单)
.判断 (等于 (菜单索引, #菜单_编辑))
    赋值 (局部_菜单句柄, 程序集_编辑菜单)
.默认
    返回 (假)
.判断结束
赋值 (局部_图标句柄, 图标_取句柄 (#资源_选中))
返回 (SetMenuItemBitmaps (程序集_主菜单, 菜单索引, #MF_BITMAP, 局部_图标句柄, 局部_图标句柄))

.子程序 菜单_取数量, 整数型, 公开, 成功返回菜单数量，失败返回0；
.参数 菜单标志, 整数型, 可空, 只写了3个,一个是录制菜单,一个是保存菜单,一个是编辑菜单   用常量  #菜单_
.参数 是否返回总数量, 逻辑型, 可空, 如果为真,那就返回录制菜单和保存菜单和编辑菜单的总数量

.局部变量 局部_数量, 整数型, , , 

.如果真 (是否返回总数量)
    赋值 (局部_数量, GetMenuItemCount (程序集_录制菜单)) ' 把3个菜单的所有项目取出来
    赋值 (局部_数量, 相加 (局部_数量, GetMenuItemCount (程序集_保存菜单)))
    赋值 (局部_数量, 相加 (局部_数量, GetMenuItemCount (程序集_编辑菜单)))
    返回 (局部_数量) ' 返回总数量,用数组之类的就可以循环写,我这里菜单不多,所以就 一步一个脚印.....
.如果真结束
.判断开始 (等于 (菜单标志, #菜单_录制))
    赋值 (局部_数量, GetMenuItemCount (程序集_录制菜单))
.判断 (等于 (菜单标志, #菜单_保存))
    赋值 (局部_数量, GetMenuItemCount (程序集_保存菜单))
.默认
    
.判断结束
返回 (局部_数量)

.子程序 菜单_置状态, 空白型, , 设置0那就是取消所有状态,让菜单项变正常状态
.参数 菜单索引, 整数型, , 索引从1开始
.参数 状态, 整数型, 可空, 默认为0 如果参数标题为-,此参数无效; 1 菜单条目以灰色显示,处于禁用状态; 2 菜单条目处于禁止状态; 8 菜单条目处于复选状态; 32 为这个条目指定一条分隔线; 64 为这个条目指定一个菜单分隔标志; 128 菜单条目加亮显示(处于选定状态); 2048 菜单条目是一个分隔符

 ' 1 菜单条目以灰色显示，处于禁用状态
 ' 2 菜单条目处于禁止状态
 ' 8 菜单条目处于复选状态
 ' 32 为这个条目指定一条分隔线。
 ' 64 为这个条目指定一个菜单分隔标志。
 ' 128 菜单条目加亮显示（处于选定状态）
 ' 2048 菜单条目是一个分隔符
ModifyMenuA (程序集_主菜单, 菜单索引, 状态, 菜单索引, 菜单_取标题 (菜单索引))
 ' 用这个会设置菜单的值,所以把原来的索引,标题都重新写上

.子程序 菜单_取状态, 整数型, , 
.参数 菜单索引, 整数型, , 

返回 (GetMenuState (程序集_主菜单, 菜单索引, 0))

.子程序 菜单_取标题, 文本型, 公开, 成功返回菜单标题；失败返回空文本；
.参数 菜单索引, 整数型, , 索引从1开始；

.局部变量 局部_文本, 文本型, , , 
.局部变量 局部_标志, 整数型, , "0", 
.局部变量 i, 整数型, , , 

 ' 1 菜单条目以灰色显示，处于禁用状态
 ' 2 菜单条目处于禁止状态
 ' 8 菜单条目处于复选状态
 ' 32 为这个条目指定一条分隔线。
 ' 64 为这个条目指定一个菜单分隔标志。
 ' 128 菜单条目加亮显示（处于选定状态）
 ' 2048 菜单条目是一个分隔符
赋值 (局部_文本, 取空白文本 (255))
赋值 (局部_标志, { 0, 3, 8, 1024, 2048 })
.计次循环首 (取数组成员数 (局部_标志), i)
    GetMenuStringA (程序集_主菜单, 菜单索引, 局部_文本, 255, 局部_标志 [i])
    .如果真 (不等于 (局部_文本, “”))
        返回 (局部_文本)
    .如果真结束
    输出调试文本 (GetLastError ()) ' 取错误信息
.计次循环尾 ()
返回 (“”)

.子程序 菜单_置标题, 逻辑型, , 成功返回真，失败返回假；只能改子菜单标题；
.参数 菜单索引, 整数型, , 索引从1开始；
.参数 菜单新标题, 文本型, , 菜单新标题

 ' 1 菜单条目以灰色显示，处于禁用状态
 ' 2 菜单条目处于禁止状态
 ' 8 菜单条目处于复选状态
 ' 32 为这个条目指定一条分隔线。
 ' 64 为这个条目指定一个菜单分隔标志。
 ' 128 菜单条目加亮显示（处于选定状态）
 ' 2048 菜单条目是一个分隔符
返回 (ModifyMenuA (程序集_主菜单, 菜单索引, #MF_STRING, 菜单索引, 菜单新标题))
 ' 输出调试文本 (GetLastError ())  ' 取错误信息

.子程序 菜单回调, 空白型, , 
.参数 菜单索引, 整数型, , 

 ' 程序_Call (到整数 (0), 程序集_主菜单, 菜单索引)
输出调试文本 (菜单_取标题 (菜单索引))

.窗口程序集 窗口程序集_窗口_设置, , , 

.子程序 _按钮2_被单击, 空白型, , 
默认设置 ()

.子程序 默认设置, 空白型, , 
赋值 (.内容, “480”)
赋值 (.内容, “340”)
赋值 (.内容, “3”)
赋值 (.内容, “5”)
赋值 (.内容, “10”)
赋值 (.内容, “15”)
赋值 (.内容, “20”)
赋值 (.选中, 真)
赋值 (.选中, 真)
赋值 (.选中, 真)
赋值 (.选中, 假)
赋值 (.选中, 真)
赋值 (.禁止, 假)

.子程序 _窗口_设置_创建完毕, 空白型, , 
赋值 (.内容, 读配置 (“宽度”, 480))
赋值 (.内容, 读配置 (“高度”, 340))
赋值 (.内容, 读配置 (“帧1”, 3))
赋值 (.内容, 读配置 (“帧2”, 5))
赋值 (.内容, 读配置 (“帧3”, 10))
赋值 (.内容, 读配置 (“帧4”, 15))
赋值 (.内容, 读配置 (“内存大小”, 20))
赋值 (.选中, 等于 (读配置 (“穿透”, 1), “1”))
赋值 (.选中, 等于 (读配置 (“录制鼠标”, 0), “1”))
赋值 (.选中, 等于 (读配置 (“存储方式”, 1), “1”))
赋值 (.选中, 取反 (.选中))
赋值 (.选中, 等于 (读配置 (“全屏隐藏”, 1), “1”))
赋值 (.禁止, .选中)

.子程序 _单选框_使用内存_被单击, 空白型, , 
赋值 (.禁止, 假)
写配置 (“存储方式”, 1)

.子程序 _单选框_使用硬盘_被单击, 空白型, , 
赋值 (.禁止, 真)
写配置 (“存储方式”, 0)

.子程序 _按钮1_被单击, 空白型, , 
写配置 (“宽度”, 到整数 (.内容))
写配置 (“高度”, 到整数 (.内容))
写配置 (“左边”, _启动窗口.)
写配置 (“顶边”, _启动窗口.)
写配置 (“内存大小”, 到整数 (.内容))
写配置 (“帧1”, 到整数 (.内容))
写配置 (“帧2”, 到整数 (.内容))
写配置 (“帧3”, 到整数 (.内容))
写配置 (“帧4”, 到整数 (.内容))
写配置 (“存储方式”, 到整数 (.选中))
写配置 (“穿透”, 到整数 (.选中))
写配置 (“录制鼠标”, 到整数 (.选中))
写配置 (“全屏隐藏”, 到整数 (.选中))
菜单_置标题 (3, 相加 (.内容, “帧/s”))
菜单_置标题 (4, 相加 (.内容, “帧/s”))
菜单_置标题 (5, 相加 (.内容, “帧/s”))
菜单_置标题 (6, 相加 (.内容, “帧/s”))
_启动窗口.移动 (到整数 (.内容), 到整数 (.内容))
赋值 (., 假)

.子程序 _选择框_是否穿透_被单击, 空白型, , 
写配置 (“穿透”, 到整数 (.选中))
子程序_设置透明 ()

.子程序 _选择框_录制鼠标_被单击, 空白型, , 
赋值 (_启动窗口., .选中)

.子程序 _窗口_设置_可否被关闭, 逻辑型, , 
赋值 (窗口_设置., 假)
返回 (假)

.窗口程序集 窗口程序集_窗口1, , , 

.子程序 _窗口_显示编辑帧_尺寸被改变, 空白型, , 
0.移动 (0, 取用户区宽度 (), 取用户区高度 ())

.子程序 _窗口_显示编辑帧_可否被关闭, 逻辑型, , 
赋值 (., 假)
返回 (假)


 ' 不属于任何一个程序集、类模块的函数：
