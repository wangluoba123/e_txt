 ' 文件类型：Windows模块源码

 ' 程序名称：汇编指令转换模块32
 ' 程序描述：
 ' 程序作者：本源码来自易语言资源网(www.5A5X.com)
 ' 邮政编码：
 ' 联系地址：
 ' 联系电话：
 ' 传真号码：
 ' 电子信箱：
 ' 主页地址：
 ' 版权声明：             易语言资源网注意事项
--============   www.5A5X.com  =============--
* 易语言资源网为易语言官方站、易语言官方论坛提供辅助资源站；本易语言资源网( www.5A5X.com)所有软件和资料均为软件作者提供和网友推荐发布而来，其版权归该软件和程序源码的合法拥有者所有，本站易语言资源网整理收集仅供易语言用户学习和易语言技术研究探讨使用，不得用于任何商业用途。如果由于以上原因造成的版权纠纷本站概不负责！
* 本站资源未经许可,任何网站不得非法盗链及抄袭本站资源；如引用，请注明来自易语言资源网，谢谢合作！
--============   www.5A5X.com  =============--
 ' 版本号：1.0
 ' 创建号：0.0

窗口 窗口1
    左边 = 50
    顶边 = 50
    宽度 = 684
    高度 = 400
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 真
    禁止 = 假
    边框 = 1
    底图方式 = 1
    底色 = -16777216 '  0xFF000000
    最大化按钮 = 真
    最小化按钮 = 真
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 真
    保持标题栏激活 = 假
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “”
    帮助文件名 = “”





 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 5 0 系统核心支持库
 ' spec A512548E76954B6E92C21055517615B0 3 0 特殊功能支持库




数据类型 程序代码数据类型1, , 
    .成员 代码1, 字节型, , , 
    .成员 代码2, 字节型, , , 
    .成员 寄存器选择位, 字节型, , , 
    .成员 扩展位sib, 字节型, , , 
    .成员 偏移量, 整数型, , , 
    .成员 立即数, 整数型, , , 
    .成员 指令集, 字节集, , , 
    .成员 长度标志, 字节型, , , 前4位偏移的长度，后4位立即数的长度,4位的第一位是否有
    .成员 位置标志, 字节型, , , 0位：是否有前缀，1位：是否有第2指令，
    .成员 跳转指针, 整数型, , , 指向一个跳转组的指针
    .成员 英文描述, 文本型, , , 
    .成员 中文描述, 文本型, , , 
    .成员 注释, 文本型, , , 

数据类型 跳转结构数据类型1, , 
    .成员 源指令ID, 整数型, , , 
    .成员 目的指令ID, 整数型, , , 

数据类型 跳转处理数据类型1, , 
    .成员 目前待处理跳转数, 整数型, , , 
    .成员 待处理行组, 整数型, , "1", 

数据类型 ea_N数据类型1, , 
    .成员 reg, 字节型, , , 
    .成员 mod, 字节型, , , 
    .成员 rm, 字节型, , , 
    .成员 mod__r_m文本, 文本型, , , 
    .成员 reg文本, 文本型, , , 

.全局变量 子程序组, 整数型, , "256", 
.全局变量 reg寄存器文本组, 文本型, , "30", 

.程序集 程序集1, , , 

.子程序 _启动子程序, 整数型, , 请在本子程序中放置易模块初始化代码
 ' --========  易语言资源网  (www.5A5X.com)  ======--
 ' 努力创建完善、持续更新的易语言学习例程源码资源站
 ' --================   www.5A5X.com  ===========--
 ' --==================   易语言资源网注意事项  ================--
 ' * 易语言资源网为易语言官方站、易语言官方论坛提供辅助资源站；
 ' 本易语言资源网( www.5A5X.com)所有软件和资料均为软件作者提
 ' 供和网友推荐发布而来，其版权归该软件和程序源码的合法拥有者所
 ' 有，本站易语言资源网整理收集仅供易语言用户学习和易语言技术研
 ' 究探讨使用，不得用于任何商业用途。如果由于以上原因造成的版权
 ' 纠纷本站概不负责！
 ' * 本站资源未经许可，任何网站不得非法盗链及抄袭本站资源；如引用
 ' 页面，请注明来自易语言资源网，谢谢合作！
 ' --=====================   www.5A5X.com  ================--

_临时子程序 () ' 在初始化代码执行完毕后调用测试代码
返回 (0) ' 可以根据您的需要返回任意数值

.子程序 _临时子程序, 空白型, , 
 ' 本名称子程序用作测试程序用，仅在开发及调试环境中有效，编译发布程序前将被系统自动清空，请将所有用作测试的临时代码放在本子程序中。 ***注意不要修改本子程序的名称、参数及返回值类型。
测试 ()


.子程序 测试, 空白型, 公开, 
载入 (窗口1, , 真)
返回 ()

.程序集 程序集2, , , 

.程序集变量 当前指令, 程序代码数据类型1, , , 
.程序集变量 输入指令的字节集, 字节集, , , 
.程序集变量 当前位置, 整数型, , , 
.程序集变量 前缀, 逻辑型, , , 
.程序集变量 错误, 逻辑型, , , 
.程序集变量 初使化, 逻辑型, , , 
.程序集变量 尺寸为32, 逻辑型, , , 
.程序集变量 opsiz, 逻辑型, , , 
.子程序 字节集转为汇编指令, 文本型, 公开, 当处理较大字符集时，时间可能较长！建议使用单行，可以控制进度！
.参数 输入字节集, 字节集, , 
.参数 是否32位指令, 逻辑型, 可空, 默认为32位指令

.局部变量 返回文本, 文本型, , , 
.局部变量 空结构, 程序代码数据类型1, , , 

赋值 (输入指令的字节集, 输入字节集)
赋值 (当前位置, 1)
.如果真 (是否为空 (是否32位指令))
    赋值 (是否32位指令, 真)
.如果真结束
赋值 (尺寸为32, 是否32位指令)
.如果真 (取反 (初使化))
    初使化子程序组结构 (是否32位指令)
.如果真结束
.循环判断首 ()
    赋值 (返回文本, 相加 (返回文本, 转为十六进制文本 (相减 (当前位置, 1), 8), “ : ”))
    赋值 (当前指令, 空结构)
    取指令 ()
    调用子程序 (子程序组 [相加 (当前指令.代码1, 1)], , , )
    赋值 (返回文本, 相加 (返回文本, 取指令集文本 (), 调整文本长度 (当前指令.英文描述, 50), #换行符))
    .如果真 (opsiz)
        赋值 (返回文本, 相加 (返回文本, 转为十六进制文本 (相减 (当前位置, 1), 8), “ : ”))
        赋值 (当前指令, 空结构)
        取指令 ()
        调用子程序 (子程序组 [相加 (当前指令.代码1, 1)], , , )
        赋值 (返回文本, 相加 (返回文本, 取指令集文本 (), 调整文本长度 (当前指令.英文描述, 50), #换行符))
         ' 本源码来自易语言资源网(www.5A5X.com)
        赋值 (opsiz, 假)
        赋值 (尺寸为32, 取反 (尺寸为32))
    .如果真结束
    
.循环判断尾 (并且 (不等于 (当前位置, -1), 小于或等于 (当前位置, 取字节集长度 (输入字节集)), 不等于 (当前位置, 0)))
返回 (返回文本)


.子程序 字节集转为汇编指令_单行, 文本型, , 返回字节集当前位置的汇编代码,位置会自动调整为下一指令起始处
.参数 输入字节集, 字节集, , 
.参数 位置, 整数型, 参考, 
.参数 是否32位指令, 逻辑型, , 

.局部变量 空结构, 程序代码数据类型1, , , 
.局部变量 返回文本, 文本型, , , 

赋值 (尺寸为32, 是否32位指令)
.如果真 (取反 (初使化))
    初使化子程序组结构 (是否32位指令)
.如果真结束
.如果真 (或者 (小于 (位置, 1), 大于 (位置, 取字节集长度 (输入字节集))))
    赋值 (位置, -1)
     ' 信息框 (“输入位置过小或过大”, 0, )
    返回 (“”)
.如果真结束
赋值 (当前位置, 位置)
赋值 (输入指令的字节集, 输入字节集)
赋值 (返回文本, 相加 (转为十六进制文本 (相减 (当前位置, 1), 8), “ : ”))
赋值 (当前指令, 空结构)
取指令 ()
调用子程序 (子程序组 [相加 (当前指令.代码1, 1)], , , )
赋值 (返回文本, 相加 (返回文本, 取指令集文本 (), 调整文本长度 (当前指令.英文描述, 50), #换行符))
赋值 (位置, 当前位置)
.如果真 (opsiz)
    赋值 (返回文本, 相加 (返回文本, 转为十六进制文本 (相减 (当前位置, 1), 8), “ : ”))
    赋值 (当前指令, 空结构)
    取指令 ()
    调用子程序 (子程序组 [相加 (当前指令.代码1, 1)], , , )
    赋值 (返回文本, 相加 (返回文本, 取指令集文本 (), 调整文本长度 (当前指令.英文描述, 50), #换行符))
    赋值 (位置, 当前位置)
    
    赋值 (opsiz, 假)
    赋值 (尺寸为32, 取反 (尺寸为32))
.如果真结束
返回 (返回文本)


.子程序 取指令集文本, 文本型, , 最大长度为24个字符
.局部变量 返回文本, 文本型, , , 
.局部变量 i, 整数型, , , 
.局部变量 x, 文本型, , , 

赋值 (i, 1)
.计次循环首 (取字节集长度 (当前指令.指令集), )
    赋值 (x, 取十六进制文本 (取字节集数据 (当前指令.指令集, 1, i)))
    .如果真 (等于 (取文本长度 (x), 1))
        赋值 (x, 相加 (“0”, x))
    .如果真结束
    赋值 (返回文本, 相加 (返回文本, x))
.计次循环尾 ()
返回 (调整文本长度 (返回文本, 24))


.子程序 变更代码指令操作数, 空白型, , 在编译过程中变更操作位用
.参数 是否32位指令, 逻辑型, , 

赋值 (尺寸为32, 是否32位指令)


.子程序 初使化子程序组结构, 空白型, , 
.参数 是否32位指令, 逻辑型, , 

赋值 (尺寸为32, 是否32位指令)

赋值 (当前位置, 1)
赋值 (reg寄存器文本组 [1], “al”)
赋值 (reg寄存器文本组 [2], “cl”)
赋值 (reg寄存器文本组 [3], “dl”)
赋值 (reg寄存器文本组 [4], “bl”)
赋值 (reg寄存器文本组 [5], “ah”)
赋值 (reg寄存器文本组 [6], “ch”)
赋值 (reg寄存器文本组 [7], “dh”)
赋值 (reg寄存器文本组 [8], “bh”)
赋值 (reg寄存器文本组 [9], “eax”)
赋值 (reg寄存器文本组 [10], “ecx”)
赋值 (reg寄存器文本组 [11], “edx”)
赋值 (reg寄存器文本组 [12], “ebx”)
赋值 (reg寄存器文本组 [13], “esp”)
赋值 (reg寄存器文本组 [14], “ebp”)
赋值 (reg寄存器文本组 [15], “esi”)
赋值 (reg寄存器文本组 [16], “edi”)
赋值 (reg寄存器文本组 [17], “es”)
赋值 (reg寄存器文本组 [18], “cs”)
赋值 (reg寄存器文本组 [19], “ss”)
赋值 (reg寄存器文本组 [20], “ds”)
赋值 (reg寄存器文本组 [21], “fs”)
赋值 (reg寄存器文本组 [22], “gs”)
赋值 (reg寄存器文本组 [23], “ax”)
赋值 (reg寄存器文本组 [24], “cx”)
赋值 (reg寄存器文本组 [25], “dx”)
赋值 (reg寄存器文本组 [26], “bx”)
赋值 (reg寄存器文本组 [27], “sp”)
赋值 (reg寄存器文本组 [28], “bp”)
赋值 (reg寄存器文本组 [29], “si”)
赋值 (reg寄存器文本组 [30], “di”)

赋值 (子程序组 [1], 取子程序地址 (&子程序1))
赋值 (子程序组 [2], 取子程序地址 (&子程序2))
赋值 (子程序组 [3], 取子程序地址 (&子程序3))
赋值 (子程序组 [4], 取子程序地址 (&子程序4))
赋值 (子程序组 [5], 取子程序地址 (&子程序5))
赋值 (子程序组 [6], 取子程序地址 (&子程序6))
赋值 (子程序组 [7], 取子程序地址 (&子程序7))
赋值 (子程序组 [8], 取子程序地址 (&子程序8))
赋值 (子程序组 [9], 取子程序地址 (&子程序9))
赋值 (子程序组 [10], 取子程序地址 (&子程序10))
赋值 (子程序组 [11], 取子程序地址 (&子程序11))
赋值 (子程序组 [12], 取子程序地址 (&子程序12))
赋值 (子程序组 [13], 取子程序地址 (&子程序13))
赋值 (子程序组 [14], 取子程序地址 (&子程序14))
赋值 (子程序组 [15], 取子程序地址 (&子程序15))
赋值 (子程序组 [16], 取子程序地址 (&子程序16))
赋值 (子程序组 [17], 取子程序地址 (&子程序17))
赋值 (子程序组 [18], 取子程序地址 (&子程序18))
赋值 (子程序组 [19], 取子程序地址 (&子程序19))
赋值 (子程序组 [20], 取子程序地址 (&子程序20))
赋值 (子程序组 [21], 取子程序地址 (&子程序21))
赋值 (子程序组 [22], 取子程序地址 (&子程序22))
赋值 (子程序组 [23], 取子程序地址 (&子程序23))
赋值 (子程序组 [24], 取子程序地址 (&子程序24))
赋值 (子程序组 [25], 取子程序地址 (&子程序25))
赋值 (子程序组 [26], 取子程序地址 (&子程序26))
赋值 (子程序组 [27], 取子程序地址 (&子程序27))
赋值 (子程序组 [28], 取子程序地址 (&子程序28))
赋值 (子程序组 [29], 取子程序地址 (&子程序29))
赋值 (子程序组 [30], 取子程序地址 (&子程序30))
赋值 (子程序组 [31], 取子程序地址 (&子程序31))
赋值 (子程序组 [32], 取子程序地址 (&子程序32))
赋值 (子程序组 [33], 取子程序地址 (&子程序33))
赋值 (子程序组 [34], 取子程序地址 (&子程序34))
赋值 (子程序组 [35], 取子程序地址 (&子程序35))
赋值 (子程序组 [36], 取子程序地址 (&子程序36))
赋值 (子程序组 [37], 取子程序地址 (&子程序37))
赋值 (子程序组 [38], 取子程序地址 (&子程序38))
赋值 (子程序组 [39], 取子程序地址 (&子程序39))
赋值 (子程序组 [40], 取子程序地址 (&子程序40))
赋值 (子程序组 [41], 取子程序地址 (&子程序41))
赋值 (子程序组 [42], 取子程序地址 (&子程序42))
赋值 (子程序组 [43], 取子程序地址 (&子程序43))
赋值 (子程序组 [44], 取子程序地址 (&子程序44))
赋值 (子程序组 [45], 取子程序地址 (&子程序45))
赋值 (子程序组 [46], 取子程序地址 (&子程序46))
赋值 (子程序组 [47], 取子程序地址 (&子程序47))
赋值 (子程序组 [48], 取子程序地址 (&子程序48))
赋值 (子程序组 [49], 取子程序地址 (&子程序49))
赋值 (子程序组 [50], 取子程序地址 (&子程序50))
赋值 (子程序组 [51], 取子程序地址 (&子程序51))
赋值 (子程序组 [52], 取子程序地址 (&子程序52))
赋值 (子程序组 [53], 取子程序地址 (&子程序53))
赋值 (子程序组 [54], 取子程序地址 (&子程序54))
赋值 (子程序组 [55], 取子程序地址 (&子程序55))
赋值 (子程序组 [56], 取子程序地址 (&子程序56))
赋值 (子程序组 [57], 取子程序地址 (&子程序57))
赋值 (子程序组 [58], 取子程序地址 (&子程序58))
赋值 (子程序组 [59], 取子程序地址 (&子程序59))
赋值 (子程序组 [60], 取子程序地址 (&子程序60))
赋值 (子程序组 [61], 取子程序地址 (&子程序61))
赋值 (子程序组 [62], 取子程序地址 (&子程序62))
赋值 (子程序组 [63], 取子程序地址 (&子程序63))
赋值 (子程序组 [64], 取子程序地址 (&子程序64))
赋值 (子程序组 [65], 取子程序地址 (&子程序65))
赋值 (子程序组 [66], 取子程序地址 (&子程序66))
赋值 (子程序组 [67], 取子程序地址 (&子程序67))
赋值 (子程序组 [68], 取子程序地址 (&子程序68))
赋值 (子程序组 [69], 取子程序地址 (&子程序69))
赋值 (子程序组 [70], 取子程序地址 (&子程序70))
赋值 (子程序组 [71], 取子程序地址 (&子程序71))
赋值 (子程序组 [72], 取子程序地址 (&子程序72))
赋值 (子程序组 [73], 取子程序地址 (&子程序73))
赋值 (子程序组 [74], 取子程序地址 (&子程序74))
赋值 (子程序组 [75], 取子程序地址 (&子程序75))
赋值 (子程序组 [76], 取子程序地址 (&子程序76))
赋值 (子程序组 [77], 取子程序地址 (&子程序77))
赋值 (子程序组 [78], 取子程序地址 (&子程序78))
赋值 (子程序组 [79], 取子程序地址 (&子程序79))
赋值 (子程序组 [80], 取子程序地址 (&子程序80))
赋值 (子程序组 [81], 取子程序地址 (&子程序81))
赋值 (子程序组 [82], 取子程序地址 (&子程序82))
赋值 (子程序组 [83], 取子程序地址 (&子程序83))
赋值 (子程序组 [84], 取子程序地址 (&子程序84))
赋值 (子程序组 [85], 取子程序地址 (&子程序85))
赋值 (子程序组 [86], 取子程序地址 (&子程序86))
赋值 (子程序组 [87], 取子程序地址 (&子程序87))
赋值 (子程序组 [88], 取子程序地址 (&子程序88))
赋值 (子程序组 [89], 取子程序地址 (&子程序89))
赋值 (子程序组 [90], 取子程序地址 (&子程序90))
赋值 (子程序组 [91], 取子程序地址 (&子程序91))
赋值 (子程序组 [92], 取子程序地址 (&子程序92))
赋值 (子程序组 [93], 取子程序地址 (&子程序93))
赋值 (子程序组 [94], 取子程序地址 (&子程序94))
赋值 (子程序组 [95], 取子程序地址 (&子程序95))
赋值 (子程序组 [96], 取子程序地址 (&子程序96))
赋值 (子程序组 [97], 取子程序地址 (&子程序97))
赋值 (子程序组 [98], 取子程序地址 (&子程序98))
赋值 (子程序组 [99], 取子程序地址 (&子程序99))
赋值 (子程序组 [100], 取子程序地址 (&子程序100))
赋值 (子程序组 [101], 取子程序地址 (&子程序101))
赋值 (子程序组 [102], 取子程序地址 (&子程序102))
赋值 (子程序组 [103], 取子程序地址 (&子程序103))
赋值 (子程序组 [104], 取子程序地址 (&子程序104))
赋值 (子程序组 [105], 取子程序地址 (&子程序105))
赋值 (子程序组 [106], 取子程序地址 (&子程序106))
赋值 (子程序组 [107], 取子程序地址 (&子程序107))
赋值 (子程序组 [108], 取子程序地址 (&子程序108))
赋值 (子程序组 [109], 取子程序地址 (&子程序109))
赋值 (子程序组 [110], 取子程序地址 (&子程序110))
赋值 (子程序组 [111], 取子程序地址 (&子程序111))
赋值 (子程序组 [112], 取子程序地址 (&子程序112))
赋值 (子程序组 [113], 取子程序地址 (&子程序113))
赋值 (子程序组 [114], 取子程序地址 (&子程序114))
赋值 (子程序组 [115], 取子程序地址 (&子程序115))
赋值 (子程序组 [116], 取子程序地址 (&子程序116))
赋值 (子程序组 [117], 取子程序地址 (&子程序117))
赋值 (子程序组 [118], 取子程序地址 (&子程序118))
赋值 (子程序组 [119], 取子程序地址 (&子程序119))
赋值 (子程序组 [120], 取子程序地址 (&子程序120))
赋值 (子程序组 [121], 取子程序地址 (&子程序121))
赋值 (子程序组 [122], 取子程序地址 (&子程序122))
赋值 (子程序组 [123], 取子程序地址 (&子程序123))
赋值 (子程序组 [124], 取子程序地址 (&子程序124))
赋值 (子程序组 [125], 取子程序地址 (&子程序125))
赋值 (子程序组 [126], 取子程序地址 (&子程序126))
赋值 (子程序组 [127], 取子程序地址 (&子程序127))
赋值 (子程序组 [128], 取子程序地址 (&子程序128))
赋值 (子程序组 [129], 取子程序地址 (&子程序129))
赋值 (子程序组 [130], 取子程序地址 (&子程序130))
赋值 (子程序组 [131], 取子程序地址 (&子程序131))
赋值 (子程序组 [132], 取子程序地址 (&子程序132))
赋值 (子程序组 [133], 取子程序地址 (&子程序133))
赋值 (子程序组 [134], 取子程序地址 (&子程序134))
赋值 (子程序组 [135], 取子程序地址 (&子程序135))
赋值 (子程序组 [136], 取子程序地址 (&子程序136))
赋值 (子程序组 [137], 取子程序地址 (&子程序137))
赋值 (子程序组 [138], 取子程序地址 (&子程序138))
赋值 (子程序组 [139], 取子程序地址 (&子程序139))
赋值 (子程序组 [140], 取子程序地址 (&子程序140))
赋值 (子程序组 [141], 取子程序地址 (&子程序141))
赋值 (子程序组 [142], 取子程序地址 (&子程序142))
赋值 (子程序组 [143], 取子程序地址 (&子程序143))
赋值 (子程序组 [144], 取子程序地址 (&子程序144))
赋值 (子程序组 [145], 取子程序地址 (&子程序145))
赋值 (子程序组 [146], 取子程序地址 (&子程序146))
赋值 (子程序组 [147], 取子程序地址 (&子程序147))
赋值 (子程序组 [148], 取子程序地址 (&子程序148))
赋值 (子程序组 [149], 取子程序地址 (&子程序149))
赋值 (子程序组 [150], 取子程序地址 (&子程序150))
赋值 (子程序组 [151], 取子程序地址 (&子程序151))
赋值 (子程序组 [152], 取子程序地址 (&子程序152))
赋值 (子程序组 [153], 取子程序地址 (&子程序153))
赋值 (子程序组 [154], 取子程序地址 (&子程序154))
赋值 (子程序组 [155], 取子程序地址 (&子程序155))
赋值 (子程序组 [156], 取子程序地址 (&子程序156))
赋值 (子程序组 [157], 取子程序地址 (&子程序157))
赋值 (子程序组 [158], 取子程序地址 (&子程序158))
赋值 (子程序组 [159], 取子程序地址 (&子程序159))
赋值 (子程序组 [160], 取子程序地址 (&子程序160))
赋值 (子程序组 [161], 取子程序地址 (&子程序161))
赋值 (子程序组 [162], 取子程序地址 (&子程序162))
赋值 (子程序组 [163], 取子程序地址 (&子程序163))
赋值 (子程序组 [164], 取子程序地址 (&子程序164))
赋值 (子程序组 [165], 取子程序地址 (&子程序165))
赋值 (子程序组 [166], 取子程序地址 (&子程序166))
赋值 (子程序组 [167], 取子程序地址 (&子程序167))
赋值 (子程序组 [168], 取子程序地址 (&子程序168))
赋值 (子程序组 [169], 取子程序地址 (&子程序169))
赋值 (子程序组 [170], 取子程序地址 (&子程序170))
赋值 (子程序组 [171], 取子程序地址 (&子程序171))
赋值 (子程序组 [172], 取子程序地址 (&子程序172))
赋值 (子程序组 [173], 取子程序地址 (&子程序173))
赋值 (子程序组 [174], 取子程序地址 (&子程序174))
赋值 (子程序组 [175], 取子程序地址 (&子程序175))
赋值 (子程序组 [176], 取子程序地址 (&子程序176))
赋值 (子程序组 [177], 取子程序地址 (&子程序177))
赋值 (子程序组 [178], 取子程序地址 (&子程序178))
赋值 (子程序组 [179], 取子程序地址 (&子程序179))
赋值 (子程序组 [180], 取子程序地址 (&子程序180))
赋值 (子程序组 [181], 取子程序地址 (&子程序181))
赋值 (子程序组 [182], 取子程序地址 (&子程序182))
赋值 (子程序组 [183], 取子程序地址 (&子程序183))
赋值 (子程序组 [184], 取子程序地址 (&子程序184))
赋值 (子程序组 [185], 取子程序地址 (&子程序185))
赋值 (子程序组 [186], 取子程序地址 (&子程序186))
赋值 (子程序组 [187], 取子程序地址 (&子程序187))
赋值 (子程序组 [188], 取子程序地址 (&子程序188))
赋值 (子程序组 [189], 取子程序地址 (&子程序189))
赋值 (子程序组 [190], 取子程序地址 (&子程序190))
赋值 (子程序组 [191], 取子程序地址 (&子程序191))
赋值 (子程序组 [192], 取子程序地址 (&子程序192))
赋值 (子程序组 [193], 取子程序地址 (&子程序193))
赋值 (子程序组 [194], 取子程序地址 (&子程序194))
赋值 (子程序组 [195], 取子程序地址 (&子程序195))
赋值 (子程序组 [196], 取子程序地址 (&子程序196))
赋值 (子程序组 [197], 取子程序地址 (&子程序197))
赋值 (子程序组 [198], 取子程序地址 (&子程序198))
赋值 (子程序组 [199], 取子程序地址 (&子程序199))
赋值 (子程序组 [200], 取子程序地址 (&子程序200))
赋值 (子程序组 [201], 取子程序地址 (&子程序201))
赋值 (子程序组 [202], 取子程序地址 (&子程序202))
赋值 (子程序组 [203], 取子程序地址 (&子程序203))
赋值 (子程序组 [204], 取子程序地址 (&子程序204))
赋值 (子程序组 [205], 取子程序地址 (&子程序205))
赋值 (子程序组 [206], 取子程序地址 (&子程序206))
赋值 (子程序组 [207], 取子程序地址 (&子程序207))
赋值 (子程序组 [208], 取子程序地址 (&子程序208))
赋值 (子程序组 [209], 取子程序地址 (&子程序209))
赋值 (子程序组 [210], 取子程序地址 (&子程序210))
赋值 (子程序组 [211], 取子程序地址 (&子程序211))
赋值 (子程序组 [212], 取子程序地址 (&子程序212))
赋值 (子程序组 [213], 取子程序地址 (&子程序213))
赋值 (子程序组 [214], 取子程序地址 (&子程序214))
赋值 (子程序组 [215], 取子程序地址 (&子程序215))
赋值 (子程序组 [216], 取子程序地址 (&子程序216))
赋值 (子程序组 [217], 取子程序地址 (&子程序217))
赋值 (子程序组 [218], 取子程序地址 (&子程序218))
赋值 (子程序组 [219], 取子程序地址 (&子程序219))
赋值 (子程序组 [220], 取子程序地址 (&子程序220))
赋值 (子程序组 [221], 取子程序地址 (&子程序221))
赋值 (子程序组 [222], 取子程序地址 (&子程序222))
赋值 (子程序组 [223], 取子程序地址 (&子程序223))
赋值 (子程序组 [224], 取子程序地址 (&子程序224))
赋值 (子程序组 [225], 取子程序地址 (&子程序225))
赋值 (子程序组 [226], 取子程序地址 (&子程序226))
赋值 (子程序组 [227], 取子程序地址 (&子程序227))
赋值 (子程序组 [228], 取子程序地址 (&子程序228))
赋值 (子程序组 [229], 取子程序地址 (&子程序229))
赋值 (子程序组 [230], 取子程序地址 (&子程序230))
赋值 (子程序组 [231], 取子程序地址 (&子程序231))
赋值 (子程序组 [232], 取子程序地址 (&子程序232))
赋值 (子程序组 [233], 取子程序地址 (&子程序233))
赋值 (子程序组 [234], 取子程序地址 (&子程序234))
赋值 (子程序组 [235], 取子程序地址 (&子程序235))
赋值 (子程序组 [236], 取子程序地址 (&子程序236))
赋值 (子程序组 [237], 取子程序地址 (&子程序237))
赋值 (子程序组 [238], 取子程序地址 (&子程序238))
赋值 (子程序组 [239], 取子程序地址 (&子程序239))
赋值 (子程序组 [240], 取子程序地址 (&子程序240))
赋值 (子程序组 [241], 取子程序地址 (&子程序241))
赋值 (子程序组 [242], 取子程序地址 (&子程序242))
赋值 (子程序组 [243], 取子程序地址 (&子程序243))
赋值 (子程序组 [244], 取子程序地址 (&子程序244))
赋值 (子程序组 [245], 取子程序地址 (&子程序245))
赋值 (子程序组 [246], 取子程序地址 (&子程序246))
赋值 (子程序组 [247], 取子程序地址 (&子程序247))
赋值 (子程序组 [248], 取子程序地址 (&子程序248))
赋值 (子程序组 [249], 取子程序地址 (&子程序249))
赋值 (子程序组 [250], 取子程序地址 (&子程序250))
赋值 (子程序组 [251], 取子程序地址 (&子程序251))
赋值 (子程序组 [252], 取子程序地址 (&子程序252))
赋值 (子程序组 [253], 取子程序地址 (&子程序253))
赋值 (子程序组 [254], 取子程序地址 (&子程序254))
赋值 (子程序组 [255], 取子程序地址 (&子程序255))
赋值 (子程序组 [256], 取子程序地址 (&子程序256))

赋值 (初使化, 真)


.子程序 取指令, 空白型, , 
赋值 (当前指令.代码1, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (当前指令.代码1)))


.子程序 转为十六进制文本, 文本型, , 
.参数 i, 整数型, , 
.参数 长度, 整数型, , 

.局部变量 x, 文本型, , , 

 ' 转换为16进制文本
赋值 (x, 取文本右边 (取十六进制文本 (i), 长度))
.计次循环首 (相减 (长度, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)


.子程序 调整文本长度, 文本型, , 
.参数 i, 文本型, , 
.参数 长度, 整数型, , 

赋值 (i, 取文本右边 (i, 长度))
.计次循环首 (相减 (长度, 取文本长度 (i)), )
    赋值 (i, 相加 (i, “ ”))
.计次循环尾 ()
返回 (i)


.子程序 取32位数据, 文本型, , 
.局部变量 x, 文本型, , , 

赋值 (当前指令.立即数, 取字节集数据 (输入指令的字节集, 3, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (当前指令.立即数)))
赋值 (当前指令.长度标志, 位或 (当前指令.长度标志, 12))
 ' 转换为16进制文本
赋值 (x, 取十六进制文本 (当前指令.立即数))
.计次循环首 (相减 (8, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)
 ' 本源码来自易语言资源网(www.5A5X.com)

.子程序 取16位数据, 文本型, , 
.局部变量 x, 文本型, , , 

赋值 (当前指令.立即数, 取字节集数据 (输入指令的字节集, 2, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (到短整数 (当前指令.立即数))))
赋值 (当前指令.长度标志, 位或 (当前指令.长度标志, 10))
 ' 转换为16进制文本
赋值 (x, 取十六进制文本 (当前指令.立即数))
赋值 (x, 取文本右边 (x, 4))
.计次循环首 (相减 (4, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)


.子程序 取8位数据, 文本型, , 
.局部变量 x, 文本型, , , 

赋值 (当前指令.立即数, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (到字节 (当前指令.立即数))))
赋值 (当前指令.长度标志, 位或 (当前指令.长度标志, 9))
 ' 转换为16进制文本
赋值 (x, 取十六进制文本 (当前指令.立即数))
赋值 (x, 取文本右边 (x, 4))
.计次循环首 (相减 (2, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)


.子程序 sib取值, 文本型, , 
.参数 mod, 字节型, , 

.局部变量 基址, 字节型, , , 
.局部变量 变址, 字节型, , , 
.局部变量 ss, 字节型, , , 
.局部变量 返回文本, 文本型, , , 

赋值 (当前指令.扩展位sib, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (当前指令.扩展位sib)))
赋值 (基址, 位与 (当前指令.扩展位sib, 7))
赋值 (变址, 右移 (位与 (当前指令.扩展位sib, 56), 3))
赋值 (ss, 右移 (位与 (当前指令.扩展位sib, 192), 6))
.判断开始 (等于 (mod, 0))
    赋值 (返回文本, 相加 (“ds:[”, reg寄存器文本组 [相加 (基址, 9)]))
    .如果真 (等于 (变址, 4))
        返回 (相加 (返回文本, “]”))
    .如果真结束
    .如果真 (等于 (基址, 6))
        返回 (相加 (“ds:[”, 取32位数据 (), “]”))
    .如果真结束
    赋值 (返回文本, 相加 (返回文本, “+”, reg寄存器文本组 [相加 (变址, 9)]))
    .判断开始 (等于 (ss, 1))
        赋值 (返回文本, 相加 (返回文本, “*2”, “]”))
    .判断 (等于 (ss, 2))
        赋值 (返回文本, 相加 (返回文本, “*4”, “]”))
    .判断 (等于 (ss, 3))
        赋值 (返回文本, 相加 (返回文本, “*8”, “]”))
    .默认
        
    .判断结束
    
.判断 (等于 (mod, 1))
    .如果 (或者 (等于 (基址, 4), 等于 (基址, 5)))
        赋值 (返回文本, 相加 (“ss:[”, reg寄存器文本组 [相加 (基址, 9)], “+”))
    .否则
        赋值 (返回文本, 相加 (“ds:[”, reg寄存器文本组 [相加 (基址, 9)], “+”))
    .如果结束
    .如果真 (不等于 (变址, 4))
        赋值 (返回文本, 相加 (返回文本, reg寄存器文本组 [相加 (变址, 9)]))
        .判断开始 (等于 (ss, 1))
            赋值 (返回文本, 相加 (返回文本, “*2+”))
        .判断 (等于 (ss, 2))
            赋值 (返回文本, 相加 (返回文本, “*4+”))
        .判断 (等于 (ss, 3))
            赋值 (返回文本, 相加 (返回文本, “*8+”))
        .默认
            
        .判断结束
        
    .如果真结束
    赋值 (返回文本, 相加 (返回文本, 取8位数据 (), “]”))
.判断 (等于 (mod, 2))
    .如果 (或者 (等于 (基址, 4), 等于 (基址, 5)))
        赋值 (返回文本, 相加 (“ss:[”, reg寄存器文本组 [相加 (基址, 9)], “+”))
    .否则
        赋值 (返回文本, 相加 (“ds:[”, reg寄存器文本组 [相加 (基址, 9)], “+”))
    .如果结束
    赋值 (返回文本, 相加 (返回文本, reg寄存器文本组 [相加 (变址, 9)]))
    .判断开始 (等于 (ss, 1))
        赋值 (返回文本, 相加 (返回文本, “*2+”))
    .判断 (等于 (ss, 2))
        赋值 (返回文本, 相加 (返回文本, “*4+”))
    .判断 (等于 (ss, 3))
        赋值 (返回文本, 相加 (返回文本, “*8+”))
    .默认
        
    .判断结束
    赋值 (返回文本, 相加 (返回文本, 取8位数据 (), “]”))
.默认
    
.判断结束
返回 (返回文本)


.子程序 ea处理_一般, 空白型, , 
.参数 w, 逻辑型, 可空, 0:假,1:真
.参数 d, 逻辑型, , 0:假,1:真

.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 
.局部变量 reg文本, 文本型, , , 
.局部变量 mod__r_m文本, 文本型, , , 
.局部变量 尺寸前缀, 文本型, , , 

赋值 (当前指令.寄存器选择位, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (当前指令.寄存器选择位)))

.如果 (尺寸为32)
     ' 32位操作指令
    赋值 (reg, 右移 (位与 (当前指令.寄存器选择位, 56), 3))
    .如果 (或者 (是否为空 (w), 等于 (w, 真)))
        赋值 (reg文本, reg寄存器文本组 [相加 (reg, 9)])
        赋值 (尺寸前缀, “dword ptr ”)
    .否则
        赋值 (reg文本, reg寄存器文本组 [相加 (reg, 1)])
        赋值 (尺寸前缀, “byte ptr ”)
    .如果结束
    
    赋值 (mod, 右移 (位与 (当前指令.寄存器选择位, 192), 6))
    赋值 (rm, 位与 (当前指令.寄存器选择位, 7))
    .判断开始 (等于 (mod, 3))
        .如果 (或者 (是否为空 (w), 等于 (w, 真)))
            赋值 (mod__r_m文本, reg寄存器文本组 [相加 (rm, 9)])
        .否则
            赋值 (mod__r_m文本, reg寄存器文本组 [相加 (rm, 1)])
        .如果结束
        
    .判断 (等于 (mod, 0))
        .判断开始 (等于 (rm, 5))
            赋值 (mod__r_m文本, 相加 (尺寸前缀, “ds:[”, 取32位数据 (), “]”))
        .判断 (等于 (rm, 4))
            赋值 (mod__r_m文本, 相加 (尺寸前缀, sib取值 (mod)))
        .默认
            赋值 (mod__r_m文本, 相加 (尺寸前缀, “ds:[”, reg寄存器文本组 [相加 (rm, 9)], “]”))
        .判断结束
        
    .判断 (等于 (mod, 1))
        .判断开始 (等于 (rm, 4))
            赋值 (mod__r_m文本, 相加 (尺寸前缀, sib取值 (mod)))
        .判断 (等于 (rm, 5))
            赋值 (mod__r_m文本, 相加 (尺寸前缀, “ss:[ebp+”, 取8位数据 (), “]”))
        .默认
            赋值 (mod__r_m文本, 相加 (尺寸前缀, “ds:[”, reg寄存器文本组 [相加 (rm, 9)], “+”, 取8位数据 (), “]”))
        .判断结束
        
    .判断 (等于 (mod, 2))
        .判断开始 (等于 (rm, 4))
            赋值 (mod__r_m文本, 相加 (尺寸前缀, sib取值 (mod)))
        .判断 (等于 (rm, 5))
            赋值 (mod__r_m文本, 相加 (尺寸前缀, “ss:[ebp+”, 取32位数据 (), “]”))
        .默认
            赋值 (mod__r_m文本, 相加 (尺寸前缀, “ds:[”, reg寄存器文本组 [相加 (rm, 9)], “+”, 取32位数据 (), “]”))
        .判断结束
        
    .默认
        
    .判断结束
    .如果 (d)
        赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, reg文本, “,”, mod__r_m文本))
    .否则
        赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, mod__r_m文本, “,”, reg文本))
    .如果结束
    
.否则
     ' 16位操作数指令
    赋值 (reg, 右移 (位与 (当前指令.寄存器选择位, 56), 3))
    .如果 (或者 (是否为空 (w), 等于 (w, 真)))
        赋值 (reg文本, reg寄存器文本组 [相加 (reg, 23)])
        赋值 (尺寸前缀, “word ptr ”)
    .否则
        赋值 (reg文本, reg寄存器文本组 [相加 (reg, 1)])
        赋值 (尺寸前缀, “byte ptr ”)
    .如果结束
    
    赋值 (mod, 右移 (位与 (当前指令.寄存器选择位, 192), 6))
    赋值 (rm, 位与 (当前指令.寄存器选择位, 7))
    .判断开始 (等于 (mod, 3))
        .如果 (或者 (是否为空 (w), 等于 (w, 真)))
            赋值 (mod__r_m文本, reg寄存器文本组 [相加 (rm, 23)])
        .否则
            赋值 (mod__r_m文本, reg寄存器文本组 [相加 (rm, 1)])
        .如果结束
        
    .判断 (等于 (mod, 0))
        .判断开始 (等于 (rm, 0))
            赋值 (mod__r_m文本, “ds:[bx+si]”)
        .判断 (等于 (rm, 1))
            赋值 (mod__r_m文本, “ds:[bx+di]”)
        .判断 (等于 (rm, 2))
            赋值 (mod__r_m文本, “ss:[bp+si]”)
        .判断 (等于 (rm, 3))
            赋值 (mod__r_m文本, “ss:[bp+di]”)
        .判断 (等于 (rm, 4))
            赋值 (mod__r_m文本, “ds:[si]”)
        .判断 (等于 (rm, 5))
            赋值 (mod__r_m文本, “ds:[di]”)
        .判断 (等于 (rm, 6))
            赋值 (mod__r_m文本, 相加 (“ds:[”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 7))
            赋值 (mod__r_m文本, “ds:[bx]”)
        .默认
            
        .判断结束
        
    .判断 (等于 (mod, 1))
        .判断开始 (等于 (rm, 0))
            赋值 (mod__r_m文本, 相加 (“ds:[bx+si+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 1))
            赋值 (mod__r_m文本, 相加 (“ds:[bx+di+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 2))
            赋值 (mod__r_m文本, 相加 (“ss:[bp+si+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 3))
            赋值 (mod__r_m文本, 相加 (“ss:[bp+di+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 4))
            赋值 (mod__r_m文本, 相加 (“ds:[si+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 5))
            赋值 (mod__r_m文本, 相加 (“ds:[di+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 6))
            赋值 (mod__r_m文本, 相加 (“ss:[bp+”, 取8位数据 (), “]”))
        .判断 (等于 (rm, 7))
            赋值 (mod__r_m文本, 相加 (“ds:[bx+”, 取8位数据 (), “]”))
        .默认
            
        .判断结束
        
    .判断 (等于 (mod, 2))
        .判断开始 (等于 (rm, 0))
            赋值 (mod__r_m文本, 相加 (“ds:[bx+si+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 1))
            赋值 (mod__r_m文本, 相加 (“ds:[bx+di+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 2))
            赋值 (mod__r_m文本, 相加 (“ss:[bp+si+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 3))
            赋值 (mod__r_m文本, 相加 (“ss:[bp+di+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 4))
            赋值 (mod__r_m文本, 相加 (“ds:[si+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 5))
            赋值 (mod__r_m文本, 相加 (“ds:[di+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 6))
            赋值 (mod__r_m文本, 相加 (“ss:[bp+”, 取16位数据 (), “]”))
        .判断 (等于 (rm, 7))
            赋值 (mod__r_m文本, 相加 (“ds:[bx+”, 取16位数据 (), “]”))
        .默认
            
        .判断结束
        
    .默认
        
    .判断结束
    .如果 (d)
        赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, reg文本, “,”, mod__r_m文本))
    .否则
        赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, mod__r_m文本, “,”, reg文本))
    .如果结束
    
.如果结束


.子程序 取偏移地址_8位, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 文本型, , , 
.局部变量 j, 整数型, , , 

赋值 (i, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (i)))
赋值 (当前指令.长度标志, 位或 (当前指令.长度标志, 9))
 ' 转换为16进制文本
赋值 (j, i)
.如果真 (等于 (位与 (i, 128), 128))
    赋值 (j, 相减 (i, 256))
.如果真结束
赋值 (x, 取十六进制文本 (相减 (相加 (j, 当前位置), 1)))
.计次循环首 (相减 (8, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)


.子程序 取偏移地址_16位, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 x, 文本型, , , 

赋值 (i, 取字节集数据 (输入指令的字节集, 2, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (i)))
赋值 (当前指令.长度标志, 位或 (当前指令.长度标志, 9))
 ' 转换为16进制文本
赋值 (x, 取十六进制文本 (相减 (相加 (i, 当前位置), 1)))
.计次循环首 (相减 (8, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)


.子程序 取偏移地址_32位, 文本型, , 
.局部变量 i, 整数型, , , 
.局部变量 x, 文本型, , , 

赋值 (i, 取字节集数据 (输入指令的字节集, 3, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (i)))
赋值 (当前指令.长度标志, 位或 (当前指令.长度标志, 9))
 ' 转换为16进制文本
赋值 (x, 取十六进制文本 (相减 (相加 (i, 当前位置), 1)))
.计次循环首 (相减 (8, 取文本长度 (x)), )
    赋值 (x, 相加 (“0”, x))
.计次循环尾 ()
返回 (x)


.子程序 ea处理_N, ea_N数据类型1, , 
.参数 w, 逻辑型, , 0:假,1:真 是否32位

.局部变量 reg, 字节型, , , 
.局部变量 i, ea_N数据类型1, , , 
.局部变量 尺寸前缀, 文本型, , , 

赋值 (当前指令.寄存器选择位, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (当前指令.寄存器选择位)))
 ' 本源码来自易语言资源网(www.5A5X.com)
.如果 (尺寸为32)
     ' 32位指令
    赋值 (i.reg, 右移 (位与 (当前指令.寄存器选择位, 56), 3))
    .如果 (w)
        赋值 (i.reg文本, reg寄存器文本组 [相加 (i.reg, 9)])
        .如果 (尺寸为32)
            赋值 (尺寸前缀, “dword ptr ”)
        .否则
            赋值 (尺寸前缀, “word ptr ”)
        .如果结束
        
    .否则
        赋值 (i.reg文本, reg寄存器文本组 [相加 (i.reg, 1)])
        赋值 (尺寸前缀, “byte ptr ”)
    .如果结束
    
    赋值 (i.mod, 右移 (位与 (当前指令.寄存器选择位, 192), 6))
    赋值 (i.rm, 位与 (当前指令.寄存器选择位, 7))
    .判断开始 (等于 (i.mod, 3))
        .如果 (w)
            赋值 (i.mod__r_m文本, reg寄存器文本组 [相加 (i.rm, 9)])
        .否则
            赋值 (i.mod__r_m文本, reg寄存器文本组 [相加 (i.rm, 1)])
        .如果结束
        
    .判断 (等于 (i.mod, 0))
        .判断开始 (等于 (i.rm, 5))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[”, 取32位数据 (), “]”))
        .判断 (等于 (i.rm, 4))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, sib取值 (i.mod)))
        .默认
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[”, reg寄存器文本组 [相加 (i.rm, 9)], “]”))
        .判断结束
        
    .判断 (等于 (i.mod, 1))
        .判断开始 (等于 (i.rm, 4))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, sib取值 (i.mod)))
        .判断 (等于 (i.rm, 5))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[ebp+”, 取8位数据 (), “]”))
        .默认
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[”, reg寄存器文本组 [相加 (i.rm, 9)], “+”, 取8位数据 (), “]”))
        .判断结束
        
    .判断 (等于 (i.mod, 2))
        .判断开始 (等于 (i.rm, 4))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, sib取值 (i.mod)))
        .判断 (等于 (i.rm, 5))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[ebp+”, 取32位数据 (), “]”))
        .默认
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[”, reg寄存器文本组 [相加 (i.rm, 9)], “+”, 取32位数据 (), “]”))
        .判断结束
        
    .默认
        
    .判断结束
    
.否则
     ' 16位指令
    赋值 (i.reg, 右移 (位与 (当前指令.寄存器选择位, 56), 3))
    .如果 (w)
        赋值 (i.reg文本, reg寄存器文本组 [相加 (i.reg, 23)])
        赋值 (尺寸前缀, “word ptr ”)
    .否则
        赋值 (i.reg文本, reg寄存器文本组 [相加 (i.reg, 1)])
        赋值 (尺寸前缀, “byte ptr ”)
    .如果结束
    
    赋值 (i.mod, 右移 (位与 (当前指令.寄存器选择位, 192), 6))
    赋值 (i.rm, 位与 (当前指令.寄存器选择位, 7))
    .判断开始 (等于 (i.mod, 3))
        .如果 (w)
            赋值 (i.mod__r_m文本, reg寄存器文本组 [相加 (i.rm, 23)])
        .否则
            赋值 (i.mod__r_m文本, reg寄存器文本组 [相加 (i.rm, 1)])
        .如果结束
        
    .判断 (等于 (i.mod, 0))
        .判断开始 (等于 (i.rm, 0))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+si]”))
        .判断 (等于 (i.rm, 1))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+di]”))
        .判断 (等于 (i.rm, 2))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+si]”))
        .判断 (等于 (i.rm, 3))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+di]”))
        .判断 (等于 (i.rm, 4))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[si]”))
        .判断 (等于 (i.rm, 5))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[di]”))
        .判断 (等于 (i.rm, 6))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 7))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx]”))
        .默认
            
        .判断结束
        
    .判断 (等于 (i.mod, 1))
        .判断开始 (等于 (i.rm, 0))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+si+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 1))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+di+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 2))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+si+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 3))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+di+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 4))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[si+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 5))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[di+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 6))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+”, 取8位数据 (), “]”))
        .判断 (等于 (i.rm, 7))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+”, 取8位数据 (), “]”))
        .默认
            
        .判断结束
        
    .判断 (等于 (i.mod, 2))
        .判断开始 (等于 (i.rm, 0))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+si+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 1))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+di+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 2))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+si+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 3))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+di+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 4))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[si+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 5))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[di+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 6))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ss:[bp+”, 取16位数据 (), “]”))
        .判断 (等于 (i.rm, 7))
            赋值 (i.mod__r_m文本, 相加 (尺寸前缀, “ds:[bx+”, 取16位数据 (), “]”))
        .默认
            
        .判断结束
        
    .默认
        
    .判断结束
    
.如果结束
返回 (i)


.子程序 子程序1, 空白型, , 
 ' 00 ea : ADD Eb,reg8
 ' =====================
 ' '输出指令结构 [目前指令行数].d位 ＝ 0
 ' '输出指令结构 [目前指令行数].w位 ＝ 0
 ' '输出指令结构 [目前指令行数].本节指令长度 ＝ 2
赋值 (当前指令.英文描述, “ADD ”)
ea处理_一般 (假, 假)


.子程序 子程序2, 空白型, , 
 ' 01 ea : ADD Ed,reg32  *
 ' =====================
 ' '输出指令结构 [目前指令行数].w位 ＝ 1
 ' '输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “ADD ”)
ea处理_一般 (真, 假)


.子程序 子程序3, 空白型, , 
 ' 02 ea : ADD reg8,Eb
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
赋值 (当前指令.英文描述, “ADD ”)
ea处理_一般 (假, 真)


.子程序 子程序4, 空白型, , 
 ' 03 ea : ADD reg32,Ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (当前指令.英文描述, “ADD ”)
ea处理_一般 (真, 真)


.子程序 子程序5, 空白型, , 
 ' 04 data8 : ADD AL,data8
 ' =========================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
赋值 (当前指令.英文描述, 相加 (“ADD al,”, 取8位数据 ()))


.子程序 子程序6, 空白型, , 
 ' 05 data32 : ADD EAX,data32  *
 ' ===========================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“ADD eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“ADD ax,”, 取16位数据 ()))
.如果结束


.子程序 子程序7, 空白型, , 
 ' 06 : PUSH ES  *
 ' ==================
赋值 (当前指令.英文描述, “PUSH es”)


.子程序 子程序8, 空白型, , 
 ' 07 : POP ES  *
 ' ================
赋值 (当前指令.英文描述, “POP es”)


.子程序 子程序9, 空白型, , 
 ' 08 ea : OR Eb,reg8
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
赋值 (当前指令.英文描述, “OR ”)
ea处理_一般 (假, 假)


.子程序 子程序10, 空白型, , 
 ' 09 ea : OR Ed,reg32  *
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “OR ”)
ea处理_一般 (真, 假)


.子程序 子程序11, 空白型, , 
 ' 0A ea : OR reg8,Eb
 ' =======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “OR ”)
ea处理_一般 (假, 真)


.子程序 子程序12, 空白型, , 
 ' 0B ea : OR reg32,Ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “OR ”)
ea处理_一般 (真, 真)


.子程序 子程序13, 空白型, , 
 ' 0C data8 : OR AL,data8
 ' ========================
赋值 (当前指令.英文描述, 相加 (“OR al,”, 取8位数据 ()))


.子程序 子程序14, 空白型, , 
 ' 0D data32 : OR EAX,data32
 ' ===========================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“OR eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“OR eax,”, 取16位数据 ()))
.如果结束


.子程序 子程序15, 空白型, , 
 ' 0E : PUSH CS  *
 ' ===============
赋值 (当前指令.英文描述, “PUSH cs”)


.子程序 子程序16, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 0F
赋值 (当前指令.代码2, 取字节集数据 (输入指令的字节集, 1, 当前位置))
赋值 (当前指令.指令集, 相加 (当前指令.指令集, 到字节集 (当前指令.代码2)))

.判断开始 (等于 (当前指令.代码2, 0)) ' 0F 00 ea
    赋值 (i, ea处理_N (真))
    .判断开始 (等于 (i.reg, 0)) ' 0F 00 ea/0
        赋值 (当前指令.英文描述, 相加 (“SLDT ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .判断 (等于 (i.reg, 1)) ' 0F 00 ea/1
        赋值 (当前指令.英文描述, 相加 (“STR ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .判断 (等于 (i.reg, 2)) ' 0F 00 ea/2
        赋值 (当前指令.英文描述, 相加 (“LLDT ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .判断 (等于 (i.reg, 3)) ' 0F 00 ea/3
        赋值 (当前指令.英文描述, 相加 (“LTR ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .判断 (等于 (i.reg, 4)) ' 0F 00 ea/4
        赋值 (当前指令.英文描述, 相加 (“VERR ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .判断 (等于 (i.reg, 5)) ' 0F 00 ea/5
        赋值 (当前指令.英文描述, 相加 (“VERW ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .默认
        赋值 (当前指令.英文描述, “byte: 0F”)
        赋值 (当前位置, 相减 (当前位置, 1))
        赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    .判断结束
    返回 ()
.判断 (等于 (当前指令.代码2, 1)) ' 0F 01 ea
    .判断开始 (等于 (i.reg, 0)) ' 0F 01 ea/0
        赋值 (当前指令.英文描述, 相加 (“SGDT ”, i.mod__r_m文本))
    .判断 (等于 (i.reg, 1)) ' 0F 01 ea/1
        赋值 (当前指令.英文描述, 相加 (“SIDT ”, i.mod__r_m文本))
    .判断 (等于 (i.reg, 2)) ' 0F 01 ea/2
        赋值 (当前指令.英文描述, 相加 (“LGDT ”, i.mod__r_m文本))
    .判断 (等于 (i.reg, 3)) ' 0F 01 ea/3
        赋值 (当前指令.英文描述, 相加 (“LIDT ”, i.mod__r_m文本))
    .判断 (等于 (i.reg, 4)) ' 0F 01 ea/4
        赋值 (当前指令.英文描述, 相加 (“SMSW ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .判断 (等于 (i.reg, 6)) ' 0F 01 ea/6
        赋值 (当前指令.英文描述, 相加 (“LMSW ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
    .默认
        赋值 (当前指令.英文描述, “byte: 0F”)
        赋值 (当前位置, 相减 (当前位置, 1))
        赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    .判断结束
    返回 ()
.判断 (等于 (当前指令.代码2, 2)) ' 0F 02 ea *
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“LAR ”, i.reg文本, “,”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 3)) ' 0F 03 ea  *
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“LSL ”, i.reg文本, “,”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 6)) ' 0F 06
    赋值 (当前指令.英文描述, “CLTS”)
.判断 (等于 (当前指令.代码2, 8)) ' 0F 08
    赋值 (当前指令.英文描述, “INVD”)
.判断 (等于 (当前指令.代码2, 9)) ' 0F 09
    赋值 (当前指令.英文描述, “WBINVD”)
.判断 (等于 (当前指令.代码2, 16)) ' 0F 10 ea
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“INVLPG ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 32)) ' 0F 20 -/n/reg
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOV cr”, 到文本 (i.reg), “,”, reg寄存器文本组 [相加 (i.rm, 17)]))
.判断 (等于 (当前指令.代码2, 33)) ' 0F 21 -/n/reg
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOV dr”, 到文本 (i.reg), “,”, reg寄存器文本组 [相加 (i.rm, 17)]))
.判断 (等于 (当前指令.代码2, 34)) ' 0F 22 -/n/reg
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOV ”, reg寄存器文本组 [相加 (i.rm, 17)], “, cr”, 到文本 (i.reg)))
.判断 (等于 (当前指令.代码2, 35)) ' 0F 23 -/n/reg
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOV ”, reg寄存器文本组 [相加 (i.rm, 17)], “, dr”, 到文本 (i.reg)))
.判断 (等于 (当前指令.代码2, 36)) ' 0F 24 -/n/reg
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOV tr”, 到文本 (i.reg), “,”, reg寄存器文本组 [相加 (i.rm, 17)]))
.判断 (等于 (当前指令.代码2, 38)) ' 0F 26 -/n/reg
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOV ”, reg寄存器文本组 [相加 (i.rm, 17)], “,tr”, 到文本 (i.reg)))
.判断 (等于 (当前指令.代码2, 128)) ' 0F 80 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JO ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JO ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 129)) ' 0F 81 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNO ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNO ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 130)) ' 0F 82 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JB ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JB ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 131)) ' 0F 83 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNB ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNB ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 132)) ' 0F 84 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JZ ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JZ ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 133)) ' 0F 85 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNZ ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNZ ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 134)) ' 0F 86 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JBE ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JBE ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 135)) ' 0F 87 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNBE ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNBE ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 136)) ' 0F 88 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JS ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JS ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 137)) ' 0F 89 disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNS ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNS ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 138)) ' 0F 8a disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JP ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JP ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 139)) ' 0F 8b disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNP ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNP ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 140)) ' 0F 8c disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JL ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JL ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 141)) ' 0F 8d disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNL ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNL ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 142)) ' 0F 8e disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JLE ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JLE ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 143)) ' 0F 8f disp32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“JNLE ”, 取偏移地址_32位 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“JNLE ”, 取偏移地址_16位 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 144)) ' 0F 90 ea  *
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETO ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 145)) ' 0F 91 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNO ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 146)) ' 0F 92 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETB ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 147)) ' 0F 93 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNB ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 148)) ' 0F 94 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETZ ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 149)) ' 0F 95 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNZ ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 150)) ' 0F 96 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETBE ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 151)) ' 0F 97 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNBE ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 152)) ' 0F 98 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETS ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 153)) ' 0F 99 ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNS ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 154)) ' 0F 9a ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETP ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 155)) ' 0F 9b ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNP ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 156)) ' 0F 9c ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETL ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 157)) ' 0F 9d ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNL ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 158)) ' 0F 9e ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETLE ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 159)) ' 0F 9f ea
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“SETNLE ”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 160)) ' 0F a0  *
    赋值 (当前指令.英文描述, “PUSH fs”)
.判断 (等于 (当前指令.代码2, 161)) ' 0F a1  *
    赋值 (当前指令.英文描述, “POP fs”)
.判断 (等于 (当前指令.代码2, 163)) ' 0F a3 ea  *
    赋值 (当前指令.英文描述, “BT ”)
    ea处理_一般 (真, 假)
.判断 (等于 (当前指令.代码2, 164)) ' 0F a4 ea  *
    赋值 (当前指令.英文描述, “SHLD ”)
    ea处理_一般 (真, 假)
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (当前指令.代码2, 165)) ' 0F a5 ea  *
    赋值 (当前指令.英文描述, “SHLD ”)
    ea处理_一般 (真, 假)
    赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, “,cl”))
.判断 (等于 (当前指令.代码2, 166)) ' 0F a6 ea
    赋值 (当前指令.英文描述, “CMPXCHG ”)
    ea处理_一般 (假, 假)
.判断 (等于 (当前指令.代码2, 167)) ' 0F a7 ea
    赋值 (当前指令.英文描述, “CMPXCHG ”)
    ea处理_一般 (真, 假)
.判断 (等于 (当前指令.代码2, 168)) ' 0F a8  *
    赋值 (当前指令.英文描述, “PUSH gs”)
.判断 (等于 (当前指令.代码2, 169)) ' 0F a9  *
    赋值 (当前指令.英文描述, “POP gs”)
.判断 (等于 (当前指令.代码2, 170)) ' 0F ab ea  *
    赋值 (当前指令.英文描述, “BTS ”)
    ea处理_一般 (真, 假)
.判断 (等于 (当前指令.代码2, 172)) ' 0F ac ea data8  *
    赋值 (当前指令.英文描述, “SHRD ”)
    ea处理_一般 (真, 假)
    赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, 取8位数据 ()))
.判断 (等于 (当前指令.代码2, 173)) ' 0F ad ea  *
    赋值 (当前指令.英文描述, “SHRD ”)
    ea处理_一般 (真, 假)
    赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, “,cl”))
.判断 (等于 (当前指令.代码2, 175)) ' 0F af ea  *
    赋值 (当前指令.英文描述, “IMUL ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 178)) ' 0F b2 ea  *
    赋值 (当前指令.英文描述, “LSS ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 179)) ' 0F b3 ea  *
    赋值 (当前指令.英文描述, “BTR ”)
    ea处理_一般 (真, 假)
.判断 (等于 (当前指令.代码2, 180)) ' 0F b4 ea  *
    赋值 (当前指令.英文描述, “LFS ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 181)) ' 0F b5 ea  *
    赋值 (当前指令.英文描述, “LGS ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 182)) ' 0F b6 ea  *
    赋值 (当前指令.英文描述, “MOVZX ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 183)) ' 0F b7 ea  *
    赋值 (当前指令.英文描述, “MOVZX ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 186)) ' 0F ba ea  *
     ' ea/4 5 6 ,data
    赋值 (i, ea处理_N (真))
    .判断开始 (等于 (i.reg, 4)) ' 0F ba ea/4 data8
        赋值 (当前指令.英文描述, 相加 (“BT ”, i.mod__r_m文本, 取8位数据 ()))
    .判断 (等于 (i.reg, 5)) ' 0F ba ea/5 data8
        赋值 (当前指令.英文描述, 相加 (“BTS ”, i.mod__r_m文本, 取8位数据 ()))
    .判断 (等于 (i.reg, 6)) ' 0F ba ea/6 data8
        赋值 (当前指令.英文描述, 相加 (“BTR ”, i.mod__r_m文本, 取8位数据 ()))
    .判断 (等于 (i.reg, 7)) ' 0F ba ea/7 data8
        赋值 (当前指令.英文描述, 相加 (“BTC ”, i.mod__r_m文本, 取8位数据 ()))
    .默认
        赋值 (当前指令.英文描述, “byte:0F”)
        赋值 (当前位置, 相减 (当前位置, 1))
        赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    .判断结束
    返回 ()
.判断 (等于 (当前指令.代码2, 187)) ' 0F bb ea  *
    赋值 (当前指令.英文描述, “BTR ”)
    ea处理_一般 (真, 假)
.判断 (等于 (当前指令.代码2, 188)) ' 0F bc ea  *
    赋值 (当前指令.英文描述, “BSF ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 189)) ' 0F bd ea  *
    赋值 (当前指令.英文描述, “BSR ”)
    ea处理_一般 (真, 真)
.判断 (等于 (当前指令.代码2, 190)) ' 0F be ea  *
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOVSX ”, i.reg文本, “,”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 191)) ' 0F bf ea  *
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“MOVSX ”, i.reg文本, “,”, i.mod__r_m文本))
.判断 (等于 (当前指令.代码2, 192)) ' 0F c0
    赋值 (i, ea处理_N (假))
    赋值 (当前指令.英文描述, 相加 (“XADD byte ptr ”, i.mod__r_m文本, “,”, i.reg文本))
.判断 (等于 (当前指令.代码2, 193)) ' 0F c1
    赋值 (i, ea处理_N (真))
    赋值 (当前指令.英文描述, 相加 (“XADD byte ptr ”, i.mod__r_m文本, “,”, i.reg文本))
.判断 (等于 (当前指令.代码2, 200)) ' 0F c8
    赋值 (当前指令.英文描述, “BSWAP eax”)
.判断 (等于 (当前指令.代码2, 201)) ' 0F c9
    赋值 (当前指令.英文描述, “BSWAP ecx”)
.判断 (等于 (当前指令.代码2, 202)) ' 0F ca
    赋值 (当前指令.英文描述, “BSWAP edx”)
.判断 (等于 (当前指令.代码2, 203)) ' 0F cb
    赋值 (当前指令.英文描述, “BSWAP ebx”)
.判断 (等于 (当前指令.代码2, 204)) ' 0F cc
    赋值 (当前指令.英文描述, “BSWAP esp”)
.判断 (等于 (当前指令.代码2, 205)) ' 0F cd
    赋值 (当前指令.英文描述, “BSWAP ebp”)
.判断 (等于 (当前指令.代码2, 206)) ' 0F ce
    赋值 (当前指令.英文描述, “BSWAP esi”)
.判断 (等于 (当前指令.代码2, 207)) ' 0F cf
    赋值 (当前指令.英文描述, “BSWAP edi”)
.默认
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断结束


.子程序 子程序17, 空白型, , 
 ' 10 ea : ADC Eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
赋值 (当前指令.英文描述, “ADC ”)
ea处理_一般 (假, 假)


.子程序 子程序18, 空白型, , 
 ' 11 ea : ADC ED,reg32  *
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (当前指令.英文描述, “ADC ”)
ea处理_一般 (真, 假)


.子程序 子程序19, 空白型, , 
 ' 12 ea : ADC reg8,Eb
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
赋值 (当前指令.英文描述, “ADC ”)
ea处理_一般 (假, 真)


.子程序 子程序20, 空白型, , 
 ' 13 ea : ADC reg32,Ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (当前指令.英文描述, “ADC”)
ea处理_一般 (真, 真)


.子程序 子程序21, 空白型, , 
 ' 14 data8 : ADC AL,data8
 ' ==========================
赋值 (当前指令.英文描述, 相加 (“ADC al,”, 取8位数据 ()))


.子程序 子程序22, 空白型, , 
 ' 15 data32 : ADC EAX,data32  *
 ' =============================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“ADC eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“ADC eax,”, 取16位数据 ()))
.如果结束


.子程序 子程序23, 空白型, , 
 ' 16 : PUSH SS  *
 ' ==============
赋值 (当前指令.英文描述, “PUSH ss”)


.子程序 子程序24, 空白型, , 
 ' 17 : POP SS  *
 ' ==============
赋值 (当前指令.英文描述, “POP ss”)


.子程序 子程序25, 空白型, , 
 ' 18 ea : SBB Eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “SBB ”)
ea处理_一般 (假, 假)


.子程序 子程序26, 空白型, , 
 ' 19 ea : SBB Ed,reg32  *
 ' =======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “SBB ”)
ea处理_一般 (真, 假)


.子程序 子程序27, 空白型, , 
 ' 1A ea : SBB reg8,Eb
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “SBB ”)
ea处理_一般 (假, 真)


.子程序 子程序28, 空白型, , 
 ' 1B ea : SBB reg32,Ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “SBB ”)
ea处理_一般 (真, 真)


.子程序 子程序29, 空白型, , 
 ' 1C data8 : SBB AL,data8
 ' =========================
赋值 (当前指令.英文描述, 相加 (“SBB al,”, 取8位数据 ()))


.子程序 子程序30, 空白型, , 
 ' 1D data32 : SBB EAX,data32  *
 ' ===========================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“SBB eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“SBB eax,”, 取16位数据 ()))
.如果结束


.子程序 子程序31, 空白型, , 
 ' 1E : PUSH DS  *
 ' ===============
赋值 (当前指令.英文描述, “PUSH ds”)


.子程序 子程序32, 空白型, , 
 ' 1F : POP DS  *
 ' =============
赋值 (当前指令.英文描述, “POP ds”)


.子程序 子程序33, 空白型, , 
 ' 20 ea : AND Eb,reg8
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “AND ”)
ea处理_一般 (假, 假)


.子程序 子程序34, 空白型, , 
 ' 21 ea : AND Ed,reg32  *
 ' ========================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “AND ”)
ea处理_一般 (真, 假)


.子程序 子程序35, 空白型, , 
 ' 22 ea : AND reg8,Eb
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “AND ”)
ea处理_一般 (假, 真)


.子程序 子程序36, 空白型, , 
 ' 23 ea : AND reg32,Ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “AND ”)
ea处理_一般 (真, 真)


.子程序 子程序37, 空白型, , 
 ' 24 data8 : AND AL,data8
 ' ===========================
赋值 (当前指令.英文描述, 相加 (“AND ”, 取8位数据 ()))


.子程序 子程序38, 空白型, , 
 ' 25 data32 : AND EAX,data32  *
 ' ===========================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“AND ”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“AND ”, 取16位数据 ()))
.如果结束


.子程序 子程序39, 空白型, , 
 ' 26 : ES:
 ' ==============
赋值 (当前指令.英文描述, “es:”)
赋值 (前缀, 真)


.子程序 子程序40, 空白型, , 
 ' 27 : DAA
 ' ===========
赋值 (当前指令.英文描述, “DAA”)


.子程序 子程序41, 空白型, , 
 ' 28 ea : SUB Eb,reg8
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “SUB ”)
ea处理_一般 (假, 假)


.子程序 子程序42, 空白型, , 
 ' 29 ea : SUB Ed,reg32  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “SUB ”)
ea处理_一般 (真, 假)


.子程序 子程序43, 空白型, , 
 ' 2A ea : SUB reg8,Eb
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “SUB ”)
ea处理_一般 (假, 真)


.子程序 子程序44, 空白型, , 
 ' 2B ea : SUB reg32,Ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “SUB ”)
ea处理_一般 (真, 真)


.子程序 子程序45, 空白型, , 
 ' 2C data8 : SUB AL,data8
 ' ===========================
赋值 (当前指令.英文描述, 相加 (“SUB al,”, 取8位数据 ()))


.子程序 子程序46, 空白型, , 
 ' 2D data32 : SUB EAX,data32  *
 ' ============================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“SUB eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“SUB eax,”, 取16位数据 ()))
.如果结束


.子程序 子程序47, 空白型, , 
 ' 2E : CS:
 ' ===========
赋值 (当前指令.英文描述, “cs:”)
赋值 (前缀, 真)


.子程序 子程序48, 空白型, , 
 ' 2F : DAS
 ' ==============
赋值 (当前指令.英文描述, “DAS”)


.子程序 子程序49, 空白型, , 
 ' 30 ea : XOR Eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “XOR ”)
ea处理_一般 (假, 假)


.子程序 子程序50, 空白型, , 
 ' 31 ea : XOR Ed,reg32  *
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “XOR ”)
ea处理_一般 (真, 假)


.子程序 子程序51, 空白型, , 
 ' 32 ea : XOR reg8,Eb
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “XOR ”)
ea处理_一般 (假, 真)


.子程序 子程序52, 空白型, , 
 ' 33 ea : XOR reg32,Ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “XOR ”)
ea处理_一般 (真, 真)


.子程序 子程序53, 空白型, , 
 ' 34 data8 : XOR AL,data8
 ' =========================
赋值 (当前指令.英文描述, 相加 (“XOR al,”, 取8位数据 ()))


.子程序 子程序54, 空白型, , 
 ' 35 data32 : XOR EAX,data32  *
 ' ===========================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“XOR eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“XOR eax,”, 取16位数据 ()))
.如果结束


.子程序 子程序55, 空白型, , 
 ' 36 : SS
 ' ===========
赋值 (当前指令.英文描述, “ss:”)
赋值 (前缀, 真)


.子程序 子程序56, 空白型, , 
 ' 37 : AAA
 ' ============
赋值 (当前指令.英文描述, “AAA”)


.子程序 子程序57, 空白型, , 
 ' 38 ea : CMP Eb,reg8
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “CMP ”)
ea处理_一般 (假, 假)


.子程序 子程序58, 空白型, , 
 ' 39 ea : CMP Ed,reg32  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “CMP ”)
ea处理_一般 (真, 假)


.子程序 子程序59, 空白型, , 
 ' 3A ea : CMP reg8,Eb
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “CMP ”)
ea处理_一般 (假, 真)


.子程序 子程序60, 空白型, , 
 ' 3B ea : CMP reg32,Ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (当前指令.英文描述, “CMP ”)
ea处理_一般 (真, 真)


.子程序 子程序61, 空白型, , 
 ' 3C data8 : CMP data8
 ' ===================
赋值 (当前指令.英文描述, 相加 (“CMP al,”, 取8位数据 ()))


.子程序 子程序62, 空白型, , 
 ' 3D data32 : CMP data32  *
 ' ========================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“CMP eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“CMP eax,”, 取16位数据 ()))
.如果结束


.子程序 子程序63, 空白型, , 
 ' 3E : DS:
 ' ============
赋值 (当前指令.英文描述, “ds:”)
赋值 (前缀, 真)


.子程序 子程序64, 空白型, , 
 ' 3F : AAS
 ' ===========
赋值 (当前指令.英文描述, “AAS”)


.子程序 子程序65, 空白型, , 
 ' 40 : INC EAX  *
 ' ===============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC eax”)
.否则
    赋值 (当前指令.英文描述, “INC ax”)
.如果结束


.子程序 子程序66, 空白型, , 
 ' 41 : INC ECX  *
 ' =================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC ecx”)
.否则
    赋值 (当前指令.英文描述, “INC cx”)
.如果结束


.子程序 子程序67, 空白型, , 
 ' 42 : INC EDX  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC edx”)
.否则
    赋值 (当前指令.英文描述, “INC dx”)
.如果结束


.子程序 子程序68, 空白型, , 
 ' 43 : INC EBX  *
 ' ===============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC ebx”)
.否则
    赋值 (当前指令.英文描述, “INC bx”)
.如果结束


.子程序 子程序69, 空白型, , 
 ' 44 : INC ESP  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC esp”)
.否则
    赋值 (当前指令.英文描述, “INC sp”)
.如果结束


.子程序 子程序70, 空白型, , 
 ' 45 : INC EBP  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC ebp”)
.否则
    赋值 (当前指令.英文描述, “INC bp”)
.如果结束


.子程序 子程序71, 空白型, , 
 ' 46 : INC ESI  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC esi”)
.否则
    赋值 (当前指令.英文描述, “INC si”)
.如果结束


.子程序 子程序72, 空白型, , 
 ' 47 : INC EDI  *
 ' ===============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INC edi”)
.否则
    赋值 (当前指令.英文描述, “INC di”)
.如果结束


.子程序 子程序73, 空白型, , 
 ' 48 : DEC EAX  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC eax”)
.否则
    赋值 (当前指令.英文描述, “DEC ax”)
.如果结束


.子程序 子程序74, 空白型, , 
 ' 49 : DEC ECX  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC ecx”)
.否则
    赋值 (当前指令.英文描述, “DEC cx”)
.如果结束


.子程序 子程序75, 空白型, , 
 ' 4A : DEC EDX  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC edx”)
.否则
    赋值 (当前指令.英文描述, “DEC dx”)
.如果结束


.子程序 子程序76, 空白型, , 
 ' 4B : DEC EBX  *
 ' ===============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC ebx”)
.否则
    赋值 (当前指令.英文描述, “DEC bx”)
.如果结束


.子程序 子程序77, 空白型, , 
 ' 4C : DEC ESP  *
 ' ===============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC esp”)
.否则
    赋值 (当前指令.英文描述, “DEC sp”)
.如果结束


.子程序 子程序78, 空白型, , 
 ' 4D : DEC EBP  *
 ' =============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC ebp”)
.否则
    赋值 (当前指令.英文描述, “DEC bp”)
.如果结束


.子程序 子程序79, 空白型, , 
 ' 4E : DEC ESI  *
 ' ===================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC esi”)
.否则
    赋值 (当前指令.英文描述, “DEC si”)
.如果结束


.子程序 子程序80, 空白型, , 
 ' 4F : DEC EDI  *
 ' ==============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “DEC edi”)
.否则
    赋值 (当前指令.英文描述, “DEC di”)
.如果结束


.子程序 子程序81, 空白型, , 
 ' 50 : PUSH EAX  *
 ' ===============
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH eax”)
.否则
    赋值 (当前指令.英文描述, “PUSH ax”)
.如果结束


.子程序 子程序82, 空白型, , 
 ' 51 : PUSH ECX  *
 ' ================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH ecx”)
.否则
    赋值 (当前指令.英文描述, “PUSH cx”)
.如果结束


.子程序 子程序83, 空白型, , 
 ' 52 : PUSH EDX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH edx”)
.否则
    赋值 (当前指令.英文描述, “PUSH dx”)
.如果结束


.子程序 子程序84, 空白型, , 
 ' 53 : PUSH EBX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH ebx”)
.否则
    赋值 (当前指令.英文描述, “PUSH bx”)
.如果结束


.子程序 子程序85, 空白型, , 
 ' 54 : PUSH ESP  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH esp”)
.否则
    赋值 (当前指令.英文描述, “PUSH sp”)
.如果结束


.子程序 子程序86, 空白型, , 
 ' 55 : PUSH EBP  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH ebp”)
.否则
    赋值 (当前指令.英文描述, “PUSH bp”)
.如果结束


.子程序 子程序87, 空白型, , 
 ' 56 : PUSH ESI  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH esi”)
.否则
    赋值 (当前指令.英文描述, “PUSH si”)
.如果结束


.子程序 子程序88, 空白型, , 
 ' 57 : PUSH EDI  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH edi”)
.否则
    赋值 (当前指令.英文描述, “PUSH di”)
.如果结束


.子程序 子程序89, 空白型, , 
 ' 58 : POP EAX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP eax”)
.否则
    赋值 (当前指令.英文描述, “POP ax”)
.如果结束


.子程序 子程序90, 空白型, , 
 ' 59 : POP ECX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP ecx”)
.否则
    赋值 (当前指令.英文描述, “POP cx”)
.如果结束


.子程序 子程序91, 空白型, , 
 ' 5A : POP EDX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP edx”)
.否则
    赋值 (当前指令.英文描述, “POP dx”)
.如果结束


.子程序 子程序92, 空白型, , 
 ' 5B : POP EBX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP ebx”)
.否则
    赋值 (当前指令.英文描述, “POP bx”)
.如果结束


.子程序 子程序93, 空白型, , 
 ' 5C : POP ESP  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP esp”)
.否则
    赋值 (当前指令.英文描述, “POP sp”)
.如果结束


.子程序 子程序94, 空白型, , 
 ' 5D : POP EBP  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP ebp”)
.否则
    赋值 (当前指令.英文描述, “POP bp”)
.如果结束


.子程序 子程序95, 空白型, , 
 ' 5E : POP ESI  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP esi”)
.否则
    赋值 (当前指令.英文描述, “POP si”)
.如果结束


.子程序 子程序96, 空白型, , 
 ' 5F : POP EDI  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP edi”)
.否则
    赋值 (当前指令.英文描述, “POP di”)
.如果结束


.子程序 子程序97, 空白型, , 
 ' 60 : PUSHAD  *
 ' ==========================================
赋值 (当前指令.英文描述, “PUSHAD”)


.子程序 子程序98, 空白型, , 
 ' 61 : POPAD  *
 ' ==========================================
赋值 (当前指令.英文描述, “POPAD”)


.子程序 子程序99, 空白型, , 
 ' 62 ea : BOUND reg32,Ea  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “BOUND ”)
ea处理_一般 (真, 真)


.子程序 子程序100, 空白型, , 
 ' 63 ea : ARPL Ew,reg16
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “ARPL ”)
ea处理_一般 (真, 假)


.子程序 子程序101, 空白型, , 
 ' 64 : FS:
 ' ==========================================
赋值 (当前指令.英文描述, “fs:”)
赋值 (前缀, 真)


.子程序 子程序102, 空白型, , 
 ' 65 : GS:
 ' ==========================================
赋值 (当前指令.英文描述, “gs:”)
赋值 (前缀, 真)


.子程序 子程序103, 空白型, , 
 ' 66 : OPSIZ:
 ' ==========================================
赋值 (当前指令.英文描述, “opsiz:”)
赋值 (opsiz, 真)
赋值 (尺寸为32, 取反 (尺寸为32))


.子程序 子程序104, 空白型, , 
 ' 67 : ADRSIZ:
 ' ==========================================
赋值 (当前指令.英文描述, “adrsiz:”)


.子程序 子程序105, 空白型, , 
 ' 68 data32 : PUSH data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“PUSH ”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“PUSH ”, 取16位数据 ()))
.如果结束


.子程序 子程序106, 空白型, , 
 ' 69 ea data32 : IMUL reg32,Ed,data32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “IMUL ”)
ea处理_一般 (真, 真)
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, “,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, “,”, 取16位数据 ()))
.如果结束


.子程序 子程序107, 空白型, , 
 ' 6A data8 : PUSH data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“PUSH ”, 取8位数据 ()))


.子程序 子程序108, 空白型, , 
 ' 6B ea data8 : IMUL reg32,Ed,data8  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “IMUL ”)
ea处理_一般 (真, 真)
赋值 (当前指令.英文描述, 相加 (当前指令.英文描述, 取8位数据 ()))


.子程序 子程序109, 空白型, , 
 ' 6C : INSB
 ' ==========================================
赋值 (当前指令.英文描述, “INSB byte ptr es:[di],dx”)


.子程序 子程序110, 空白型, , 
 ' 6D : INSD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “INSD dword ptr ds:[edi],ax”)
.否则
    赋值 (当前指令.英文描述, “INSD word ptr ds:[di],ax”)
.如果结束


.子程序 子程序111, 空白型, , 
 ' 6E : OUTSB
 ' ==========================================
赋值 (当前指令.英文描述, “OUTS dx,byte ptr es:[edi]”)


.子程序 子程序112, 空白型, , 
 ' 6F : OUTSD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “OUTS dx,dword ptr es:[edi]”)
.否则
    赋值 (当前指令.英文描述, “OUTS dx,word ptr es:[di]”)
.如果结束


.子程序 子程序113, 空白型, , 
 ' 70 disp8 : JO disp8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JO ”, 取8位数据 ()))


.子程序 子程序114, 空白型, , 
 ' 71 disp8 : JNO disp8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNO ”, 取8位数据 ()))


.子程序 子程序115, 空白型, , 
 ' 72 disp8 : JB disp8 (JB/JNAE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JB ”, 取偏移地址_8位 ()))


.子程序 子程序116, 空白型, , 
 ' 73 disp8 : JNB disp8 (JNB/JAE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNB ”, 取偏移地址_8位 ()))


.子程序 子程序117, 空白型, , 
 ' 74 disp8 : JZ disp8 (JZ/JE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JZ ”, 取偏移地址_8位 ()))


.子程序 子程序118, 空白型, , 
 ' 75 disp8 : JNZ disp8 (JNZ/JNE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNZ ”, 取偏移地址_8位 ()))


.子程序 子程序119, 空白型, , 
 ' 76 disp8 : JBE disp8 (JBE/JNA)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JBE ”, 取偏移地址_8位 ()))


.子程序 子程序120, 空白型, , 
 ' 77 disp8 : JNBE disp8 (JNBE/JA)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNBE ”, 取偏移地址_8位 ()))


.子程序 子程序121, 空白型, , 
 ' 78 disp8 : JS disp8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JS ”, 取偏移地址_8位 ()))


.子程序 子程序122, 空白型, , 
 ' 79 disp8 : JNS disp8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNS ”, 取偏移地址_8位 ()))


.子程序 子程序123, 空白型, , 
 ' 7A disp8 : JP disp8 (JP/JPE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JP ”, 取偏移地址_8位 ()))


.子程序 子程序124, 空白型, , 
 ' 7B disp8 : JNP disp8 (JNP/JPO)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNP ”, 取偏移地址_8位 ()))


.子程序 子程序125, 空白型, , 
 ' 7C disp8 : JL disp8 (JL/JNGE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JL ”, 取偏移地址_8位 ()))


.子程序 子程序126, 空白型, , 
 ' 7D disp8 : JNL disp8 (JNL/JGE)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNL ”, 取偏移地址_8位 ()))


.子程序 子程序127, 空白型, , 
 ' 7E disp8 : JLE disp8 (JLE/JNG)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JLE ”, 取偏移地址_8位 ()))


.子程序 子程序128, 空白型, , 
 ' 7F disp8 : JNLE disp8 (JNLE/JG)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JNLE ”, 取偏移地址_8位 ()))


.子程序 子程序129, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 80
赋值 (i, ea处理_N (假))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data8 ADD Eb,data8
    赋值 (当前指令.英文描述, 相加 (“ADD ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 1))
     ' ea/1 data8 OR Eb,data8
    赋值 (当前指令.英文描述, 相加 (“OR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 2))
     ' ea/2 data8 ADC Eb,data8
    赋值 (当前指令.英文描述, 相加 (“ADC ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 3))
     ' ea/3 data8 SBB Eb,data8
    赋值 (当前指令.英文描述, 相加 (“SBB ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 4))
     ' ea/4 data8 AND Eb,data8
    赋值 (当前指令.英文描述, 相加 (“AND ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 5))
     ' ea/5 data8 SUB Eb,data8
    赋值 (当前指令.英文描述, 相加 (“SUB ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 6))
     ' ea/6 data8 XOR Eb,data8
    赋值 (当前指令.英文描述, 相加 (“XOR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 7))
     ' ea/7 data8 CMP Eb,data8
    赋值 (当前指令.英文描述, 相加 (“CMP ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.默认
    
.判断结束


.子程序 子程序130, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 81  *
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data8 ADD Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“ADD ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“ADD ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 1))
     ' ea/1 data8 OR Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“OR ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“OR ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 2))
     ' ea/2 data8 ADC Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“ADC ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“ADC ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 3))
     ' ea/3 data8 SBB Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“SBB ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“SBB ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 4))
     ' ea/4 data8 AND Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“AND ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“AND ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 5))
     ' ea/5 data8 SUB Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“SUB ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“SUB ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 6))
     ' ea/6 data8 XOR Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“XOR ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“XOR ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 7))
     ' ea/7 data8 CMP Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“CMP ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“CMP ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.默认
    
.判断结束


.子程序 子程序131, 空白型, , 
 ' 82 为空
 ' ==========================================
赋值 (当前指令.英文描述, “*82* 错误！”)


.子程序 子程序132, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 83  *
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data8 ADD Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“ADD ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 1))
     ' ea/1 data8 OR Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“OR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 2))
     ' ea/2 data8 ADC Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“ADC ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 3))
     ' ea/3 data8 SBB Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“SBB ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 4))
     ' ea/4 data8 AND Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“AND ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 5))
     ' ea/5 data8 SUB Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“SUB ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 6))
     ' ea/6 data8 XOR Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“XOR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 7))
     ' ea/7 data8 CMP Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“CMP ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.默认
    
.判断结束


.子程序 子程序133, 空白型, , 
 ' 84 ea : TEST Eb,reg8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “TEST ”)
ea处理_一般 (假, 假)


.子程序 子程序134, 空白型, , 
 ' 85 ea : TEST Ed,reg32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “TEST ”)
ea处理_一般 (真, 假)


.子程序 子程序135, 空白型, , 
 ' 86 ea : XCHG Eb,reg8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “XCHG ”)
ea处理_一般 (假, 假)


.子程序 子程序136, 空白型, , 
 ' 87 ea : XCHG Ed,reg32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “XCHG ”)
ea处理_一般 (真, 假)


.子程序 子程序137, 空白型, , 
 ' 88 ea : MOV Eb,reg8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “MOV ”)
ea处理_一般 (假, 假)


.子程序 子程序138, 空白型, , 
 ' 89 ea : MOV Ed,reg32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
赋值 (当前指令.英文描述, “MOV ”)
ea处理_一般 (真, 假)


.子程序 子程序139, 空白型, , 
 ' 8A ea : MOV reg8,Eb
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “MOV ”)
ea处理_一般 (假, 真)


.子程序 子程序140, 空白型, , 
 ' 8B ea : MOV reg32,Ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “MOV ”)
ea处理_一般 (真, 真)


.子程序 子程序141, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 8C ea/s : MOV Ew,sreg
 ' ==========================================
赋值 (i, ea处理_N (假))
.如果真 (大于 (i.rm, 5))
    赋值 (错误, 真)
    赋值 (当前指令.英文描述, “*错误*”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    返回 ()
.如果真结束
赋值 (当前指令.英文描述, 相加 (“MOV ”, i.mod__r_m文本, “,”, reg寄存器文本组 [相加 (17, i.rm)]))


.子程序 子程序142, 空白型, , 
 ' 8D ea : LEA reg32,Ea  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “LEA ”)
ea处理_一般 (真, 真)


.子程序 子程序143, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 8E ea/sreg : MOV sreg,Ew
 ' ==========================================
赋值 (i, ea处理_N (假))
.如果真 (大于 (i.rm, 5))
    赋值 (错误, 真)
    赋值 (当前指令.英文描述, “*错误*”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    返回 ()
.如果真结束
赋值 (当前指令.英文描述, 相加 (“MOV ”, reg寄存器文本组 [相加 (17, i.rm)], “,”, i.mod__r_m文本))



.子程序 子程序144, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' 8F ea/modrm : POP Ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (i, ea处理_N (真))
赋值 (当前指令.英文描述, 相加 (“POP ”, i.mod__r_m文本))



.子程序 子程序145, 空白型, , 
 ' 90 : NOP
 ' ==========================================
赋值 (当前指令.英文描述, “NOP”)


.子程序 子程序146, 空白型, , 
 ' 91 : XCHG EAX,ECX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,ecx”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,cx”)
.如果结束


.子程序 子程序147, 空白型, , 
 ' 92 : XCHG EAX,EDX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,edx”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,dx”)
.如果结束


.子程序 子程序148, 空白型, , 
 ' 93 : XCHG EAX,EBX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,ebx”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,bx”)
.如果结束


.子程序 子程序149, 空白型, , 
 ' 94 : XCHG EAX,ESP  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,esp”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,sp”)
.如果结束


.子程序 子程序150, 空白型, , 
 ' 95 : XCHG EAX,EBP  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,ebp”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,bp”)
.如果结束


.子程序 子程序151, 空白型, , 
 ' 96 : XCHG EAX,ESI  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,esi”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,si”)
.如果结束


.子程序 子程序152, 空白型, , 
 ' 97 : XCHG EAX,EDI  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “XCHG eax,edi”)
.否则
    赋值 (当前指令.英文描述, “XCHG ax,di”)
.如果结束


.子程序 子程序153, 空白型, , 
 ' 98 : CBW/CWDE  *
 ' ==========================================
赋值 (当前指令.英文描述, “CBW”)


.子程序 子程序154, 空白型, , 
 ' 99 : CWD
 ' ==========================================
赋值 (当前指令.英文描述, “CWD”)


.子程序 子程序155, 空白型, , 
.局部变量 i, 文本型, , , 
.局部变量 j, 文本型, , , 

 ' 9A offset32 : CALL offset32
 ' ==========================================
.如果 (尺寸为32)
    赋值 (i, 取32位数据 ())
.否则
    赋值 (i, 取16位数据 ())
.如果结束
赋值 (j, 取16位数据 ())
赋值 (当前指令.英文描述, 相加 (“CALL ”, j, “:”, i))


.子程序 子程序156, 空白型, , 
 ' 9B : WAIT
 ' ==========================================
赋值 (当前指令.英文描述, “WAIT”)


.子程序 子程序157, 空白型, , 
 ' 9C : PUSH FD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “PUSH fd”)
.否则
    赋值 (当前指令.英文描述, “PUSH fw”)
.如果结束


.子程序 子程序158, 空白型, , 
 ' 9D : POP FD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “POP fd”)
.否则
    赋值 (当前指令.英文描述, “POP fw”)
.如果结束


.子程序 子程序159, 空白型, , 
 ' 9E : SAHF
 ' ==========================================
赋值 (当前指令.英文描述, “SAHF”)


.子程序 子程序160, 空白型, , 
 ' 9F : LAHF
 ' ==========================================
赋值 (当前指令.英文描述, “LAHF”)


.子程序 子程序161, 空白型, , 
 ' A0 disp32 : MOV AL,[disp]
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV al,byte ptr ds:[”, 取32位数据 (), “]”))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV al,byte ptr ds:[”, 取16位数据 (), “]”))
.如果结束


.子程序 子程序162, 空白型, , 
 ' A1 disp32 : MOV EAX,[disp]  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV eax,dword ptr ds:[”, 取32位数据 (), “]”))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV ax,word ptr ds:[”, 取16位数据 (), “]”))
.如果结束


.子程序 子程序163, 空白型, , 
 ' A2 disp32 : MOV [disp],AL
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV byte ptr ds:[”, 取32位数据 (), “],al”))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV byte ptr ds:[”, 取16位数据 (), “],al”))
.如果结束


.子程序 子程序164, 空白型, , 
 ' A3 disp32 : MOV [disp],EAX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV dword ptr ds:[”, 取32位数据 (), “],eax”))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV word ptr ds:[”, 取16位数据 (), “],ax”))
.如果结束


.子程序 子程序165, 空白型, , 
 ' A4 : MOVSB
 ' ==========================================
赋值 (当前指令.英文描述, “MOVSB”)


.子程序 子程序166, 空白型, , 
 ' A5 : MOVSD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “MOVSD”)
.否则
    赋值 (当前指令.英文描述, “MOVSW”)
.如果结束


.子程序 子程序167, 空白型, , 
 ' A6 : CMPSB
 ' ==========================================
赋值 (当前指令.英文描述, “CMPSB”)


.子程序 子程序168, 空白型, , 
 ' A7 : CMPSD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “CMPSD”)
.否则
    赋值 (当前指令.英文描述, “CMPSW”)
.如果结束


.子程序 子程序169, 空白型, , 
 ' A8 data8 : TEST AL,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“TEST al,”, 取8位数据 ()))


.子程序 子程序170, 空白型, , 
 ' A9 data32 : TEST EAX,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“TEST eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“TEST ax,”, 取16位数据 ()))
.如果结束


.子程序 子程序171, 空白型, , 
 ' AA : STOSB
 ' ==========================================
赋值 (当前指令.英文描述, “STOSB”)


.子程序 子程序172, 空白型, , 
 ' AB : STOSD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “STOSD”)
.否则
    赋值 (当前指令.英文描述, “STOSW”)
.如果结束


.子程序 子程序173, 空白型, , 
 ' AC : LODSB
 ' ==========================================
赋值 (当前指令.英文描述, “LODSB”)


.子程序 子程序174, 空白型, , 
 ' AD : LODSD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “LODSD”)
.否则
    赋值 (当前指令.英文描述, “LODSW”)
.如果结束


.子程序 子程序175, 空白型, , 
 ' AE : SCASB
 ' ==========================================
赋值 (当前指令.英文描述, “SCASB”)


.子程序 子程序176, 空白型, , 
 ' AF : SCASD  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “SCASD”)
.否则
    赋值 (当前指令.英文描述, “SCASW”)
.如果结束


.子程序 子程序177, 空白型, , 
 ' B0 data8 : MOV AL,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV al,”, 取8位数据 ()))


.子程序 子程序178, 空白型, , 
 ' B1 data8 : MOV CL,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV cl,”, 取8位数据 ()))


.子程序 子程序179, 空白型, , 
 ' B2 data8 : MOV DL,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV dl,”, 取8位数据 ()))


.子程序 子程序180, 空白型, , 
 ' B3 data8 : MOV BL,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV bl,”, 取8位数据 ()))


.子程序 子程序181, 空白型, , 
 ' B4 data8 : MOV AH,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV ah,”, 取8位数据 ()))


.子程序 子程序182, 空白型, , 
 ' B5 data8 : MOV CH,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV ch,”, 取8位数据 ()))


.子程序 子程序183, 空白型, , 
 ' B6 data8 : MOV DH,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV dh,”, 取8位数据 ()))


.子程序 子程序184, 空白型, , 
 ' B7 data8 : MOV BH,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“MOV bh,”, 取8位数据 ()))


.子程序 子程序185, 空白型, , 
 ' B8 data32 : MOV EAX,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV eax,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV ax,”, 取16位数据 ()))
.如果结束


.子程序 子程序186, 空白型, , 
 ' B9 data32 : MOV ECX,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV ecx,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV cx,”, 取16位数据 ()))
.如果结束


.子程序 子程序187, 空白型, , 
 ' BA data32 : MOV EDX,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV edx,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV dx,”, 取16位数据 ()))
.如果结束


.子程序 子程序188, 空白型, , 
 ' BB data32 : MOV EBX,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV ebx,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV bx,”, 取16位数据 ()))
.如果结束


.子程序 子程序189, 空白型, , 
 ' BC data32 : MOV ESP,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV esp,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV sp,”, 取16位数据 ()))
.如果结束


.子程序 子程序190, 空白型, , 
 ' BD data32 : MOV EBP,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV ebp,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV bp,”, 取16位数据 ()))
.如果结束


.子程序 子程序191, 空白型, , 
 ' BE data32 : MOV ESI,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV esi,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV si,”, 取16位数据 ()))
.如果结束


.子程序 子程序192, 空白型, , 
 ' BF data32 : MOV EDI,data32  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV edi,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV di,”, 取16位数据 ()))
.如果结束


.子程序 子程序193, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' C0
赋值 (i, ea处理_N (假))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data8 ROL Eb,data8
    赋值 (当前指令.英文描述, 相加 (“ROL ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 1))
     ' ea/1 data8 ROR Eb,data8
    赋值 (当前指令.英文描述, 相加 (“ROR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 2))
     ' ea/2 data8 RCL Eb,data8
    赋值 (当前指令.英文描述, 相加 (“RCL ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 3))
     ' ea/3 data8 RCR Eb,data8
    赋值 (当前指令.英文描述, 相加 (“RCR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 4))
     ' ea/4 data8 SHL Eb,data8
    赋值 (当前指令.英文描述, 相加 (“SHL ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 5))
     ' ea/5 data8 SHR Eb,data8
    赋值 (当前指令.英文描述, 相加 (“SHR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 7))
     ' ea/7 data8 SAR Eb,data8
    赋值 (当前指令.英文描述, 相加 (“SAR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.默认
    
.判断结束


.子程序 子程序194, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' C1  *
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data8 ROL Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“ROL ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 1))
     ' ea/1 data8 ROR Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“ROR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 2))
     ' ea/2 data8 RCL Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“RCL ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 3))
     ' ea/3 data8 RCR Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“RCR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 4))
     ' ea/4 data8 SHL Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“SHL ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 5))
     ' ea/5 data8 SHR Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“SHR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 7))
     ' ea/7 data8 SAR Ed,data8  *
    赋值 (当前指令.英文描述, 相加 (“SAR ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.默认
    
.判断结束


.子程序 子程序195, 空白型, , 
 ' C2 data16 : RET data16
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“RET ”, 取16位数据 ()))


.子程序 子程序196, 空白型, , 
 ' C3 : RET
 ' ==========================================
赋值 (当前指令.英文描述, “RET”)


.子程序 子程序197, 空白型, , 
 ' C4 ea : LES reg32,Ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “LES ”)
ea处理_一般 (真, 真)


.子程序 子程序198, 空白型, , 
 ' C5 ea : LDS reg32,Ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
赋值 (当前指令.英文描述, “LDS ”)
ea处理_一般 (真, 真)


.子程序 子程序199, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' C6 ea data8 : MOV reg8,data8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
赋值 (i, ea处理_N (假))
赋值 (当前指令.英文描述, 相加 (“MOV ”, i.reg文本, “,”, 取8位数据 ()))


.子程序 子程序200, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' C7 ea data32 : MOV reg32,data32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (i, ea处理_N (真))
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“MOV ”, i.mod__r_m文本, “,”, 取32位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“MOV ”, i.mod__r_m文本, “,”, 取16位数据 ()))
.如果结束


.子程序 子程序201, 空白型, , 
 ' C8 data16 data8 : ENTER data16,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“ENTER ”, 取16位数据 (), “,”, 取8位数据 ()))


.子程序 子程序202, 空白型, , 
 ' C9 : LEAVE
 ' ==========================================
赋值 (当前指令.英文描述, “LEAVE”)


.子程序 子程序203, 空白型, , 
 ' CA data16 : RETF data16
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“RETF ”, 取16位数据 ()))


.子程序 子程序204, 空白型, , 
 ' CB : RETF
 ' ==========================================
赋值 (当前指令.英文描述, “RETF”)


.子程序 子程序205, 空白型, , 
 ' CC : INT 3
 ' ==========================================
赋值 (当前指令.英文描述, “INT 3”)


.子程序 子程序206, 空白型, , 
 ' CD data8 : INT data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“INT ”, 取8位数据 ()))


.子程序 子程序207, 空白型, , 
 ' CE : INTO
 ' ==========================================
赋值 (当前指令.英文描述, “INTO”)


.子程序 子程序208, 空白型, , 
 ' CF : IRET
 ' ==========================================
赋值 (当前指令.英文描述, “IRET”)


.子程序 子程序209, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' D0
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 ROL Eb,1
    赋值 (当前指令.英文描述, 相加 (“ROL ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 1))
     ' ea/1 ROR Eb,1
    赋值 (当前指令.英文描述, 相加 (“ROR ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 2))
     ' ea/2 RCL Eb,1
    赋值 (当前指令.英文描述, 相加 (“RCL ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 3))
     ' ea/3 RCR Eb,1
    赋值 (当前指令.英文描述, 相加 (“RCR ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 4))
     ' ea/4 SHL Eb,1
    赋值 (当前指令.英文描述, 相加 (“SHL ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 5))
     ' ea/5 SHR Eb,1
    赋值 (当前指令.英文描述, 相加 (“SHR ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 7))
     ' ea/7 SAR Eb,1
    赋值 (当前指令.英文描述, 相加 (“SAR ”, i.mod__r_m文本, “,1”))
.默认
    
.判断结束


.子程序 子程序210, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' D1  *
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 ROL Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“ROL ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 1))
     ' ea/1 ROR Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“ROR ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 2))
     ' ea/2 RCL Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“RCL ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 3))
     ' ea/3 RCR Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“RCR ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 4))
     ' ea/4 SHL Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“SHL ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 5))
     ' ea/5 SHR Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“SHR ”, i.mod__r_m文本, “,1”))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 7))
     ' ea/7 SAR Ed,1  *
    赋值 (当前指令.英文描述, 相加 (“SAR ”, i.mod__r_m文本, “,1”))
.默认
    
.判断结束


.子程序 子程序211, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' D2
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 ROL Eb,CL
    赋值 (当前指令.英文描述, 相加 (“ROL ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 1))
     ' ea/1 ROR Eb,CL
    赋值 (当前指令.英文描述, 相加 (“ROR ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 2))
     ' ea/2 RCL Eb,CL
    赋值 (当前指令.英文描述, 相加 (“RCL ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 3))
     ' ea/3 RCR Eb,CL
    赋值 (当前指令.英文描述, 相加 (“RCR ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 4))
     ' ea/4 SHL Eb,CL
    赋值 (当前指令.英文描述, 相加 (“SHL ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 5))
     ' ea/5 SHR Eb,CL
    赋值 (当前指令.英文描述, 相加 (“SHR ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 7))
     ' ea/7 SAR Eb,CL
    赋值 (当前指令.英文描述, 相加 (“SAR ”, i.mod__r_m文本, “,cl”))
.默认
    
.判断结束


.子程序 子程序212, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' D3  *
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 ROL Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“ROL ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 1))
     ' ea/1 ROR Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“ROR ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 2))
     ' ea/2 RCL Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“RCL ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 3))
     ' ea/3 RCR Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“RCR ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 4))
     ' ea/4 SHL Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“SHL ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 5))
     ' ea/5 SHR Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“SHR ”, i.mod__r_m文本, “,cl”))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 7))
     ' ea/7 SAR Ed,CL  *
    赋值 (当前指令.英文描述, 相加 (“SAR ”, i.mod__r_m文本, “,cl”))
.默认
    
.判断结束
 ' ea/0 ROL Ed,CL
 ' ea/1 ROR Ed,CL
 ' ea/2 RCL Ed,CL
 ' ea/3 RCR Ed,CL
 ' ea/4 SHL Ed,CL
 ' ea/5 SHR Ed,CL
 ' ea/7 SAR Ed,CL


.子程序 子程序213, 空白型, , 
 ' D4 : AAM
 ' ==========================================
赋值 (当前指令.英文描述, “AAM”)


.子程序 子程序214, 空白型, , 
 ' D5 : AAD
 ' ==========================================
赋值 (当前指令.英文描述, “AAD”)


.子程序 子程序215, 空白型, , 
 ' D6
 ' ==========================================
赋值 (当前指令.英文描述, “*D6* 错误！”)


.子程序 子程序216, 空白型, , 
 ' D7 XLAT
 ' ==========================================
赋值 (当前指令.英文描述, “XLAT”)


.子程序 子程序217, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' D8 : ESC0(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.mod, 3))
    .判断开始 (等于 (i.reg, 0))
        赋值 (当前指令.英文描述, 相加 (“FADD ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 1))
        赋值 (当前指令.英文描述, 相加 (“FMUL ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 2))
        赋值 (当前指令.英文描述, 相加 (“FCOM ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 3))
        赋值 (当前指令.英文描述, 相加 (“FCOMP ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 4))
        赋值 (当前指令.英文描述, 相加 (“FSUB ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 5))
        赋值 (当前指令.英文描述, 相加 (“FSUBR ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 6))
        赋值 (当前指令.英文描述, 相加 (“FDIV ST,ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 7))
        赋值 (当前指令.英文描述, 相加 (“FDIVR ST,ST(”, 到文本 (i.rm), “)”))
    .默认
        
    .判断结束
    
.默认
    
.判断结束
.判断开始 (等于 (i.reg, 0))
     ' D8 ea/0 FADD Real32
    赋值 (当前指令.英文描述, 相加 (“FADD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 1))
     ' D8 ea/1 FMUL Real32
    赋值 (当前指令.英文描述, 相加 (“FMUL ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
     ' D8 ea/2 FCOM Real32
    赋值 (当前指令.英文描述, 相加 (“FCOM ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
     ' D8 ea/3 FCOMP Real32
    赋值 (当前指令.英文描述, 相加 (“FCOMP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
     ' D8 ea/4 FSUB Real32
    赋值 (当前指令.英文描述, 相加 (“FSUB ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
     ' D8 ea/5 FSUBR Real32
    赋值 (当前指令.英文描述, 相加 (“FSUBR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
     ' D8 ea/6 FDIV Real32
    赋值 (当前指令.英文描述, 相加 (“FDIV ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
     ' D8 ea/7 FDIVR Real32
    赋值 (当前指令.英文描述, 相加 (“FDIVR ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte D8”)
.判断结束


.子程序 子程序218, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' D9 : ESC1(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.mod, 3))
    .判断开始 (等于 (i.reg, 0))
        赋值 (当前指令.英文描述, 相加 (“FLD ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 1))
        赋值 (当前指令.英文描述, 相加 (“FXCH ST(”, 到文本 (i.rm), “)”))
    .默认
        
    .判断结束
    
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 D0
    赋值 (当前指令.英文描述, “FNOP”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 E0
    赋值 (当前指令.英文描述, “FCHS”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 E1
    赋值 (当前指令.英文描述, “FABS”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 E4
    赋值 (当前指令.英文描述, “FTST”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 E5
    赋值 (当前指令.英文描述, “FXAM”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 E8
    赋值 (当前指令.英文描述, “FLD1”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 E9
    赋值 (当前指令.英文描述, “FLDL2T”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 EA
    赋值 (当前指令.英文描述, “FLDL2E”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 EB
    赋值 (当前指令.英文描述, “FLDPI”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 EC
    赋值 (当前指令.英文描述, “FLDLG2”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 ED
    赋值 (当前指令.英文描述, “FLDLN2”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 EE
    赋值 (当前指令.英文描述, “FLDZ”)
.判断 (等于 (当前指令.寄存器选择位, 208)) ' D9 F0
    赋值 (当前指令.英文描述, “F2XM1”)
.判断 (等于 (当前指令.寄存器选择位, 241)) ' D9 F1
    赋值 (当前指令.英文描述, “FYL2X”)
.判断 (等于 (当前指令.寄存器选择位, 242)) ' D9 F2
    赋值 (当前指令.英文描述, “FPTAN”)
.判断 (等于 (当前指令.寄存器选择位, 243)) ' D9 F3
    赋值 (当前指令.英文描述, “FPATAN”)
.判断 (等于 (当前指令.寄存器选择位, 244)) ' D9 F4
    赋值 (当前指令.英文描述, “FXTRACT”)
.判断 (等于 (当前指令.寄存器选择位, 245)) ' D9 F5
    赋值 (当前指令.英文描述, “FPREM1”)
.判断 (等于 (当前指令.寄存器选择位, 246)) ' D9 F6
    赋值 (当前指令.英文描述, “FDECSTP”)
.判断 (等于 (当前指令.寄存器选择位, 247)) ' D9 F7
    赋值 (当前指令.英文描述, “FINCSTP”)
.判断 (等于 (当前指令.寄存器选择位, 248)) ' D9 F8
    赋值 (当前指令.英文描述, “FPREM”)
.判断 (等于 (当前指令.寄存器选择位, 249)) ' D9 F9
    赋值 (当前指令.英文描述, “FYL2XP1”)
.判断 (等于 (当前指令.寄存器选择位, 250)) ' D9 FA
    赋值 (当前指令.英文描述, “FSQRT”)
.判断 (等于 (当前指令.寄存器选择位, 251)) ' D9 FB
    赋值 (当前指令.英文描述, “FSINCOS”)
.判断 (等于 (当前指令.寄存器选择位, 252)) ' D9 FC
    赋值 (当前指令.英文描述, “FRNDINT”)
.判断 (等于 (当前指令.寄存器选择位, 253)) ' D9 FD
    赋值 (当前指令.英文描述, “FSCALE”)
.判断 (等于 (当前指令.寄存器选择位, 254)) ' D9 FE
    赋值 (当前指令.英文描述, “FSIN”)
.判断 (等于 (当前指令.寄存器选择位, 255)) ' D9 FF
    赋值 (当前指令.英文描述, “FCOS”)
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FLD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FST ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FSTP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
    赋值 (当前指令.英文描述, 相加 (“FLDENV ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
    赋值 (当前指令.英文描述, 相加 (“FLDCW ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, 相加 (“FSTENVE ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FSTCWE ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte D9”)
.判断结束


.子程序 子程序219, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' DA : EAC2(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (当前指令.寄存器选择位, 233))
    赋值 (当前指令.英文描述, “FUCOMPP”)
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FIADD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 1))
    赋值 (当前指令.英文描述, 相加 (“FIMUL ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FICOM ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FICOMP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
    赋值 (当前指令.英文描述, 相加 (“FISUB ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
    赋值 (当前指令.英文描述, 相加 (“FISUBR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, 相加 (“FIDIV ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FIDIVR ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte DA”)
.判断结束


.子程序 子程序220, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' DB : EAC3(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (当前指令.寄存器选择位, 226)) ' EB E2
    赋值 (当前指令.英文描述, “FCLEX”)
.判断 (等于 (当前指令.寄存器选择位, 227)) ' EB E3
    赋值 (当前指令.英文描述, “FINIT”)
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FILD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FIST ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FISTP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
    赋值 (当前指令.英文描述, 相加 (“FLD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FSTP ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte DB”)
.判断结束


.子程序 子程序221, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' DC : EAC4(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.mod, 3))
    .判断开始 (等于 (i.reg, 0)) ' DC C0+i
        赋值 (当前指令.英文描述, 相加 (“FADD ST(”, 到文本 (i.rm), “),ST”))
    .判断 (等于 (i.reg, 1)) ' DC C8+i
        赋值 (当前指令.英文描述, 相加 (“FMUL ST(”, 到文本 (i.rm), “),ST”))
    .判断 (等于 (i.reg, 4)) ' DC E0+i
        赋值 (当前指令.英文描述, 相加 (“FSUB ST(”, 到文本 (i.rm), “),ST”))
    .判断 (等于 (i.reg, 5)) ' DC E8+i
        赋值 (当前指令.英文描述, 相加 (“FSUBR ST(”, 到文本 (i.rm), “),ST”))
    .判断 (等于 (i.reg, 6)) ' DC F0+i
        赋值 (当前指令.英文描述, 相加 (“FDIVR ST(”, 到文本 (i.rm), “),ST”))
    .判断 (等于 (i.reg, 7)) ' DC F8+i
        赋值 (当前指令.英文描述, 相加 (“FDIV ST(”, 到文本 (i.rm), “),ST”))
    .默认
        
    .判断结束
    
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FADD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 1))
    赋值 (当前指令.英文描述, 相加 (“FMUL ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FCOM ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FCOMP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
    赋值 (当前指令.英文描述, 相加 (“FSUB ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
    赋值 (当前指令.英文描述, 相加 (“FSUBR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, 相加 (“FDIV ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FDIVR ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte DC”)
.判断结束


.子程序 子程序222, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' DD : EAC5(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.mod, 3))
    .判断开始 (等于 (i.reg, 0)) ' DD C0+i
        赋值 (当前指令.英文描述, 相加 (“FFREE ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 2)) ' DD D0+i
        赋值 (当前指令.英文描述, 相加 (“FST ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 3)) ' DD D8+i
        赋值 (当前指令.英文描述, 相加 (“FSTP ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 4)) ' DD E0+i
        赋值 (当前指令.英文描述, 相加 (“FUCOM ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 5)) ' DD E8+i
        赋值 (当前指令.英文描述, 相加 (“FUCOMP ST(”, 到文本 (i.rm), “)”))
    .默认
        
    .判断结束
    
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FLD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FST ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FSTP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
    赋值 (当前指令.英文描述, 相加 (“FRSTOR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, 相加 (“FSAVE ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FSTSW ”, 子文本替换 (i.mod__r_m文本, “dword”, “word”, , , 真)))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte DC”)
.判断结束


.子程序 子程序223, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' DE : EAC6(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (当前指令.寄存器选择位, 217)) ' DE  D9
    赋值 (当前指令.英文描述, “FCOMPP”)
.判断 (等于 (i.mod, 3))
    .判断开始 (等于 (i.reg, 0)) ' DE C0+i
        赋值 (当前指令.英文描述, 相加 (“FADDP ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 1)) ' DE C8+i
        赋值 (当前指令.英文描述, 相加 (“FMULP ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 4)) ' DE E0+i
        赋值 (当前指令.英文描述, 相加 (“FSUBRP ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 5)) ' DE E8+i
        赋值 (当前指令.英文描述, 相加 (“FSUBP ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 6)) ' DE F0+i
        赋值 (当前指令.英文描述, 相加 (“FDIVRP ST(”, 到文本 (i.rm), “)”))
    .判断 (等于 (i.reg, 7)) ' DE F8+i
        赋值 (当前指令.英文描述, 相加 (“FDIVP ST(”, 到文本 (i.rm), “)”))
    .默认
        
    .判断结束
    
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FIADD ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 1))
    赋值 (当前指令.英文描述, 相加 (“FIMUL ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FICOM ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FICOMP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
    赋值 (当前指令.英文描述, 相加 (“FISUB ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
    赋值 (当前指令.英文描述, 相加 (“FISUBR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, 相加 (“FIDIV ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FIDIVR ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte DE”)
.判断结束


.子程序 子程序224, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' DF : EAC7(NDP)
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (当前指令.寄存器选择位, 224))
    赋值 (当前指令.英文描述, “FSTSW ax”)
.判断 (等于 (i.reg, 0))
    赋值 (当前指令.英文描述, 相加 (“FILD ”, i.mod__r_m文本)) ' Int16
.判断 (等于 (i.reg, 2))
    赋值 (当前指令.英文描述, 相加 (“FIST ”, i.mod__r_m文本)) ' Int16
.判断 (等于 (i.reg, 3))
    赋值 (当前指令.英文描述, 相加 (“FISTP ”, i.mod__r_m文本)) ' Int16
.判断 (等于 (i.reg, 4))
    赋值 (当前指令.英文描述, 相加 (“FBLD ”, i.mod__r_m文本)) ' Bcd80
.判断 (等于 (i.reg, 5))
    赋值 (当前指令.英文描述, 相加 (“FILD ”, i.mod__r_m文本)) ' Int64
.判断 (等于 (i.reg, 6))
    赋值 (当前指令.英文描述, 相加 (“FBSTP ”, i.mod__r_m文本)) ' Bcd80
.判断 (等于 (i.reg, 7))
    赋值 (当前指令.英文描述, 相加 (“FISTP ”, i.mod__r_m文本)) ' Int64
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
    赋值 (当前指令.英文描述, “byte DF”)
.判断结束


.子程序 子程序225, 空白型, , 
 ' E0 disp8 : LOOPNE disp8(LOOPNE/LOOPNZ)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“LOOPNE ”, 取偏移地址_8位 ()))


.子程序 子程序226, 空白型, , 
 ' E1 disp8 : LOOPE disp8 (LPPOE/LOOPZ)
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“LOOPE ”, 取偏移地址_8位 ()))


.子程序 子程序227, 空白型, , 
 ' E2 disp8 : LOOP disp8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“LOOP ”, 取偏移地址_8位 ()))


.子程序 子程序228, 空白型, , 
 ' E3 data8 : JCXZ data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JCXZ ”, 取8位数据 ()))


.子程序 子程序229, 空白型, , 
 ' E4 data8 : IN AL,data8
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“IN al,”, 取8位数据 ()))


.子程序 子程序230, 空白型, , 
 ' E5 data8 : IN EAX,data8  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“IN eax,”, 取8位数据 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“IN ax,”, 取8位数据 ()))
.如果结束


.子程序 子程序231, 空白型, , 
 ' E6 data8 : OUT data8,AL
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“OUT ”, 取8位数据 (), “,al”))


.子程序 子程序232, 空白型, , 
 ' E7 data8 : OUT data8,EAX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“OUT ”, 取8位数据 (), “,eax”))
.否则
    赋值 (当前指令.英文描述, 相加 (“OUT ”, 取8位数据 (), “,ax”))
.如果结束


.子程序 子程序233, 空白型, , 
 ' E8 ea(32) : CALL ea32    *  'ea32 为32位偏移量，CALL 下一句地址+偏移量
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“CALL ”, 取偏移地址_32位 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“CALL ”, 取偏移地址_16位 ()))
.如果结束


.子程序 子程序234, 空白型, , 
 ' E9 disp32 : JMP disp32
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, 相加 (“JMP ”, 取偏移地址_32位 ()))
.否则
    赋值 (当前指令.英文描述, 相加 (“JMP ”, 取偏移地址_16位 ()))
.如果结束


.子程序 子程序235, 空白型, , 
.局部变量 i, 文本型, , , 
.局部变量 j, 文本型, , , 

 ' EA ea(48) : JMP FAR ea48  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (i, 取32位数据 ())
.否则
    赋值 (i, 取16位数据 ())
.如果结束
赋值 (j, 取16位数据 ())
赋值 (当前指令.英文描述, 相加 (“JMP ”, j, “:”, i))
 ' 本源码来自易语言资源网(www.5A5X.com)

.子程序 子程序236, 空白型, , 
 ' EB disp8 : JMP disp8 < 为偏移量
 ' ==========================================
赋值 (当前指令.英文描述, 相加 (“JMP ”, 取偏移地址_8位 ()))


.子程序 子程序237, 空白型, , 
 ' EC : IN AL,DX
 ' ==========================================
赋值 (当前指令.英文描述, “IN al,dx”)


.子程序 子程序238, 空白型, , 
 ' ED : IN EAX,DX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “IN eax,dx”)
.否则
    赋值 (当前指令.英文描述, “IN ax,dx”)
.如果结束


.子程序 子程序239, 空白型, , 
 ' EE : OUT DX,AL
 ' ==========================================
赋值 (当前指令.英文描述, “OUT dx,al”)


.子程序 子程序240, 空白型, , 
 ' EF : OUT DX,EAX  *
 ' ==========================================
.如果 (尺寸为32)
    赋值 (当前指令.英文描述, “OUT dx,eax”)
.否则
    赋值 (当前指令.英文描述, “OUT dx,ax”)
.如果结束


.子程序 子程序241, 空白型, , 
 ' F0 : LOCK      前缀
 ' ==========================================
赋值 (当前指令.英文描述, “LOCK”)


.子程序 子程序242, 空白型, , 
 ' F1
 ' ==========================================
赋值 (当前指令.英文描述, “*F1* 错误！”)


.子程序 子程序243, 空白型, , 
 ' F2 : REPNE/REPNZ
 ' ==========================================
赋值 (当前指令.英文描述, “REPNE”)


.子程序 子程序244, 空白型, , 
 ' F3 : REP/REPE/REPZ
 ' ==========================================
赋值 (当前指令.英文描述, “REP”)


.子程序 子程序245, 空白型, , 
 ' F4 : HLT
 ' ==========================================
赋值 (当前指令.英文描述, “HLT”)


.子程序 子程序246, 空白型, , 
 ' F5 : CMC
 ' ==========================================
赋值 (当前指令.英文描述, “CMC”)


.子程序 子程序247, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' F6 ea/n
 ' ==========================================
赋值 (i, ea处理_N (假))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data8  TEST Eb,data8
    赋值 (当前指令.英文描述, 相加 (“TEST byte ptr ”, i.mod__r_m文本, “,”, 取8位数据 ()))
.判断 (等于 (i.reg, 1))
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.英文描述, “byte 0F”)
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 2))
     ' ea/2  NOT Eb
    赋值 (当前指令.英文描述, 相加 (“NOT byte ptr ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
     ' ea/3 NEG Eb
    赋值 (当前指令.英文描述, 相加 (“NEG byte ptr ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
     ' ea/4 MUL AL,Eb
    赋值 (当前指令.英文描述, 相加 (“MUL al,byte ptr ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
     ' ea/5 IMUL AL,Eb
    赋值 (当前指令.英文描述, 相加 (“IMUL al,byte ptr ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
     ' ea/6 DIV AL,Eb
    赋值 (当前指令.英文描述, 相加 (“DIV al,byte ptr ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 7))
     ' ea/7 IDIV AL,Eb
    赋值 (当前指令.英文描述, 相加 (“IDIV al,byte ptr ”, i.mod__r_m文本))
.默认
    
.判断结束


.子程序 子程序248, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' F7 ea/n  *
 ' ==========================================
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 data32  TEST Ed,data32  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“TEST ”, i.mod__r_m文本, “,”, 取32位数据 ()))
    .否则
        赋值 (当前指令.英文描述, 相加 (“TEST ”, i.mod__r_m文本, “,”, 取16位数据 ()))
    .如果结束
    
.判断 (等于 (i.reg, 1))
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.英文描述, “byte F7”)
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断 (等于 (i.reg, 2))
     ' ea/2  NOT Ed  *
    赋值 (当前指令.英文描述, 相加 (“NOT ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
     ' ea/3 NEG Ed  *
    赋值 (当前指令.英文描述, 相加 (“NEG ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
     ' ea/4 MUL EAX,Ed  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“MUL eax,”, i.mod__r_m文本))
    .否则
        赋值 (当前指令.英文描述, 相加 (“MUL ax,”, i.mod__r_m文本))
    .如果结束
    
.判断 (等于 (i.reg, 5))
     ' ea/5 IMUL EAX,Ed  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“IMUL eax,”, i.mod__r_m文本))
    .否则
        赋值 (当前指令.英文描述, 相加 (“IMUL ax,”, i.mod__r_m文本))
    .如果结束
    
.判断 (等于 (i.reg, 6))
     ' ea/6 DIV EAX,Ed  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“DIV eax,”, i.mod__r_m文本))
    .否则
        赋值 (当前指令.英文描述, 相加 (“DIV ax,”, i.mod__r_m文本))
    .如果结束
    
.判断 (等于 (i.reg, 7))
     ' ea/7 IDIV EAX,Ed  *
    .如果 (尺寸为32)
        赋值 (当前指令.英文描述, 相加 (“IDIV eax,”, i.mod__r_m文本))
    .否则
        赋值 (当前指令.英文描述, 相加 (“IDIV ax,”, i.mod__r_m文本))
    .如果结束
    
.默认
    
.判断结束


.子程序 子程序249, 空白型, , 
 ' F8 : CLC
 ' ==========================================
赋值 (当前指令.英文描述, “CLC”)


.子程序 子程序250, 空白型, , 
 ' F9 : STC
 ' ==========================================
赋值 (当前指令.英文描述, “STC”)


.子程序 子程序251, 空白型, , 
 ' FA : CLI
 ' ==========================================
赋值 (当前指令.英文描述, “CLI”)


.子程序 子程序252, 空白型, , 
 ' FB : STI
 ' ==========================================
赋值 (当前指令.英文描述, “STI”)


.子程序 子程序253, 空白型, , 
 ' FC : CLD
 ' ==========================================
赋值 (当前指令.英文描述, “CLD”)


.子程序 子程序254, 空白型, , 
 ' FD : STD
 ' ==========================================
赋值 (当前指令.英文描述, “STD”)


.子程序 子程序255, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' FE ea/(0,1) :
 ' ==========================================
赋值 (i, ea处理_N (假))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 INC Eb
    赋值 (当前指令.英文描述, 相加 (“INC ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 1))
     ' ea/1 DEC Eb
    赋值 (当前指令.英文描述, 相加 (“DEC ”, i.mod__r_m文本))
.默认
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.英文描述, “byte FE”)
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断结束


.子程序 子程序256, 空白型, , 
.局部变量 i, ea_N数据类型1, , , 

 ' FF ea/n(n=0~6)  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
赋值 (i, ea处理_N (真))
.判断开始 (等于 (i.reg, 0))
     ' ea/0 INC Ed  *
    赋值 (当前指令.英文描述, 相加 (“INC ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 1))
     ' ea/1 DEC Ed  *
    赋值 (当前指令.英文描述, 相加 (“DEC ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 2))
     ' ea/2 CALL Ed  *
    赋值 (当前指令.英文描述, 相加 (“CALL ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 3))
     ' ea/3 CALL FAR ea  *
    赋值 (当前指令.英文描述, 相加 (“CALL FAR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 4))
     ' ea/4 JMP Ed  *
    赋值 (当前指令.英文描述, 相加 (“JMP ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 5))
     ' ea/5 JMP FAR ea  *
    赋值 (当前指令.英文描述, 相加 (“JMP FAR ”, i.mod__r_m文本))
.判断 (等于 (i.reg, 6))
     ' ea/6 PUSH Ed  *
    赋值 (当前指令.英文描述, 相加 (“PUSH ”, i.mod__r_m文本))
.默认
    赋值 (当前指令.英文描述, “byte FF”)
    赋值 (当前位置, 相减 (当前位置, 1))
    赋值 (当前指令.指令集, 取字节集左边 (当前指令.指令集, 相减 (取字节集长度 (当前指令.指令集), 1)))
.判断结束


.窗口程序集 窗口程序集1, , , 

.程序集变量 待显示文本, 文本型, , , 
.程序集变量 i, 字节集, , , 
.子程序 _窗口1_创建完毕, 空白型, , 
赋值 (.内容, 待显示文本)
 ' 本源码来自易语言资源网(www.5A5X.com)

.子程序 显示文本, 空白型, , 
.参数 显示文本, 文本型, , 

赋值 (待显示文本, 显示文本)
载入 (窗口1, , 真)


.子程序 _窗口1_尺寸被改变, 空白型, , 
赋值 (.宽度, 相减 (窗口1., 120))
赋值 (.高度, 相减 (窗口1., 56))
赋值 (.顶边, 相减 (窗口1., 48))
赋值 (.宽度, .宽度)
赋值 (.左边, 相减 (窗口1., 108))
赋值 (.左边, 相减 (窗口1., 108))
赋值 (.左边, 相减 (窗口1., 108))
赋值 (.左边, 相减 (窗口1., 108))
赋值 (.左边, 相减 (窗口1., 108))
赋值 (.左边, 相减 (窗口1., 108))
赋值 (.左边, 相减 (窗口1., 108))
 ' 本源码来自易语言资源网(www.5A5X.com)

.子程序 _按钮1_被单击, 空白型, , 
.局部变量 文件号, 整数型, , , 

赋值 (.初始目录, 取运行目录 ())
.如果 (打开 ())
    赋值 (文件号, 打开文件 (.文件名, #读入, ))
    .如果真 (等于 (文件号, 0))
        赋值 (.内容, “＝＝＝ 打开文件失败！ ＝＝＝”)
        返回 ()
    .如果真结束
    赋值 (i, 读入字节集 (文件号, 取文件长度 (文件号)))
    .如果真 (等于 (取字节集长度 (i), 0))
        赋值 (.内容, “ -------------- 文件长度为0 !! ----------------”)
        返回 ()
    .如果真结束
    赋值 (.禁止, 假)
    赋值 (窗口1., .文件名)
    关闭文件 (文件号)
    赋值 (.内容, “”)
.否则
    返回 ()
.如果结束


.子程序 _按钮2_被单击, 空白型, , 
.局部变量 s, 整数型, , , 
.局部变量 x, 整数型, , , 
.局部变量 l, 整数型, , , 
.局部变量 e, 整数型, , , 
.局部变量 文本信息, 文本型, , , 
.局部变量 w, 整数型, , , 
.局部变量 指令集, 字节集, , , 

赋值 (.内容, “”)
赋值 (s, 到数值 (.内容))
赋值 (w, s)
赋值 (l, 取字节集长度 (i))
.如果真 (小于 (s, 1))
    赋值 (.内容, “--------------  起始位置输入错误！----------------”)
    返回 ()
.如果真结束
赋值 (x, 到数值 (.内容))
赋值 (.最大位置, x)
赋值 (指令集, 取字节集左边 (i, x))
赋值 (e, 相加 (x, s))
.循环判断首 ()
    赋值 (文本信息, 相加 (文本信息, 字节集转为汇编指令_单行 (指令集, s, .选中)))
    赋值 (.位置, 相加 (相减 (s, w), 1))
.循环判断尾 (并且 (小于 (s, e), 小于 (s, l), 不等于 (s, -1)))
赋值 (.内容, 文本信息)
赋值 (.位置, 0)



 ' 不属于任何一个程序集、类模块的函数：
