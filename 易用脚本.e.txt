 ' 文件类型：Windows模块源码

 ' 程序名称：脚本引擎
 ' 程序描述：纯易语言开发的脚本语言,支持中英文混合开发.
 ' 程序作者：周少礼(水墨剑客)
 ' 邮政编码：314002
 ' 联系地址：浙江省嘉兴市七星镇
 ' 联系电话：
 ' 传真号码：
 ' 电子信箱：lcgyzsl@163.com
 ' 主页地址：
 ' 版权声明：脚本引擎处于测试阶段.
如有问题,请联系 QQ:174487481 Email:Lcgyzsl@163.com

 ' 版本号：2.0
 ' 创建号：0.0



.常量 未知类型, "-1", , '数据类型------------------------------
.常量 短整型, "1", , 
.常量 布尔型, "2", , 
.常量 字符型, "3", , 
.常量 浮点型, "4", , 
.常量 长整型, "5", , '数据类型------------------------------
.常量 程序版本, "“2.0”", , 
.常量 关键字, "“int,短整型,
long,长整型,
char,字符型,
bool,布尔型,
float,浮点型,
sub,过程,
function,函数,
echo,信息框,
input,输入框,
if,如果,
else,否则,
end if,如果结束,
goto,跳到标签,
for,计次循环,
next,计次环尾,
while,判断循环,
loop,判断环尾,
exit,结束,
return,返回,
call,调用过程,
default,默认”", , 
.常量 算星期几, "“过程 启动过程()
{ 
    信息框(计算星期几(2007,8,9));               
}


函数 计算星期几(长整型 年,长整型 月,长整型 日)
{  
           字符型 星期文本="一二三四五六日";
           长整型 世纪,星期;

           
           //echo( 07 + 取整(7 / 4) + 取整(20 / 4) - 20* 2 + 取整(26 * (8+1)/ 10) + 10 - 1;

           //需要判断年月日是否合法

           如果(年<=0 || (取文本长度1(年)<>4))
         	   返回 "年份输入错误";
           如果结束;
           如果(月<=0 || 月>12)
         	   返回  "月份输入错误";
           如果结束;
           如果(日<=0 || 日>31)
         	   返回 "日期输入错误";
           如果结束;
           如果(月=4 || 月=6 || 月=9 || 月=11)
                 如果(日>30)
                      返回 "月份日期输入错误";
                 如果结束;
           如果结束;
           如果(年%4=0  && 月=2)
         	  如果(日>29)
         	     返回 "2月日期输入错误";
         	  如果结束;
           否则
                  如果(日>28)
         	     返回 "2月日期输入错误";
                  如果结束;
           如果结束;
           //根据公式的要求调整年,月
           如果(月=1||月=2)
               月 = 月 + 12;
               年=年-1;
           如果结束;
           
           
           世纪=取文本左边1(年,2);
           年=取文本右边1(年,2);
           //套公式计算
           星期 = 取整(世纪 / 4)+年+ 取整(年 / 4)- 世纪 * 2+取整(26 * (月 + 1) / 10)+ 日 - 1;
           星期 = 星期 % 7;//余数是几就是星期几,如果余数是0，则为星期日
            
           如果(星期 <= 0)
           	   星期 += 7;
           如果结束;
           返回 "星期" & 取文本中间1(星期文本,星期 ,1);
}
”", , 
.常量 多条件语句, "“//脚本语言的调用方法:

过程 启动过程()
{
    INT a = 3;
    测试表达式 (a)
        测试结果:1
          调用过程 前进 (100);
          echo(1);
        测试结果:2
          调用过程 后退 (100);
          echo(2);
        测试结果:<=3
          调用过程 左转(90);
          echo(3);
        测试结果:4        
          调用过程 右转(90);
          echo(4);
        测试结果:默认
          信息框("不在测试结果内");
　　测试表达式结束;
}”", , Switch语句
.常量 , , , 


 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 4 4 系统核心支持库



 ' 所需要的模块
 ' 汇编模块 $汇编模块.ec
 ' 模块_中英文文本处理 D:\Program Files\e\src\易用脚本\模块_中英文文本处理.ec


数据类型 变量类型, , 所有变量的类型
    .成员 名称, 文本型, , , 
    .成员 类型, 整数型, , , 
    .成员 值, 变体型, , , 
    .成员 只读, 逻辑型, , , 
    .成员 过程, 文本型, , , 

数据类型 数组类型, , 所有变量的类型
    .成员 名称, 文本型, , , 
    .成员 类型, 整数型, , , 
    .成员 值, 数组成员值类, , , 
    .成员 过程, 文本型, , , 

数据类型 过程集类型, , 
    .成员 名称, 文本型, , , 
    .成员 参数数量, 空白型, , , 
    .成员 是否具有返回值, 逻辑型, , , 
    .成员 代码段, 文本型, , , 
    .成员 变量列表, 文本型, , , 
    .成员 保留变量, 逻辑型, , , 如果在执行代码段内递归调用时，为了不失误将过程级变量清除，所以使用这个来判断是否要清除

.全局变量 G变量集, 变量类型, , "0", 保存脚本中的所有变量的数组
.全局变量 G数组变量集, 数组类型, , "0", 保存脚本中的所有数组变量的数组
.全局变量 G变量数量, 整数型, , , 变量的总数
.全局变量 G数组变量数量, 整数型, , , 数组变量的总数
.全局变量 G过程数量, 整数型, , , 所有过程的数量
.全局变量 G分析出错, 逻辑型, , , 
.全局变量 G分析出错文本, 文本型, , , 
.全局变量 G过程类实体, 过程类, , , 
.全局变量 G外部过程类, 外部注册函数类, , , 
.全局变量 GRegNum, 空白型, , , 
.全局变量 G当前执行类模块, 类执行模块, , , 
.全局变量 G内置常量数量, 空白型, , , 
.全局变量 G注册函数数量, 空白型, , , 

.DLL命令 CloseHandle, 整数型, "", "CloseHandle", 公开, 
    .参数 hObject, 整数型, , 

.DLL命令 GetCurrentProcessId, 整数型, "", "GetCurrentProcessId", 公开, 

.DLL命令 GetProcAddress, 整数型, "", "GetProcAddress", 公开, 
    .参数 hinst, 整数型, , 
    .参数 函数过程名, 文本型, , 

.DLL命令 GetModuleHandle, 整数型, "", "GetModuleHandleA", 公开, 
    .参数 lpModuleName, 文本型, , 

.DLL命令 OpenProcess, 整数型, "", "OpenProcess", 公开, 
    .参数 a, 整数型, , 
    .参数 b, 整数型, , 
    .参数 c, 整数型, , 

.DLL命令 LoadLibrary, 整数型, "", "LoadLibraryA", 公开, 载入指定的动态链接库，并将它映射到当前进程使用的地址空间。一旦载入，即可访问库内保存的资源
    .参数 lpLibFileName, 文本型, , 指定要载入的动态链接库的名称

.DLL命令 FreeLibrary, 整数型, "", "FreeLibrary", 公开, 
    .参数 DLL句柄, 整数型, , 

.DLL命令 WriteProcessMemory, 整数型, "", "WriteProcessMemory", 公开, 
    .参数 要写进程的句柄, 整数型, , 
    .参数 写内存的起始地址, 整数型, , 
    .参数 写入数据的地址, 整数型, , 
    .参数 要写的字节数, 整数型, , 
    .参数 实际写入的子节数, 整数型, 传址, 

.DLL命令 ReadProcessMemory, 整数型, "", "ReadProcessMemory", 公开, 
    .参数 要读进程的句柄, 整数型, , 
    .参数 读内存的起始地址, 整数型, , 
    .参数 读入数据的地址, 整数型, , 
    .参数 要读入的字节数, 整数型, , 
    .参数 实际读入的子节数, 整数型, , 

.DLL命令 VirtualAllocEx, 整数型, "", "VirtualAllocEx", 公开, 
    .参数 目标进程的句柄, 整数型, , 
    .参数 分配的起始地址, 整数型, , 
    .参数 分配空间的大小, 整数型, , byte
    .参数 分配的类型, 整数型, , 
    .参数 读写的保护模式, 整数型, , 

.DLL命令 GetWindowThreadProcessId, 整数型, "", "GetWindowThreadProcessId", 公开, 
    .参数 xc, 整数型, , 
    .参数 jb, 整数型, 传址, 

.DLL命令 VirtualProtectEx, 整数型, "", "VirtualProtectEx", 公开, 
    .参数 要修改内存的进程句柄, 整数型, , 
    .参数 要修改内存的起始地址, 整数型, , 
    .参数 修改内存的字节, 整数型, , 
    .参数 修改后的内存属性, 整数型, , 
    .参数 修改前的内存属性的地址, 整数型, , 

.程序集 启动程序集, , , 

.子程序 _启动子程序, 整数型, , 请在本子程序中放置易模块初始化代码
启动 ()

 ' S ＝ 取运行目录 () ＋ “\factorial.txt”
 ' 注册外部函数 (“取启动时间”, 到数值 (&自定义函数_取启动时间))
 ' 信息框 (求自然对数 (5), 0, )

 ' 添加并执行代码 (到文本 (#多条件语句))
 ' 添加并执行代码 (到文本 (读入文件 (“D:\Program Files\e\src\易用脚本\例子\loops\forloop.jks”)))

 ' 外部过程类.添加注册函数 (“xxk”, 到数值 (&子程序1))

 ' 执行代码段 (“char x;” ＋ #换行符 ＋ “x= xxk(” ＋ 字符 (34) ＋ “OK” ＋ 字符 (34) ＋ “,” ＋ 字符 (34) ＋ “你发” ＋ 字符 (34) ＋ “);” ＋ #换行符 ＋ “echo x;” ＋ #换行符 ＋ “echo 9<=8;”)
 ' 输出调试文本 (G当前执行类模块.GetExp (“多文件对话框()”))
 ' 运行 (“calc”, 假, )
 ' 输出调试文本 (L.GetExp (#input).取文本 ())
 ' 载入 (窗口1, , 真)

返回 (0)


.子程序 启动, 空白型, , 
.局部变量 匿名局部变量_7724, 空白型, , , 

添加全局常量 ()
.如果真 (等于 (GRegNum, 0))
    赋值 (GRegNum, 10)
.如果真结束
输出调试文本 (相加 (“当前目录：”, 取运行目录 ()))


.类模块 数组成员值类, , , 

.程序集变量 数据, 变体型, , "0", 所有的成员
.程序集变量 数量, 空白型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 添加成员, 空白型, 公开, 
.参数 成员值, 变体型, , 

赋值 (数量, 相加 (数量, 1))
重定义数组 (数据, 假, 数量)
赋值 (数据 [数量], 成员值)


.子程序 取数量, 整数型, 公开, 
赋值 (数量, 取数组成员数 (数据))
返回 (数量)


.子程序 取值, 变体型, 公开, 
.参数 索引, 空白型, , 

.局部变量 临时变量, 变体型, , , 


.如果真 (小于或等于 (索引, 0))
    返回 (临时变量)
    
.如果真结束

返回 (数据 [索引])


.子程序 设值, 空白型, 公开, 
.参数 索引, 空白型, , 
.参数 值, 变体型, , 

 ' 输出调试文本 (“数值” ＋ 到文本 (索引) ＋ “ 赋值:” ＋ 值.取文本 ())

数据.赋值 ( [索引], 值, )


.子程序 Dump, 文本型, 公开, 
.局部变量 l, 空白型, , , 
.局部变量 a, 文本型, , , 

.变量循环首 (1, 数量, 1, l)
    赋值 (a, 相加 (a, “    ”, 数据.取文本 ( [l], ), #换行符))
.变量循环尾 ()
返回 (a)


.子程序 重定义大小, 空白型, 公开, 
.参数 大小, 空白型, , 
.参数 保留, 逻辑型, , 

重定义数组 (数据, 保留, 大小)
赋值 (数量, 大小)


.子程序 清除所有, 空白型, 公开, 
清除数组 (数据)


.程序集 全局变量程序集, , , 

.程序集变量 匿名程序集变量_46, 空白型, , , 
.子程序 G分析声明语句, 逻辑型, , 
.参数 sLine, 文本型, 参考, 
.参数 e_pos, 空白型, , 
.参数 过程名称, 文本型, 参考 可空, 

.局部变量 TempJ, 空白型, , , 
.局部变量 TempK, 空白型, , , 
.局部变量 lVariableType, 文本型, , , 
.局部变量 lVariableName, 文本型, , , 
.局部变量 lVarNameLst, 文本型, , "0", 
.局部变量 lVariableData, 变体型, , , 
.局部变量 sTemp, 文本型, , , 
.局部变量 S, 文本型, , , 
.局部变量 S1, 文本型, , , 
.局部变量 多, 逻辑型, , , 

赋值 (sLine, TidyLine (sLine))

赋值 (lVariableType, 到小写 (删首尾空 (取文本左边 (sLine, 相减 (e_pos, 1)))))

赋值 (lVariableName, 删首尾空 (取文本中间 (sLine, 相加 (e_pos, 1), 取文本长度 (sLine)))) ' 取 int  后的一段

 ' lVarNameLst ＝ 分割文本 (lVariableName, “,”, )
赋值 (sTemp, lVariableName)

.判断循环首 (不等于 (sTemp, “”))
    赋值 (S, “”)
    赋值 (多, 假)
    赋值 (S, G当前执行类模块.GetValue (sTemp, 真).取文本 ())
    .如果 (并且 (等于 (S, “”), 多))
        异常 (1, 相加 (sLine, “ 存在无效的逗号”))
        返回 (假)
    .否则
        .如果真 (等于 (S, “”))
            跳出循环 ()
        .如果真结束
        
    .如果结束
    
    赋值 (S1, ReadChar (sTemp))
    .如果 (等于 (S1, “=”))
        .如果真 (HasSqrBrackets (S)) ' 数组不支持声明明赋值
            异常 (1, 相加 (sLine, “ 数组变量不支持声明时赋值!”))
            返回 (假)
        .如果真结束
        .如果 (或者 (等于 (lVariableType, “字符型”), 等于 (lVariableType, “char”)))
            赋值 (S, 相加 (S, “=”, 置双引号 (G当前执行类模块.GetExp (sTemp).取文本 (), 真)))
        .否则
            赋值 (S, 相加 (S, “=”, G当前执行类模块.GetExp (sTemp).取文本 ()))
        .如果结束
        
    .否则
        RetChar (sTemp, S1)
    .如果结束
    
    
    .如果 (等于 (取数组成员数 (lVarNameLst), 0))
        重定义数组 (lVarNameLst, 真, 1)
    .否则
        重定义数组 (lVarNameLst, 真, 相加 (取数组成员数 (lVarNameLst), 1))
    .如果结束
    赋值 (lVarNameLst [取数组成员数 (lVarNameLst)], S)
    赋值 (S1, ReadChar (sTemp))
    .如果 (不等于 (S1, “,”))
        RetChar (sTemp, S1)
        跳出循环 ()
    .否则
        
    .如果结束
    
    
.判断循环尾 ()

.计次循环首 (取数组成员数 (lVarNameLst), TempK)
    赋值 (lVariableName, 删首尾空 (lVarNameLst [TempK]))
    赋值 (TempJ, GetCharPos (lVariableName, “=”))
    .如果真 (大于 (TempJ, 0))
        赋值 (sTemp, 取文本中间 (lVariableName, 相加 (TempJ, 1), 取文本长度 (lVariableName)))
        .如果 (或者 (等于 (lVariableType, “字符型”), 等于 (lVariableType, “char”)))
            lVariableData.赋值 (置双引号 (删首尾空 (sTemp), 假), )
        .否则
            赋值 (lVariableData, G当前执行类模块.GetExp (删首尾空 (sTemp)))
        .如果结束
        
        
        赋值 (lVariableName, 删尾空 (取文本中间 (lVariableName, 1, 相减 (TempJ, 1))))
        .如果真 (是否为关键字 (lVariableName))
            异常 (8, 相加 (“关键字不能作标识符”, lVariableName))
            返回 (假)
            跳出循环 ()
        .如果真结束
        G变量添加变量 (lVariableName, 变量名称到类型 (lVariableType), 假, 过程名称)
        G变量赋值 (G变量数量, lVariableData)
        输出调试文本 (相加 (“定义变量：”, lVariableName, “　值：　”, lVariableData.取文本 ()))
        
        赋值 (sLine, “”)
        到循环尾 ()
        
    .如果真结束
    .如果 (HasSqrBrackets (lVariableName))
        G数组添加变量 (GetArrayInfo (lVariableName, 1).取文本 (), 变量名称到类型 (lVariableType), GetArrayInfo (lVariableName, 2).取数值 (), 过程名称)
    .否则
        .如果真 (是否为关键字 (lVariableName))
            异常 (8, 相加 (“关键字不能作标识符”, lVariableName))
            返回 (假)
            跳出循环 ()
        .如果真结束
        G变量添加变量 (lVariableName, 变量名称到类型 (lVariableType), 假, 过程名称)
        
    .如果结束
    lVariableData.清除 ()
    赋值 (lVariableName, “”)
    赋值 (TempJ, 0)
    
.计次循环尾 ()
返回 (真)


.子程序 G取类型, 整数型, , 
.参数 索引, 空白型, , 
.参数 是否数组, 逻辑型, 可空, 

.如果 (是否数组)
    返回 (G数组变量集 [索引], 类型)
.否则
    返回 (G变量集 [索引], 类型)
.如果结束


.子程序 GDump, 文本型, , 
.参数 F, 逻辑型, 可空, 

.局部变量 l, 空白型, , , 
.局部变量 a, 文本型, , , 

.变量循环首 (选择 (F, 1, 相加 (G内置常量数量, 1)), G变量数量, 1, l)
    赋值 (a, 相加 (a, “>变量:[”, G变量集 [l], 名称, “] 值: ”, G变量集.取文本 ( [l], 值, ), #换行符))
.变量循环尾 ()

.计次循环首 (G数组变量数量, l)
    赋值 (a, 相加 (a, “>数组变量[”, G数组变量集 [l], 名称, “] 值:”, G数组变量集.Dump ( [l], 值)))
.计次循环尾 ()
输出调试文本 (a)
返回 (a)


.子程序 G数组添加变量, 整数型, , 用户声明了变量数组，应该调用此程序分配内存
.参数 变量名, 文本型, , 
.参数 变量类型, 整数型, , 
.参数 变量尺寸, 空白型, 可空, 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 计数, 空白型, , , 

.如果真 (大于 (G数组取变量索引 (变量名, 过程名称), 0))
    .如果 (等于 (G过程类实体.取过程是否保留变量 (过程名称), 假))
        异常 (0, 相加 (“重复定义变量”, 变量名))
        返回 (0)
    .否则
        返回 (G数组取变量索引 (变量名, 过程名称))
    .如果结束
    
.如果真结束

赋值 (G数组变量数量, 相加 (G数组变量数量, 1))
重定义数组 (G数组变量集, 真, G数组变量数量)
赋值 (G数组变量集 [G数组变量数量], 名称, 变量名)
赋值 (G数组变量集 [G数组变量数量], 类型, 变量类型)
赋值 (G数组变量集 [G数组变量数量], 过程, 过程名称)
.如果真 (大于 (变量尺寸, 0))
    .计次循环首 (变量尺寸, 计数)
        G数组变量集.添加成员 ( [G数组变量数量], 值, 变量类型的默认值 (变量类型))
    .计次循环尾 ()
.如果真结束
返回 (G数组变量数量)


.子程序 G数组取变量索引, 整数型, , 
.参数 变量名, 文本型, , 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 计数, 整数型, , , 

.如果真 (等于 (G数组变量数量, 0))
    返回 (0)
.如果真结束
.计次循环首 (G数组变量数量, 计数)
    .如果真 (等于 (到小写 (G数组变量集 [计数], 名称), 到小写 (变量名)))
        .如果 (并且 (大于 (取文本长度 (过程名称), 0), 大于 (取文本长度 (G数组变量集 [计数], 过程), 0)))
            .如果真 (等于 (到小写 (G数组变量集 [计数], 过程), 到小写 (过程名称)))
                返回 (计数)
            .如果真结束
            
        .否则
            返回 (计数)
        .如果结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (0)


.子程序 变量类型的默认值, 变体型, , 
.参数 变量类型, 整数型, , 

.局部变量 临时变量, 变体型, , , 

.判断开始 (等于 (变量类型, #短整型))
    临时变量.赋值 (0, )
.判断 (等于 (变量类型, #长整型))
    临时变量.赋值 (0, )
.判断 (等于 (变量类型, #浮点型))
    临时变量.赋值 (0, )
.判断 (等于 (变量类型, #字符型))
    临时变量.赋值 (“”, )
.判断 (等于 (变量类型, #布尔型))
    临时变量.赋值 (假, )
.判断 (等于 (变量类型, #未知类型))
    临时变量.赋值 (“”, )
.默认
    
.判断结束
返回 (临时变量)


.子程序 索引出错, 逻辑型, , 
.参数 NO, 空白型, , 
.参数 INFO, 文本型, , 

异常 (2, “找不到变量成员　或　数组变量的成员”)

返回 (真)

.子程序 G数组取值, 变体型, , 
.参数 索引, 空白型, , 
.参数 值索引, 空白型, , 

.局部变量 临时变量, 变体型, , , 
.局部变量 匿名局部变量_7857, 空白型, , , 

.如果真 (大于 (索引, 0))
    返回 (G数组变量集.取值 ( [索引], 值, 值索引))
.如果真结束
返回 (临时变量)

.子程序 G数组取上标, 整数型, , 
.参数 索引, 空白型, , 

返回 (G数组变量集.取数量 ( [索引], 值))


.子程序 G数组重定义尺寸, 空白型, , 
.参数 索引, 空白型, , 
.参数 大小, 空白型, , 
.参数 保留, 逻辑型, , 

G数组变量集.重定义大小 ( [索引], 值, 大小, 保留)
赋值 (G数组变量数量, 大小)


.子程序 G数组销毁数组, 空白型, , 
.参数 索引, 空白型, , 

.如果真 (小于或等于 (索引, 0))
    异常 (4, “索引超出下标”)
    返回 ()
.如果真结束
G数组变量集.清除所有 ( [索引], 值)


.子程序 G数组赋值, 空白型, , 
.参数 索引, 空白型, , 
.参数 值索引, 空白型, , 
.参数 值, 变体型, , 

.如果真 (小于或等于 (索引, 0))
    异常 (4, “索引超出下标”)
    返回 ()
.如果真结束

G数组变量集.设值 ( [索引], 值, 值索引, 值)

.子程序 G变量取变量索引, 整数型, , 
.参数 变量名, 文本型, , 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 计数, 整数型, , , 

 ' 置错误提示管理 (&查找出错)
.如果真 (等于 (G变量数量, 0))
    返回 (0)
.如果真结束
.计次循环首 (G变量数量, 计数)
    .如果真 (等于 (到小写 (G变量集 [计数], 名称), 到小写 (变量名)))
        .如果 (并且 (大于 (取文本长度 (过程名称), 0), 大于 (取文本长度 (G变量集 [计数], 过程), 0)))
            .如果真 (等于 (到小写 (G变量集 [计数], 过程), 到小写 (过程名称)))
                返回 (计数)
            .如果真结束
            
        .否则
            返回 (计数)
        .如果结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (0)

.子程序 查找出错, 逻辑型, , 
.参数 NO, 空白型, , 
.参数 INTO, 文本型, , 

返回 (真)


.子程序 G变量添加变量, 整数型, , 
.参数 变量名, 文本型, , 
.参数 变量类型, 整数型, , 
.参数 是否只读, 逻辑型, , 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.如果真 (大于 (G变量取变量索引 (变量名, 过程名称), 0))
    .如果 (等于 (G过程类实体.取过程是否保留变量 (过程名称), 假))
        异常 (0, 相加 (“变量重定义”, 变量名))
        返回 (0)
    .否则
        返回 (G变量取变量索引 (变量名, 过程名称))
    .如果结束
    
    
.如果真结束

赋值 (G变量数量, 相加 (G变量数量, 1))
重定义数组 (G变量集, 真, G变量数量)
赋值 (G变量集 [G变量数量], 名称, 变量名)
赋值 (G变量集 [G变量数量], 类型, 变量类型)
赋值 (G变量集 [G变量数量], 只读, 是否只读)
赋值 (G变量集 [G变量数量], 过程, 过程名称)
G变量集.赋值 ( [G变量数量], 值, 变量类型的默认值 (变量类型), )
 ' 输出调试文本 (“添加变量:” ＋ 变量名 ＋ “ 在过程:” ＋ 过程名称)

 ' .如果真 (等于 (变量名, “gy”))
     ' 暂停 ()
    
.如果真结束
返回 (G变量数量)


.子程序 G变量取值, 变体型, , 
.参数 索引, 空白型, , 



输出调试文本 (相加 (“取变量：”, G变量集.取文本 ( [索引], 值, )))
返回 (G变量集 [索引], 值)

.子程序 G变量赋值, 空白型, , 
.参数 索引, 空白型, , 
.参数 值, 变体型, , 
.参数 内置, 逻辑型, 可空, 

.如果真 (并且 (G变量集 [索引], 只读, 等于 (内置, 假)))
    异常 (2, “不能给常量赋值”)
    返回 ()
.如果真结束
赋值 (G变量集 [索引], 值, 值)
 ' 输出调试文本 (“给变量：” ＋ 值.取文本 ())


.子程序 G变量是否为数组, 逻辑型, , 从全局变量或局部变量中查找变量是否为数组
.参数 变量名, 文本型, , 
.参数 过程名称, 类变量集, 参考 可空, 

.局部变量 索引, 空白型, , , 

赋值 (索引, G数组取变量索引 (变量名))
.如果真 (大于 (索引, 0))
    返回 (真)
.如果真结束
赋值 (索引, 过程名称.数组取变量索引 (变量名))
.如果真 (大于 (索引, 0))
    返回 (真)
.如果真结束
返回 (假)




.子程序 G重设所有变量, 空白型, , 
.局部变量 l, 整数型, , , 


清除数组 (G数组变量集)
重定义数组 (G变量集, 真, G内置常量数量)

赋值 (G变量数量, 0)
赋值 (G数组变量数量, 0)
赋值 (G分析出错, 假)
赋值 (G分析出错文本, “”)




.子程序 是否为关键字, 逻辑型, , 
.参数 变量名, 文本型, , 
.参数 类型关键, 逻辑型, 可空, 

.局部变量 临时数组, 文本型, , "0", 
.局部变量 计数, 空白型, , , 

赋值 (变量名, 到小写 (变量名))

.如果真 (类型关键)
    .判断开始 (或者 (等于 (变量名, “int”), 等于 (变量名, “char”), 等于 (变量名, “long”), 等于 (变量名, “float”), 等于 (变量名, “bool”), 等于 (变量名, “短整型”), 等于 (变量名, “长整型”), 等于 (变量名, “字符型”), 等于 (变量名, “浮点型”), 等于 (变量名, “布尔型”)))
        返回 (真)
    .默认
        返回 (假)
    .判断结束
    
.如果真结束
赋值 (临时数组, 分割文本 (#关键字, “,”, ))
.计次循环首 (取数组成员数 (临时数组), 计数)
    .如果真 (等于 (到小写 (临时数组 [计数]), 变量名))
        返回 (真)
    .如果真结束
    
.计次循环尾 ()
返回 (假)


.子程序 变量名称到类型, 整数型, , 
.参数 字符串, 文本型, , 

赋值 (字符串, 到小写 (字符串))
.判断开始 (或者 (等于 (字符串, “int”), 等于 (字符串, “短整型”)))
    返回 (#短整型)
.判断 (或者 (等于 (字符串, “long”), 等于 (字符串, “长整型”)))
    返回 (#长整型)
.判断 (或者 (等于 (字符串, “float”), 等于 (字符串, “浮点型”)))
    返回 (#浮点型)
.判断 (或者 (等于 (字符串, “char”), 等于 (字符串, “字符型”)))
    返回 (#字符型)
.判断 (或者 (等于 (字符串, “bool”), 等于 (字符串, “布尔型”)))
    返回 (#布尔型)
.默认
    
.判断结束
返回 (#未知类型)


.子程序 添加全局常量, 空白型, , 
.局部变量 临时变量, 变体型, , , 


临时变量.赋值 (真, )
G变量添加变量 (“true”, #布尔型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“真”, #布尔型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (假, )
G变量添加变量 (“false”, #布尔型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“假”, #布尔型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#换行符, )
G变量添加变量 (“#crlf”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#换行符”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (字符 (9), )
G变量添加变量 (“#tab”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (字符 (13), )
G变量添加变量 (“#cr”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#回车”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (字符 (10), )
G变量添加变量 (“#lf”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#换行”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (字符 (32), )
G变量添加变量 (“#空格”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#space”, #字符型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#确认钮, )
G变量添加变量 (“#确认钮”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_ok”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#取消钮, )
G变量添加变量 (“#取消钮”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_cancel”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#是钮, )
G变量添加变量 (“#是钮”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_yes”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#否钮, )
G变量添加变量 (“#否钮”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_no”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#是否钮, )
G变量添加变量 (“#是否钮”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_yesno”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#信息图标, )
G变量添加变量 (“#信息图标”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_infomation”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#错误图标, )
G变量添加变量 (“#错误图标”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_critical”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#询问图标, )
G变量添加变量 (“#询问图标”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#mb_question”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#输入文本, )
G变量添加变量 (“#输入文本”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#in_text”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#输入整数, )
G变量添加变量 (“#输入整数”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#in_value”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#输入小数, )
G变量添加变量 (“#输入小数”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#in_float”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#输入密码, )
G变量添加变量 (“#输入密码”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
G变量添加变量 (“#in_password”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' 1、#年份； 2、#季度； 3、#月份； 4、#周； 5、#日； 6、#小时； 7、#分钟； 8、#秒
临时变量.赋值 (#年份, )
G变量添加变量 (“#年份”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#季度, )
G变量添加变量 (“#季度”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#月份, )
G变量添加变量 (“#月份”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#周, )
G变量添加变量 (“#周”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#日, )
G变量添加变量 (“#日”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#小时, )
G变量添加变量 (“#小时”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#分钟, )
G变量添加变量 (“#分钟”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#秒, )
G变量添加变量 (“#秒”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' 1、#全部转换； 2、#日期部分； 3、#时间部分
临时变量.赋值 (#全部转换, )
G变量添加变量 (“#全部转换”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#日期部分, )
G变量添加变量 (“#日期部分”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#时间部分, )
G变量添加变量 (“#时间部分”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' 1、#读入：从指定文件读入数据，如果该文件不存在则失败；
 ' 2、#写出：写出数据到指定文件，如果该文件不存在则失败；
 ' 3、#读写：从文件中读入数据或者写出数据到文件，如果该文件不存在则失败；
 ' 4、#重写：写出数据到指定文件。如果该文件不存在则先创建一个新文件，如果已经存在就先清除其中的所有数据；
 ' 5、#改写：写出数据到指定文件。如果该文件不存在则创建一个新文件，如果已经存在就直接打开；
 ' 6、#改读
临时变量.赋值 (#读入, )
G变量添加变量 (“#读入”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#写出, )
G变量添加变量 (“#写出”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#读写, )
G变量添加变量 (“#读写”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)


临时变量.赋值 (#重写, )
G变量添加变量 (“#重写”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)


临时变量.赋值 (#改写, )
G变量添加变量 (“#改写”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)


临时变量.赋值 (#改读, )
G变量添加变量 (“#改读”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' 1、#无限制：允许其它进程任意读写此文件；
 ' 2、#禁止读：禁止其它进程读此文件；
 ' 3、#禁止写：禁止其它进程写此文件；
 ' 4、#禁止读写：禁止其它进程读写此文件。


临时变量.赋值 (#无限制, )
G变量添加变量 (“#无限制”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)


临时变量.赋值 (#禁止读, )
G变量添加变量 (“#禁止读”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#禁止写, )
G变量添加变量 (“#禁止写”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

临时变量.赋值 (#禁止读写, )
G变量添加变量 (“#禁止读写”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' 1、#文件首； 2、#文件尾； 3、#现行位置
临时变量.赋值 (#文件首, )
G变量添加变量 (“#文件首”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#文件尾, )
G变量添加变量 (“#文件尾”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#现行位置, )
G变量添加变量 (“#现行位置”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' 1、#根类； 2、#现行设置； 3、#现行用户； 4、#本地机器； 5、#所有用户
临时变量.赋值 (#根类, )
G变量添加变量 (“#根类”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#现行设置, )
G变量添加变量 (“#现行设置”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#现行用户, )
G变量添加变量 (“#现行用户”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#本地机器, )
G变量添加变量 (“#本地机器”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#所有用户, )
G变量添加变量 (“#所有用户”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
 ' '''''''''''''''''''' 1、Windows 32S； 2、Windows 9X (包含Win95、Win98、WinME等)； 3、Windows NT (包含WinNT、Win2000、WinXP等)； 4、Linux。

 ' 1、GBK中文； 2、英文； 3、BIG5中文； 4、日文
临时变量.赋值 (#GBK中文, )
G变量添加变量 (“GBK中文”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#英文, )
G变量添加变量 (“#英文”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)
临时变量.赋值 (#BIG5中文, )
G变量添加变量 (“#BIG5中文”, #短整型, 真)
G变量赋值 (G变量数量, 临时变量, 真)

赋值 (G内置常量数量, G变量数量)

.程序集 工具集, , , 

.子程序 JoinArr, 文本型, , 
.参数 Arrs, 文本型, 参考 数组, 
.参数 Split, 文本型, 参考 可空, 

.局部变量 I, 空白型, , , 
.局部变量 结果, 文本型, , , 

.如果真 (是否为空 (Split))
    赋值 (Split, #换行符)
.如果真结束
.计次循环首 (取数组成员数 (Arrs), I)
    赋值 (结果, 相加 (结果, Arrs [I], 选择 (等于 (取数组成员数 (Arrs), I), “”, Split)))
.计次循环尾 ()

返回 (结果)


.子程序 ReadChar, 文本型, , 
.参数 Str1, 文本型, 参考, 

.局部变量 返回值, 文本型, , , 
.局部变量 数量, 空白型, , , 

 ' 取出一个字符
 ' 参数： Str1 处理的字符串
 ' 返回： 第一个字符
 ' Str1 成为被取后的字符串
.如果真 (等于 (Str1, “”))
    返回 (“”)
.如果真结束


赋值 (返回值, 取文本左边 (Str1, 1))
赋值 (数量, 2)

.如果真 (小于 (取代码 (返回值, ), 0))
    赋值 (返回值, 取文本左边 (Str1, 2))
    赋值 (数量, 3)
.如果真结束

赋值 (Str1, 取文本中间 (Str1, 数量, 相减 (取文本长度 (Str1), 1)))
返回 (返回值)

.子程序 RetChar, 文本型, , 
.参数 Str1, 文本型, 参考, 
.参数 AChar, 文本型, 参考, 

 ' 退回一个字符
 ' 参数： Str1 处理的字符串
 ' AChar 要退回的字符
 ' 返回： Str1 ：被退回的字符串
赋值 (Str1, 相加 (AChar, Str1))
返回 (Str1)


.子程序 ReadNumber, 文本型, , 
.参数 Str1, 文本型, 参考, 

.局部变量 rets, 文本型, , , 
.局部变量 C1, 文本型, , , 

 ' 读入数字
 ' 参数： Str1 处理的字符串
 ' 返回：  取到的数字， "" 为错误！
 ' Str1 ：处理后字符串
赋值 (C1, ReadChar (Str1))
.判断循环首 (不等于 (C1, “”))
    .如果 (或者 (并且 (大于或等于 (C1, “0”), 小于或等于 (C1, “9”)), 等于 (C1, “.”)))
        赋值 (rets, 相加 (rets, C1))
    .否则
        RetChar (Str1, C1)
        跳出循环 ()
    .如果结束
    赋值 (C1, ReadChar (Str1))
    
.判断循环尾 ()
返回 (rets)


.子程序 ReadString, 文本型, , 
.参数 Str1, 文本型, 参考, 

.局部变量 rets, 文本型, , , 
.局部变量 C1, 文本型, , , 

 ' 读入字符串
 ' 参数： Str1 处理的字符串
 ' 返回：  取到的字符串， "" 为错误！
 ' Str1 ：处理后字符串
赋值 (C1, ReadChar (Str1))
.判断循环首 (并且 (不等于 (C1, “”), 不等于 (C1, 字符 (34))))
    赋值 (rets, 相加 (rets, C1))
    赋值 (C1, ReadChar (Str1))
    
.判断循环尾 ()
 ' 信息框 (“ ReadString:” ＋ rets, 0, )
返回 (rets)


.子程序 是否操作符, 逻辑型, , 
.参数 StrExp, 文本型, , 
.参数 判断符, 整数型, 可空, 

.如果真 (或者 (等于 (StrExp, “+”), 等于 (StrExp, “-”), 等于 (StrExp, “*”), 等于 (StrExp, “\”), 等于 (StrExp, “/”), 等于 (StrExp, “&”), 等于 (StrExp, “^”), 等于 (StrExp, “=”), 等于 (StrExp, “<”), 等于 (StrExp, “>”), 等于 (StrExp, “%”)))
    .如果真 (小于或等于 (判断符, 0))
        返回 (真)
    .如果真结束
    返回 (或者 (等于 (StrExp, “=”), 等于 (StrExp, “>”), 等于 (StrExp, “<”)))
    
.如果真结束
返回 (假)

.子程序 异常, 空白型, , 
.参数 异常号, 整数型, , 
.参数 异常描述, 文本型, 可空, 


信息框 (异常描述, 相加 (0, #错误图标), 相加 (“[易用脚本引擎]”, #程序版本))
赋值 (G分析出错, 真)
赋值 (G分析出错文本, 异常描述)


.子程序 置双引号, 文本型, , 
.参数 字符串, 文本型, 参考, 
.参数 是否添加, 逻辑型, 可空, 

.局部变量 前置, 逻辑型, , , 
.局部变量 后置, 逻辑型, , , 

 ' 返回 (字符串)
.如果真 (等于 (取文本长度 (字符串), 0))
    返回 (“”)
.如果真结束
赋值 (前置, 等于 (取文本左边 (字符串, 1), 字符 (34)))
赋值 (后置, 等于 (取文本右边 (字符串, 1), 字符 (34)))
.如果真 (并且 (前置, 后置))
    .如果 (是否添加)
        返回 (字符串)
    .否则
        赋值 (字符串, 取文本中间 (字符串, 2, 取文本长度 (字符串)))
        赋值 (字符串, 取文本中间 (字符串, 1, 相减 (取文本长度 (字符串), 1)))
    .如果结束
    
    
.如果真结束
.如果真 (并且 (取反 (前置), 是否添加))
    赋值 (字符串, 相加 (字符 (34), 字符串))
.如果真结束
.如果真 (并且 (取反 (后置), 是否添加))
    赋值 (字符串, 相加 (字符串, 字符 (34)))
.如果真结束
返回 (字符串)


.子程序 子文本出现次数, 整数型, , 
.参数 原文, 文本型, , 
.参数 子文, 文本型, , 

.局部变量 计数量, 空白型, , , 
.局部变量 返回值, 空白型, , , 

.计次循环首 (取文本长度 (原文), 计数量)
    .如果真 (等于 (到小写 (取文本中间 (原文, 计数量, 取文本长度 (子文))), 到小写 (子文)))
        赋值 (返回值, 相加 (返回值, 1))
    .如果真结束
    
.计次循环尾 ()
返回 (返回值)

.子程序 GetProcInfo, 变体型, , 
.参数 lzStr, 文本型, , 
.参数 mOption, 空白型, , 
.参数 Data1, 变体型, 参考 可空, 
.参数 Data2, 变体型, 参考 可空, 

.局部变量 返回值, 变体型, , , 
.局部变量 临时1, 空白型, , , 
.局部变量 临时2, 空白型, , , 
.局部变量 临时字符串, 文本型, , , 

.判断开始 (等于 (mOption, 1))
    返回值.赋值 (寻找文本 (lzStr, “(”, , 假), )
.判断 (等于 (mOption, 2))
    返回值.赋值 (寻找文本 (lzStr, “)”, , 假), )
.判断 (等于 (mOption, 3))
    赋值 (临时1, GetProcInfo (lzStr, 1).取数值 ())
    赋值 (临时2, GetProcInfo (lzStr, 2).取数值 ())
    .如果真 (并且 (大于 (临时1, 0), 大于 (临时2, 0)))
        返回值.赋值 (取文本中间 (lzStr, 相加 (临时1, 1), 相减 (临时2, 临时1, 1)), )
    .如果真结束
    
.判断 (等于 (mOption, 4))
    赋值 (临时字符串, 删首尾空 (GetProcInfo (lzStr, 3).取文本 ()))
    .如果真 (等于 (取文本长度 (临时字符串), 0))
        返回值.赋值 (0, )
        返回 (返回值)
    .如果真结束
    
    返回值.赋值 (相加 (子文本出现次数 (lzStr, “,”), 1), )
    
.判断 (等于 (mOption, 5))
    返回值.赋值 (取文本中间 (lzStr, 相加 (Data1.取数值 (), 1), 相减 (Data2.取数值 (), Data1.取数值 (), 1)), )
.判断 (等于 (mOption, 6))
    返回值.赋值 (或者 (等于 (到小写 (Data1.取文本 ()), “function”), 等于 (到小写 (Data1.取文本 ()), “函数”)), )
.默认
    
.判断结束
返回 (返回值)


.子程序 DoEnum, 逻辑型, , 
.参数 mLine, 文本型, , 
.参数 过程, 类变量集, 参考 可空, 

.局部变量 vEnumList, 文本型, , "0", 
.局部变量 sTemp, 文本型, , , 
.局部变量 I, 空白型, , , 
.局部变量 ipos, 空白型, , , 
.局部变量 OldIndex, 空白型, , , 
.局部变量 临时变量, 变体型, , , 


赋值 (mLine, RemoveEol (mLine))
赋值 (sTemp, 删首尾空 (mLine))
赋值 (ipos, 寻找文本 (sTemp, “{”, , 假))
.如果真 (小于或等于 (ipos, 0))
    异常 (11, “期待 '{'”)
    返回 (假)
.如果真结束
.如果真 (不等于 (取文本右边 (sTemp, 1), “}”))
    异常 (11, “期待 '}'”)
    返回 (假)
.如果真结束
赋值 (sTemp, 取文本中间 (sTemp, 相加 (ipos, 1), 相减 (取文本长度 (sTemp), ipos, 1)))
赋值 (sTemp, 到小写 (子文本替换 (sTemp, “ ”, “”, , , 真)))
赋值 (ipos, 0)
赋值 (vEnumList, 分割文本 (sTemp, “,”, ))
.如果真 (等于 (取数组成员数 (vEnumList), 0))
    异常 (5, 相加 (“枚举为空”, mLine))
    返回 (假)
.如果真结束
.计次循环首 (取数组成员数 (vEnumList), I)
    赋值 (sTemp, 删首尾空 (vEnumList [I]))
    .如果真 (是否为关键字 (sTemp))
        异常 (5, 相加 (“关键字不能用作枚举:”, sTemp))
        清除数组 (vEnumList)
        赋值 (sTemp, “”)
        赋值 (ipos, 0)
        返回 (假)
    .如果真结束
    
    临时变量.赋值 (I, )
    .如果 (等于 (I, 1))
        
        .如果 (是否为空 (过程))
            G变量添加变量 (sTemp, #短整型, 真)
            G变量赋值 (G变量数量, 临时变量, 真)
        .否则
            过程.变量添加变量 (sTemp, #短整型, 真)
            过程.变量赋值 (过程.取数量 (), 临时变量, 真)
        .如果结束
        
        
    .否则
        临时变量.赋值 (相加 (ipos, 1), )
        .如果 (是否为空 (过程))
            G变量添加变量 (sTemp, #短整型, 真)
            G变量赋值 (G变量数量, 临时变量, 真)
            赋值 (临时变量, G变量取值 (G变量取变量索引 (sTemp)))
            
            
        .否则
            过程.变量添加变量 (sTemp, #短整型, 真)
            过程.变量赋值 (过程.取数量 (), 临时变量, 真)
            赋值 (临时变量, 过程.变量取值 (过程.变量取变量索引 (sTemp)))
        .如果结束
        赋值 (ipos, 临时变量.取数值 ())
        
        赋值 (sTemp, “”)
    .如果结束
    
.计次循环尾 ()
赋值 (OldIndex, 0)
赋值 (I, 0)
清除数组 (vEnumList)
返回 (真)


.子程序 EolPos, 整数型, , 
.参数 lzLine, 文本型, 参考, 

 ' 返回 (倒找文本 (, 取文本长度 (lzLine), 假, 假))
返回 (GetCharPos (lzLine, “;”))


.子程序 FixPath, 文本型, , 
.参数 lzPath, 文本型, 参考, 

.判断开始 (等于 (取文本右边 (lzPath, 1), “\”))
    返回 (lzPath)
.默认
    返回 (相加 (lzPath, “\”))
.判断结束


.子程序 GetCharPos, 整数型, , 
.参数 lpStr, 文本型, 参考, 
.参数 lpChar, 文本型, 参考, 

.局部变量 结果, 空白型, , , 
.局部变量 双引号位置, 空白型, , , 
.局部变量 旧位置, 空白型, , , 

.如果真 (小于或等于 (寻找文本 (lpStr, lpChar, , 假), 0))
    返回 (0)
.如果真结束

赋值 (旧位置, 寻找文本 (lpStr, 字符 (34), , 假))
赋值 (结果, 寻找文本 (lpStr, lpChar, , 假))
.如果真 (并且 (大于 (旧位置, 0), 大于 (结果, 0), 小于 (旧位置, 结果), 不等于 (lpChar, 字符 (34))))
    赋值 (双引号位置, 寻找文本 (lpStr, 字符 (34), 相加 (旧位置, 1), 假))
    .判断循环首 (并且 (大于 (结果, 旧位置), 小于 (结果, 双引号位置), 大于 (双引号位置, 0), 大于 (旧位置, 0)))
        赋值 (旧位置, 双引号位置)
        赋值 (结果, 寻找文本 (lpStr, lpChar, 相加 (结果, 1), 假))
        赋值 (旧位置, 寻找文本 (lpStr, 字符 (34), 相加 (旧位置, 1), 假))
        赋值 (双引号位置, 寻找文本 (lpStr, 字符 (34), 相加 (旧位置, 1), 假))
        
    .判断循环尾 ()
    
.如果真结束
返回 (结果)


.子程序 FixStr, 文本型, , 
.参数 lzBuff, 文本型, 参考, 

返回 (删首尾空 (取文本中间 (lzBuff, 相加 (GetCharPos (lzBuff, “(”), 1), 相减 (取文本长度 (lzBuff), GetCharPos (lzBuff, “(”), 1))))


.子程序 GetArrayInfo, 变体型, , 
.参数 lzStr, 文本型, 参考, 
.参数 ArrayOption, 空白型, , 为１返回数组名称，为２返回数组维数 ）

.局部变量 i_pos, 空白型, , , 
.局部变量 n_pos, 空白型, , , 
.局部变量 ArrySize, 空白型, , , *******
.局部变量 返回值, 变体型, , , 

赋值 (i_pos, GetCharPos (lzStr, “[”))
赋值 (n_pos, GetCharPos (lzStr, “]”))
.如果真 (或者 (等于 (i_pos, 0), 等于 (n_pos, 0)))
    返回值.赋值 (“”, )
    返回 (返回值)
.如果真结束
.判断开始 (等于 (ArrayOption, 1))
    返回值.赋值 (到小写 (删首尾空 (取文本中间 (lzStr, 1, 相减 (i_pos, 1)))), ) ' 返回数组名
.判断 (等于 (ArrayOption, 2)) ' 得到数组维数
    返回值.赋值 (删首尾空 (取文本中间 (lzStr, 相加 (i_pos, 1), 相减 (n_pos, i_pos, 1))), )
    .如果 (等于 (删首尾空 (返回值.取文本 ()), “”))
        返回值.赋值 (0, )
    .否则
        赋值 (返回值, G当前执行类模块.GetExp (返回值.取文本 ()))
    .如果结束
    
.默认
    
.判断结束
赋值 (i_pos, 0)
赋值 (n_pos, 0)

返回 (返回值)

.子程序 GetFromAssign, 文本型, , 
.参数 lzStr, 文本型, 参考, 
.参数 AssignPos, 空白型, 参考, 
.参数 nPostion, 空白型, 参考, 

.局部变量 返回值, 文本型, , , 

.如果真 (等于 (AssignPos, 0))
    返回 (“”)
.如果真结束
.如果 (等于 (nPostion, 0))
    赋值 (返回值, 到小写 (删首尾空 (取文本中间 (lzStr, 1, 相减 (AssignPos, 1)))))
.否则
    赋值 (返回值, 删首尾空 (取文本中间 (lzStr, 相加 (AssignPos, 1), )))
.如果结束
返回 (返回值)


.子程序 HasSqrBrackets, 逻辑型, , 
.参数 lzStr, 文本型, 参考, 

.局部变量 i_pos, 空白型, , , 
.局部变量 n_pos, 空白型, , , 

赋值 (i_pos, 寻找文本 (lzStr, “[”, , 假))
赋值 (n_pos, 寻找文本 (lzStr, “]”, , 假))
返回 (并且 (大于 (i_pos, 0), 大于 (n_pos, 0)))


.子程序 GetIncludeFiles, 文本型, , 
.参数 lzCode, 文本型, 参考, 

.局部变量 vCode, 文本型, , "0", 
.局部变量 I, 空白型, , , 
.局部变量 e_pos, 空白型, , , 
.局部变量 n_pos, 空白型, , , 
.局部变量 s_pos, 空白型, , , 
.局部变量 sline, 文本型, , , 
.局部变量 incFile, 文本型, , , 
.局部变量 AbsFile, 文本型, , , 
.局部变量 sBuff, 文本型, , , 
.局部变量 StrA, 文本型, , , 
.局部变量 IncludeFound, 逻辑型, , , 
.局部变量 返回值, 文本型, , , 

赋值 (incFile, “”)
.如果真 (等于 (取文本长度 (lzCode), 0))
    返回 (“”)
.如果真结束
赋值 (vCode, 分割文本 (lzCode, #换行符, ))
.计次循环首 (取数组成员数 (vCode), I)
    赋值 (sline, 删首尾空 (vCode [I]))
    赋值 (e_pos, 取绝对值 (到数值 (等于 (取文本左边 (sline, 1), “#”))))
    
    赋值 (n_pos, GetCharPos (sline, “ ”))
    
    .如果真 (并且 (大于 (e_pos, 0), 大于 (n_pos, 0)))
        赋值 (IncludeFound, 或者 (等于 (到大写 (取文本中间 (sline, 相加 (e_pos, 1), 相减 (n_pos, e_pos, 1))), “INCLUDE”), 等于 (到大写 (取文本中间 (sline, 相加 (e_pos, 1), 相减 (n_pos, e_pos, 1))), “包含”)))
    .如果真结束
    .如果真 (IncludeFound)
        赋值 (n_pos, GetCharPos (sline, “<”))
        赋值 (s_pos, GetCharPos (sline, “>”))
        .如果真 (并且 (大于 (n_pos, 0), 大于 (e_pos, 0)))
            赋值 (incFile, 删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 相减 (s_pos, n_pos, 1))))
            .如果 (大于 (寻找文本 (incFile, “\”, , 假), 0))
                赋值 (AbsFile, incFile)
            .否则
                赋值 (AbsFile, 相加 (FixPath (取运行目录 ()), “Include\”, incFile))
                
            .如果结束
            .如果真 (等于 (文件是否存在 (AbsFile), 假))
                异常 (3, 相加 (“文件:”, AbsFile, “ 找不到”))
                返回 (“”)
            .如果真结束
            赋值 (sBuff, 到文本 (读入文件 (AbsFile)))
            赋值 (StrA, 相加 (StrA, sBuff, #换行符))
            赋值 (AbsFile, “”)
            赋值 (e_pos, 0)
            赋值 (n_pos, 0)
            赋值 (s_pos, 0)
            赋值 (incFile, “”)
            赋值 (lzCode, 子文本替换 (lzCode, sline, “”, , , 真))
            
        .如果真结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (StrA)


.子程序 GetIndexFromStr, 文本型, , 取出字符串前面的所有数字
.参数 lzStr, 文本型, , 

.局部变量 c, 文本型, , , 
.局部变量 StrNum, 文本型, , , 
.局部变量 i, 文本型, , , 


.计次循环首 (取文本长度 (lzStr), i)
    赋值 (c, 取文本中间 (lzStr, i, 1))
    .如果 (是否为数字 (c))
        赋值 (StrNum, 相加 (StrNum, c))
    .否则
        跳出循环 ()
    .如果结束
    
.计次循环尾 ()
返回 (StrNum)


.子程序 是否为数字, 逻辑型, , 
.参数 sChar, 文本型, , 

.局部变量 I, 空白型, , , 
.局部变量 t, 文本型, , , 

 ' .如果真 (等于 (取文本左边 (sChar, 1), “-”))
     ' sChar ＝ 取文本右边 (sChar, 取文本长度 (sChar) － 1)
    
.如果真结束
 ' 输出调试文本 (“验证:” ＋ sChar ＋ “ 长度: ” ＋ 到文本 (取文本长度 (sChar)))

.计次循环首 (取文本长度 (sChar), I)
    赋值 (t, 取文本中间 (sChar, I, 1))
     ' 输出调试文本 (“代码:” ＋ 到文本 (取代码 (t, )))
    
    .如果真 (等于 (t, “”))
        跳出循环 ()
    .如果真结束
    .如果真 (或者 (小于 (取代码 (t, ), 48), 大于 (取代码 (t, ), 57)))
        .如果真 (并且 (大于 (I, 1), 不等于 (取代码 (t, ), 取代码 (“.”, ))))
             ' 输出调试文本 (“不是数字:” ＋ t)
            
            返回 (假)
        .如果真结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (真)


.子程序 RemoveBlanks, 文本型, , 去掉所有前导空白和尾随注释
.参数 StrA, 文本型, , 
.参数 OK, 空白型, 参考 可空, 

.局部变量 StrB, 文本型, , , 
.局部变量 l, 空白型, , , 
.局部变量 B, 空白型, , , 

赋值 (StrB, RemoveSingleLineComment (StrA))

.判断循环首 (小于或等于 (B, 取文本长度 (StrB)))
    赋值 (B, 相加 (B, 1))
    .如果 (或者 (等于 (取文本中间 (StrB, B, 1), 字符 (32)), 等于 (取文本中间 (StrB, B, 1), 字符 (8)), 等于 (取文本中间 (StrB, B, 1), 字符 (9)), 等于 (取文本中间 (StrB, B, 1), 字符 (10)), 等于 (取文本中间 (StrB, B, 1), 字符 (13))))
        赋值 (l, 相加 (l, 1))
    .否则
        跳出循环 ()
    .如果结束
    
.判断循环尾 ()

.如果真 (大于 (l, 0))
    赋值 (StrB, 取文本右边 (StrB, 相减 (取文本长度 (StrB), l)))
.如果真结束
返回 (StrB)


.子程序 ISBlank, 逻辑型, , 测试字符是否　是空白字符
.参数 StrB, 文本型, 参考, 

 ' 输出调试文本 (取代码 (取文本左边 (StrB, 1), ))

.如果真 (或者 (等于 (取文本左边 (StrB, 1), “ ”), 等于 (取文本左边 (StrB, 1), 字符 (8)), 等于 (取文本左边 (StrB, 1), 字符 (9)), 等于 (取文本左边 (StrB, 1), 字符 (10)), 等于 (取文本左边 (StrB, 1), 字符 (13)), 等于 (取文本左边 (StrB, 1), “　”), 等于 (取代码 (取文本左边 (StrB, 1), ), -95)))
    
    返回 (真)
.如果真结束
返回 (假)


.子程序 RemoveEol, 文本型, , 
.参数 lzLine, 文本型, , 

.如果真 (等于 (取文本右边 (lzLine, 1), “;”))
    赋值 (lzLine, 取文本左边 (lzLine, 相减 (取文本长度 (lzLine), 1)))
.如果真结束
返回 (lzLine)


.子程序 RemoveCrlf, 文本型, , 
.参数 StrA, 文本型, , 

.局部变量 StrB, 文本型, , , 

赋值 (StrB, StrA)
.如果真 (等于 (取文本右边 (StrB, 2), #换行符))
    赋值 (StrB, 取文本左边 (StrB, 相减 (取文本长度 (StrB), 2)))
.如果真结束
.如果真 (等于 (取文本左边 (StrB, 2), #换行符))
    赋值 (StrB, 取文本右边 (StrB, 相减 (取文本长度 (StrB), 2)))
.如果真结束
返回 (StrB)


.子程序 StrRemoveLeft, 文本型, , 
.参数 lzStr, 文本型, 参考, 
.参数 iPlaces, 空白型, , 

.如果真 (小于或等于 (取文本长度 (lzStr), iPlaces))
    返回 (“”)
.如果真结束
返回 (取文本右边 (lzStr, 相减 (取文本长度 (lzStr), iPlaces)))


.子程序 RemoveSingleLineComment, 文本型, , 
.参数 StrLine, 文本型, , 

.局部变量 注释位置, 空白型, , , 
.局部变量 双引号位置, 空白型, , , 
.局部变量 是否字符串, 空白型, , , 
.局部变量 I, 空白型, , , 
.局部变量 s, 文本型, , , 

赋值 (注释位置, 倒找文本 (StrLine, “//”, , 假)) ' 找到最后个 //
赋值 (双引号位置, 倒找文本 (StrLine, 字符 (34), , 假)) ' 判断是否字符串
.如果 (大于 (注释位置, 双引号位置))
    赋值 (StrLine, 取文本左边 (StrLine, 相减 (注释位置, 1)))
    返回 (StrLine)
    
.否则
    
.如果结束

返回 (StrLine)


.子程序 TidyLine, 文本型, , 
.参数 lpStrLine, 文本型, 参考, 

.局部变量 StrA, 文本型, , , 

赋值 (StrA, 删首尾空 (lpStrLine))

赋值 (StrA, RemoveSingleLineComment (StrA))
赋值 (StrA, RemoveEol (StrA))
返回 (StrA)


.子程序 GetKeyWord, 整数型, , 
.参数 lzLine, 文本型, 参考, 
.参数 是否函数, 逻辑型, 可空, 

.局部变量 I, 空白型, , , 
.局部变量 临时字符, 空白型, , , 

.计次循环首 (取文本长度 (lzLine), I)
    赋值 (临时字符, 取代码 (取文本中间 (lzLine, I, 1), ))
    .如果 (是否函数)
        .如果真 (或者 (等于 (临时字符, 32), 等于 (临时字符, #Tab键), 等于 (临时字符, 取代码 (“　”, ))))
            跳出循环 ()
        .如果真结束
        
    .否则
        .如果真 (或者 (等于 (临时字符, 取代码 (“(”, )), 等于 (临时字符, #空格键), 等于 (临时字符, -95), 等于 (临时字符, #Tab键), 等于 (临时字符, 取代码 (“:”, ))))
            跳出循环 ()
        .如果真结束
        
    .如果结束
    
.计次循环尾 ()

.如果 (并且 (小于 (I, 取文本长度 (lzLine)), 不等于 (I, 1)))
    返回 (I)
.否则
    返回 (0)
.如果结束


.类模块 过程类, , , 

.程序集变量 G过程集, 过程集类型, , "0", 保存所有的用户定义函数和过程
.程序集变量 G变量堆, 类变量集, , "0", 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
重定义数组 (G过程集, 假, 0)
赋值 (G过程数量, 0)


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
重定义数组 (G过程集, 假, 0)
赋值 (G过程数量, 0)


.子程序 置变量堆, 空白型, 公开, 
.参数 过程索引, 空白型, , 
.参数 变量堆, 类变量集, 参考, 

赋值 (G变量堆 [过程索引], 变量堆)


.子程序 取变量堆, 类变量集, 公开, 
.参数 过程索引, 空白型, , 

返回 (G变量堆 [过程索引])


.子程序 添加过程, 空白型, 公开, 
.参数 过程名称, 文本型, , 
.参数 参数数量, 整数型, , 
.参数 可否返回, 逻辑型, , 
.参数 变量列表, 文本型, 参考, 

.如果真 (大于 (过程取索引 (过程名称), 0))
    异常 (2, 相加 (“重复定义过程:”, 过程名称))
    返回 ()
.如果真结束
赋值 (G过程数量, 相加 (G过程数量, 1))
重定义数组 (G过程集, 真, G过程数量)
赋值 (G过程集 [G过程数量], 名称, 到小写 (过程名称))
赋值 (G过程集 [G过程数量], 参数数量, 参数数量)
赋值 (G过程集 [G过程数量], 是否具有返回值, 可否返回)
赋值 (G过程集 [G过程数量], 变量列表, 变量列表)


.子程序 过程取索引, 整数型, 公开, 
.参数 过程名称, 文本型, , 

.局部变量 计数, 空白型, , , 

.如果真 (小于或等于 (G过程数量, 0))
    返回 (0)
.如果真结束
.计次循环首 (G过程数量, 计数)
    .如果真 (等于 (到小写 (G过程集 [计数], 名称), 到小写 (过程名称)))
        返回 (计数)
    .如果真结束
    
.计次循环尾 ()
返回 (0)


.子程序 清除所有过程, 空白型, 公开, 
清除数组 (G过程集)
赋值 (G过程数量, 0)


.子程序 过程置代码, 空白型, 公开, 
.参数 索引, 空白型, , 
.参数 代码内容, 文本型, , 

赋值 (G过程集 [索引], 代码段, 代码内容)
 ' 输出调试文本 (“置过程” ＋ 到文本 (索引) ＋ “:” ＋ 代码内容)


.子程序 置过程是否保留变量, 空白型, 公开, 
.参数 过程名, 文本型, , 
.参数 是否保留, 逻辑型, 可空, 

.局部变量 索引, 空白型, , , 

赋值 (索引, 过程取索引 (过程名))
.如果真 (小于或等于 (索引, 0))
    返回 ()
.如果真结束
赋值 (G过程集 [索引], 是否具有返回值, 是否保留)


.子程序 取过程是否保留变量, 逻辑型, 公开, 
.参数 过程名, 文本型, , 

.局部变量 索引, 空白型, , , 

赋值 (索引, 过程取索引 (过程名))
.如果真 (小于或等于 (索引, 0))
    返回 (假)
.如果真结束
返回 (G过程集 [索引], 是否具有返回值)


.子程序 过程取参数量, 整数型, 公开, 
.参数 过程名称, 文本型, , 

.局部变量 索引, 空白型, , , 

赋值 (索引, 过程取索引 (过程名称))
.如果真 (小于或等于 (索引, 0))
    返回 (0)
.如果真结束
返回 (G过程集 [索引], 参数数量)


.子程序 过程取变量列表, 文本型, 公开, 
.参数 过程名称, 文本型, , 

.局部变量 索引, 空白型, , , 

赋值 (索引, 过程取索引 (过程名称))
.如果真 (小于或等于 (索引, 0))
    返回 (“”)
.如果真结束
返回 (G过程集 [索引], 变量列表)


.子程序 过程取代码段, 文本型, 公开, 
.参数 过程名称, 文本型, , 

.局部变量 索引, 空白型, , , 

赋值 (索引, 过程取索引 (过程名称))
.如果真 (小于或等于 (索引, 0))
    返回 (“”)
.如果真结束
返回 (G过程集 [索引], 代码段)


.子程序 过程取代码段1, 文本型, 公开, 
.参数 索引, 空白型, , 


.如果真 (小于或等于 (索引, 0))
    返回 (“”)
.如果真结束
返回 (G过程集 [索引], 代码段)


.子程序 过程取名称, 文本型, 公开, 
.参数 索引, 空白型, , 

.如果真 (小于或等于 (索引, 0))
    返回 (“”)
.如果真结束
返回 (G过程集 [索引], 名称)


.程序集 可执行程序集, , , 

.子程序 添加并执行代码, 整数型, 公开, 添加代码到引擎中，可选择是否立即执行
.参数 nCode, 文本型, , 代码内容（包含所有要执行的代码）
.参数 是否执行, 逻辑型, 可空, 是否立即执行,默认为立即执行(可置为假,然后调用 计算表达式() 或 执行代码段() 函数来启动任意过程)

.局部变量 s_main, 文本型, , , 
.局部变量 dm_ScriptSrc, 文本型, , , 
.局部变量 IncStr, 文本型, , , 
.局部变量 sTemp, 文本型, , , 
.局部变量 表达式计算器, 类执行模块, , , 
.局部变量 I, 空白型, , , 


赋值 (dm_ScriptSrc, nCode)
赋值 (dm_ScriptSrc, 子文本替换 (dm_ScriptSrc, 相加 (“_”, #换行符), “ ”, , , 真))
赋值 (IncStr, GetIncludeFiles (dm_ScriptSrc))
赋值 (sTemp, dm_ScriptSrc)
赋值 (dm_ScriptSrc, 相加 (IncStr, sTemp))
赋值 (sTemp, “”) ' Clean up
LoadProcedure (dm_ScriptSrc) ' Load all the Procedures
赋值 (dm_ScriptSrc, “”) ' Clean



.如果真 (是否为空 (是否执行))
    赋值 (是否执行, 真)
.如果真结束

.如果真 (等于 (是否执行, 假))
    返回 (0)
.如果真结束


继续执行 ()

赋值 (I, G过程类实体.过程取索引 (“main”))
.如果真 (小于或等于 (I, 0))
    赋值 (I, G过程类实体.过程取索引 (“启动过程”))
.如果真结束
.如果真 (小于或等于 (I, 0))
    信息框 (相加 (“没有启动过程 ”, #换行符, “你需要一个名为　'启动过程' 的过程或函数”), 0, “易用脚本”)
    返回 (0)
.如果真结束
赋值 (s_main, G过程类实体.过程取代码段1 (I))
赋值 (G当前执行类模块, 表达式计算器)

G当前执行类模块.执行代码段 (s_main, G过程类实体.过程取名称 (I))
.如果真 (G分析出错)
    返回 (0)
.如果真结束
返回 (1)


.子程序 LoadProcedure, 空白型, , 
.参数 s_ScriptCode, 文本型, 参考, 

.局部变量 v, 文本型, , "0", 
.局部变量 ProcVars, 文本型, , "0", 
.局部变量 cLine, 文本型, , , 
.局部变量 sTemp, 文本型, , , 
.局部变量 sTempB, 文本型, , , 
.局部变量 ProcNameType, 文本型, , , 
.局部变量 sProcName, 文本型, , , 
.局部变量 sBuffer, 文本型, , , 
.局部变量 lVariableName, 文本型, , , 
.局部变量 lVariableType, 文本型, , , 
.局部变量 e_pos, 空白型, , , 
.局部变量 OpenB, 逻辑型, , , 
.局部变量 CloseB, 逻辑型, , , 
.局部变量 bOK, 空白型, , , 
.局部变量 X, 空白型, , , 
.局部变量 I, 空白型, , , 
.局部变量 Start, 逻辑型, , , 
.局部变量 参数数量, 空白型, , , 
.局部变量 有返回值, 逻辑型, , , 
.局部变量 变量列表, 文本型, , , 
.局部变量 临时变量, 变体型, , , 
.局部变量 过程开始, 逻辑型, , , 是否全局变量
.局部变量 TheToken, 文本型, , , 
.局部变量 lVariableData, 变体型, , , 

赋值 (v, 分割文本 (s_ScriptCode, #换行符, ))
.计次循环首 (取数组成员数 (v), I)
    赋值 (cLine, 删首尾空 (v [I]))
    赋值 (cLine, RemoveBlanks (cLine))
    赋值 (e_pos, GetKeyWord (cLine, 真))
    
    赋值 (ProcNameType, 到小写 (删首尾空 (取文本中间 (cLine, 1, e_pos))))
    .如果真 (或者 (等于 (ProcNameType, “type”), 等于 (ProcNameType, “类型”)))
        赋值 (cLine, 相加 (cLine, “()”))
    .如果真结束
    .如果真 (或者 (等于 (ProcNameType, “function”), 等于 (ProcNameType, “sub”), 等于 (ProcNameType, “函数”), 等于 (ProcNameType, “过程”)))
        .如果真 (等于 (GetProcInfo (cLine, 1).取数值 (), 0))
            异常 (1, “期待 '('”)
            跳出循环 ()
        .如果真结束
        .如果真 (等于 (GetProcInfo (cLine, 2).取数值 (), 0))
            异常 (1, “期待 ')'”)
            跳出循环 ()
        .如果真结束
        临时变量.赋值 (e_pos, )
        赋值 (sProcName, GetProcInfo (cLine, 5, 临时变量, GetProcInfo (cLine, 1)).取文本 ())
        .如果真 (等于 (取文本长度 (sProcName), 0))
            异常 (1, “期待 函数或过程名”)
            跳出循环 ()
        .如果真结束
        赋值 (参数数量, GetProcInfo (cLine, 4).取数值 ())
        赋值 (有返回值, GetProcInfo (“”, 6, 临时变量).取逻辑值 ())
        赋值 (变量列表, GetProcInfo (cLine, 3).取文本 ())
        
        .如果真 (不等于 (参数数量, 0))
            赋值 (ProcVars, 分割文本 (GetProcInfo (cLine, 3).取文本 (), “,”, ))
            .计次循环首 (取数组成员数 (ProcVars), X)
                赋值 (sTempB, 删首尾空 (ProcVars [X]))
                赋值 (e_pos, GetCharPos (sTempB, “ ”))
                .如果真 (小于或等于 (e_pos, 0))
                    异常 (7, “”)
                    跳出循环 ()
                .如果真结束
                赋值 (lVariableName, 到小写 (取文本中间 (sTempB, 相加 (e_pos, 1), 取文本长度 (sTempB))))
                赋值 (lVariableType, 到小写 (取文本中间 (sTempB, 1, 相减 (e_pos, 1))))
                 ' 变量添加变量 (lVariableName, 变量名称到类型 (lVariableType), 假, sProcName)
                
            .计次循环尾 ()
            
        .如果真结束
        临时变量.赋值 (ProcNameType, )
        G过程类实体.添加过程 (sProcName, 参数数量, 有返回值, 变量列表)
        赋值 (Start, 真)
        赋值 (过程开始, 真)
    .如果真结束
    
    .如果真 (等于 (过程开始, 假)) ' =========================检查全局变量,全局变量必须定义在所有过程的前面
        赋值 (e_pos, GetKeyWord (cLine))
        .如果真 (大于 (e_pos, 0))
            赋值 (TheToken, 取文本左边 (cLine, 相减 (e_pos, 1)))
            
            .判断开始 (或者 (等于 (TheToken, “int”), 等于 (TheToken, “char”), 等于 (TheToken, “long”), 等于 (TheToken, “float”), 等于 (TheToken, “bool”), 等于 (TheToken, “短整型”), 等于 (TheToken, “长整型”), 等于 (TheToken, “字符型”), 等于 (TheToken, “浮点型”), 等于 (TheToken, “布尔型”)))
                
                .如果真 (等于 (EolPos (cLine), 0))
                    异常 (5, 相加 (“期待结束符 ';'”, cLine))
                    返回 ()
                .如果真结束
                赋值 (cLine, TidyLine (cLine))
                .如果 (G分析声明语句 (cLine, e_pos))
                    
                .否则
                    返回 ()
                .如果结束
                
            .默认
                
            .判断结束
            
            .判断开始 (或者 (等于 (TheToken, “enum”), 等于 (TheToken, “枚举”)))
                .如果真 (等于 (EolPos (cLine), 0))
                    异常 (5, “期待';'”)
                    跳出循环 ()
                .如果真结束
                赋值 (cLine, 删首尾空 (取文本右边 (cLine, 相减 (取文本长度 (cLine), 取文本长度 (TheToken)))))
                .如果真 (等于 (DoEnum (cLine), 假))
                    跳出循环 ()
                .如果真结束
                到循环尾 ()
            .默认
                
            .判断结束
            
            .判断开始 (或者 (等于 (TheToken, “const”), 等于 (TheToken, “常量”)))
                赋值 (X, EolPos (cLine))
                
                .如果真 (等于 (X, 0))
                    异常 (5, “期待结束符 ';'”)
                    返回 ()
                .如果真结束
                赋值 (cLine, 删首尾空 (取文本右边 (cLine, 相减 (取文本长度 (cLine), 取文本长度 (TheToken)))))
                赋值 (e_pos, GetCharPos (cLine, “=”))
                .如果真 (小于或等于 (e_pos, 0))
                    异常 (1, “常量必须在定义时赋值”)
                    返回 ()
                .如果真结束
                赋值 (lVariableName, 删首尾空 (取文本中间 (cLine, 1, 相减 (e_pos, 1))))
                赋值 (cLine, 删首尾空 (取文本中间 (cLine, 相加 (e_pos, 1), 相减 (X, e_pos, 1))))
                
                赋值 (lVariableData, G当前执行类模块.GetExp (cLine))
                
                .如果真 (是否为关键字 (lVariableName))
                    异常 (8, “关键字不能用作标识符”)
                    返回 ()
                .如果真结束
                G变量添加变量 (lVariableName, #字符型, 真)
                G变量赋值 (G变量数量, lVariableData, 真)
                赋值 (lVariableName, “”)
                lVariableData.清除 ()
                赋值 (e_pos, 0)
                赋值 (cLine, “”)
                到循环尾 ()
            .默认
                
            .判断结束
             ' -===============================================================================
        .如果真结束
        
    .如果真结束
    
    .如果真 (Start)
        赋值 (OpenB, 等于 (取文本左边 (cLine, 1), “{”))
        
    .如果真结束
    .如果真 (OpenB)
        赋值 (bOK, 1)
    .如果真结束
    .如果真 (CloseB)
        赋值 (bOK, 0)
    .如果真结束
    .如果真 (不等于 (bOK, 0))
        赋值 (sBuffer, 相加 (sBuffer, 删首空 (cLine), #换行符))
    .如果真结束
    赋值 (CloseB, 等于 (取文本右边 (cLine, 1), “}”))
    .如果真 (CloseB)
        赋值 (sBuffer, RemoveCrlf (sBuffer))
        .如果真 (不等于 (取文本左边 (sBuffer, 1), “{”))
            异常 (1, “期待'{'”)
            跳出循环 ()
        .如果真结束
        赋值 (sBuffer, 取文本右边 (sBuffer, 相减 (取文本长度 (sBuffer), 1)))
        赋值 (sBuffer, 取文本左边 (sBuffer, 相减 (取文本长度 (sBuffer), 1)))
        赋值 (sBuffer, RemoveCrlf (sBuffer))
        G过程类实体.过程置代码 (G过程数量, sBuffer)
        赋值 (sBuffer, “”)
        赋值 (Start, 假)
        赋值 (过程开始, 假)
    .如果真结束
    
.计次循环尾 ()
清除数组 (v)
清除数组 (ProcVars)
赋值 (cLine, “”)
赋值 (sTemp, “”)
赋值 (sTempB, “”)
赋值 (ProcNameType, “”)

赋值 (sProcName, “”)
赋值 (lVariableName, “”)
赋值 (lVariableType, “”)

.子程序 执行代码段, 空白型, 公开, 执行代码段,不返回结果
.参数 代码内容, 文本型, , 

继续执行 ()
G当前执行类模块.执行代码段 (代码内容)


.子程序 计算表达式, 文本型, 公开, 执行表达式,并返回结果
.参数 表达式, 文本型, , 

继续执行 ()
返回 (G当前执行类模块.GetExp (表达式).取文本 ())


.子程序 注册外部函数, 逻辑型, 公开, 添加外部函数的注册信息,注册后,可以和使用用户函数一样的在脚本内使用
.参数 函数名, 文本型, , 随意填写,指在脚本代码中所调用时使用的函数名
.参数 函数地址, 空白型, , 实际值为一个子程序指针.请用 到数值() 函数转换为整数型

返回 (G外部过程类.添加注册函数 (函数名, 函数地址))


.子程序 重置所有, 空白型, 公开, 清除所有外部注册函数和用户代码
G外部过程类.清除所有注册 ()
G过程类实体.清除所有过程 ()
G重设所有变量 ()
继续执行 ()

.子程序 引擎初始化, 空白型, 公开, 将脚本引擎初始化到开始状态
重置所有 ()
启动 ()
继续执行 ()

 ' GDump (真)
 ' 信息框 (“引擎初始化:” ＋ 到文本 (G内置常量数量), 0, )

.子程序 取堆栈信息, 文本型, 公开, 取得当前脚本引擎内的所有用户变量的值
.如果 (等于 (GRegNum, 20))
    返回 (“易用脚本引擎未注册．”)
.否则
    返回 (G当前执行类模块.取变量堆 ().Dump ())
.如果结束


.子程序 置注册码, 空白型, , 添加易用脚本的注册信息，注册成功可解除外部注册函数数量的限制
.参数 注册码, 文本型, , 

.局部变量 HD, 空白型, , , 
.局部变量 A, 文本型, , , 
.局部变量 Temp, 文本型, , , 
.局部变量 I, 空白型, , , 
.局部变量 b, 文本型, , , 

.如果真 (不等于 (取文本长度 (注册码), 10))
    返回 ()
.如果真结束
赋值 (HD, 取硬盘特征字 ())
.如果真 (小于或等于 (HD, 0))
    异常 (1, “置注册码时发生错误！”)
    结束 ()
.如果真结束
赋值 (Temp, “2007-02-21”)

.计次循环首 (取文本长度 (Temp), I)
    赋值 (A, 相加 (A, 到文本 (位或 (HD, 到数值 (取文本中间 (Temp, I, 1))))))
.计次循环尾 ()
 ' 输出调试文本 (A)
赋值 (b, A)

赋值 (A, 到文本 (位或 (到数值 (取文本中间 (A, 10, 10)), HD)))

 ' 输出调试文本 (A ＋ b)
.如果 (不等于 (A, 注册码))
    返回 ()
.否则
    赋值 (GRegNum, -1) ' 小于０
.如果结束




.子程序 暂停执行, 空白型, 公开, 暂停当前脚本引擎的执行,用于检查堆栈信息
G当前执行类模块.置状态 (1)


.子程序 继续执行, 空白型, 公开, 对应 暂停执行() 后所使用的继续
.如果真 (小于或等于 (G内置常量数量, 0))
    引擎初始化 ()
.如果真结束
G当前执行类模块.置状态 (0)


.子程序 停止执行, 空白型, 公开, 停止当前脚本的执行
G当前执行类模块.置状态 (2)















.子程序 DLL添加并执行代码, 整数型, 公开, 添加代码到引擎中，可选择是否立即执行
.参数 nCode, 空白型, , 代码内容（包含所有要执行的代码）
.参数 是否执行, 空白型, , 是否立即执行,默认为立即执行(可置为假,然后调用 计算表达式() 或 执行代码段() 函数来启动任意过程)

.局部变量 代码内容, 文本型, , , 

赋值 (代码内容, 指针到文本 (nCode))
 ' 信息框 (代码内容, 0, )

返回 (添加并执行代码 (代码内容, 选择 (等于 (是否执行, 0), 假, 真)))


.子程序 DLL执行代码段, 空白型, 公开, 执行代码段,不返回结果
.参数 代码内容, 空白型, , 

.局部变量 代码内容S, 文本型, , , 

赋值 (代码内容S, 指针到文本 (代码内容))
继续执行 ()
G当前执行类模块.执行代码段 (代码内容S)

.子程序 DLL注册外部函数, 逻辑型, 公开, 添加外部函数的注册信息,注册后,可以和使用用户函数一样的在脚本内使用
.参数 函数名, 空白型, , 随意填写,指在脚本代码中所调用时使用的函数名
.参数 函数地址, 空白型, , 实际值为一个子程序指针.请用 到数值() 函数转换为整数型

.局部变量 函数名S, 文本型, , , 

赋值 (函数名S, 指针到文本 (函数名))

返回 (G外部过程类.添加注册函数 (函数名S, 函数地址))

.子程序 DLL置注册码, 空白型, 公开, 添加易用脚本的注册信息，注册成功可解除外部注册函数数量的限制
.参数 注册码, 空白型, , 

.局部变量 S, 文本型, , , 

赋值 (S, 指针到文本 (注册码))
置注册码 (S)


.子程序 DLL计算表达式, 空白型, 公开, 执行表达式,并返回结果
.参数 表达式, 空白型, , 
.参数 结果存放处, 空白型, , 
.参数 结果长度, 空白型, , 

.局部变量 S, 文本型, , , 

继续执行 ()
赋值 (S, 指针到文本 (表达式))
赋值 (S, 计算表达式 (S))
写到内存 (S, 结果存放处, 结果长度)


.类模块 外部注册函数类, , , 

.程序集变量 函数名, 文本型, , "0", 
.程序集变量 函数地址, 空白型, , "0", 
.程序集变量 函数数量, 整数型, , , 
.程序集变量 调用结果, 逻辑型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
清除数组 (函数名)
清除数组 (函数地址)
赋值 (函数数量, 0)

.子程序 添加注册函数, 逻辑型, 公开, 
.参数 名称, 文本型, , 
.参数 地址, 空白型, , 

.如果真 (大于 (外部函数取索引 (名称), 0))
    异常 (3, 相加 (“注册的函数有重复:”, 名称))
    返回 (假)
.如果真结束

.如果真 (并且 (大于 (函数数量, GRegNum), 大于 (GRegNum, 0))) ' 注册数量的限制
    返回 (假)
.如果真结束

赋值 (函数数量, 相加 (函数数量, 1))
重定义数组 (函数名, 真, 函数数量)
重定义数组 (函数地址, 真, 函数数量)
赋值 (函数名 [函数数量], 到小写 (名称))
赋值 (函数地址 [函数数量], 地址)
返回 (真)


.子程序 清除所有注册, 空白型, 公开, 

清除数组 (函数名)
清除数组 (函数地址)
赋值 (函数数量, 0)


.子程序 外部函数取索引, 整数型, 公开, 
.参数 名称, 文本型, , 

.局部变量 I, 空白型, , , 

.如果真 (小于或等于 (函数数量, 0))
    返回 (函数数量)
.如果真结束
.计次循环首 (取数组成员数 (函数名), I)
    .如果真 (等于 (到小写 (名称), 到小写 (函数名 [I])))
        返回 (I)
    .如果真结束
    
.计次循环尾 ()
返回 (0)



.子程序 是否调用OK, 逻辑型, 公开, 
返回 (调用结果)


.子程序 注册函数调用, 文本型, 公开, 
.参数 索引, 空白型, 参考, 
.参数 vInfo, 文本型, 参考 数组, 

.局部变量 代码, 字节集, , , 
.局部变量 函数址, 空白型, , , 
.局部变量 I, 空白型, , , 
.局部变量 返回值, 文本型, , , 
.局部变量 J, 空白型, , , 
.局部变量 临时变量, 文本型, , , 
.局部变量 参数, 文本型, , "0", 
.局部变量 zz, 空白型, , , 

赋值 (I, 索引)
.如果真 (小于或等于 (I, 0))
    赋值 (调用结果, 假)
    返回 (“”)
    
.如果真结束
赋值 (函数址, 函数地址 [I])
赋值 (调用结果, 真)
置代码 ({  })

赋值 (I, 取数组成员数 (vInfo))

.如果真 (大于 (I, 0))
    重定义数组 (参数, 真, I)
    .变量循环首 (I, 1, -1, J) ' 从尾将参数压入堆栈
        赋值 (参数 [J], vInfo [J])
        赋值 (zz, 取文本型变量指针 (参数 [J]))
         ' 信息框 (到文本 (J) ＋ “  ” ＋ 到文本 (zz), 0, )
        push_常数 (zz)
    .变量循环尾 ()
    
.如果真结束

mov_eax_ptr (取整数型变量指针 (函数址))
call_eax ()
ret ()


赋值 (代码, _取代码 ())
输出调试文本 (到文本 (代码))

赋值 (zz, 运行汇编代码 (代码))
输出调试文本 (相加 (“调用得到指针:”, 到文本 (zz)))

.如果真 (大于 (zz, 1)) ' 免得空指针出错
    输出调试文本 (相加 (“调用外部注册函数:>1”, 返回值))
    赋值 (返回值, 指针到文本 (zz))
.如果真结束

输出调试文本 (相加 (“调用外部注册函数:”, 返回值))

返回 (返回值)


.类模块 循环类, , , 

.程序集变量 表达式, 文本型, , "0", 
.程序集变量 开始值, 文本型, , "0", 
.程序集变量 变量名, 文本型, , "0", 
.程序集变量 行, 空白型, , "0", 
.程序集变量 跳转, 文本型, , "0", 
.程序集变量 数量, 空白型, , , 
.程序集变量 操作行, 文本型, , "0", 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
清除数组 (表达式)
清除数组 (开始值)
清除数组 (变量名)
清除数组 (行)
清除数组 (操作行)

赋值 (数量, 0)


.子程序 压入, 整数型, 公开, 
.参数 For表达式Ex, 文本型, , 
.参数 For变量名Ex, 文本型, 可空, 
.参数 For起始值Ex, 文本型, 可空, 
.参数 For行Ex, 空白型, , 
.参数 跳转行, 文本型, 可空, 
.参数 操作行Ex, 文本型, 参考 可空, 

赋值 (数量, 相加 (数量, 1))

重定义数组 (表达式, 真, 数量)
重定义数组 (变量名, 真, 数量)
重定义数组 (开始值, 真, 数量)
重定义数组 (行, 真, 数量)
重定义数组 (跳转, 真, 数量)
重定义数组 (操作行, 真, 数量)

赋值 (表达式 [数量], For表达式Ex)
赋值 (变量名 [数量], For变量名Ex)
赋值 (开始值 [数量], For起始值Ex)

赋值 (行 [数量], For行Ex)
赋值 (跳转 [数量], 跳转行)
赋值 (操作行 [数量], 操作行Ex)
返回 (数量)


.子程序 取出, 整数型, 公开, 
.参数 表达式OUT, 文本型, 参考 可空, 
.参数 变量名OUT, 文本型, 参考 可空, 
.参数 起始值OUT, 文本型, 参考 可空, 
.参数 行OUT, 空白型, 参考 可空, 
.参数 清空, 逻辑型, 可空, 
.参数 跳转行OUT, 文本型, 参考 可空, 2007-07-18 Block块尾处
.参数 操作行OUT, 文本型, 参考 可空, 

.如果真 (小于或等于 (数量, 0))
    返回 (-1)
.如果真结束

赋值 (表达式OUT, 表达式 [数量])
赋值 (变量名OUT, 变量名 [数量])
赋值 (起始值OUT, 开始值 [数量])
赋值 (行OUT, 行 [数量])
赋值 (跳转行OUT, 跳转 [数量])
赋值 (操作行OUT, 操作行 [数量])

.如果真 (清空)
    赋值 (数量, 相减 (数量, 1))
    重定义数组 (表达式, 真, 数量)
    重定义数组 (变量名, 真, 数量)
    重定义数组 (开始值, 真, 数量)
    重定义数组 (行, 真, 数量)
    重定义数组 (跳转, 真, 数量)
    重定义数组 (操作行, 真, 数量)
.如果真结束
返回 (数量)


.子程序 分析For循环, 逻辑型, 公开, 
.参数 For行文本, 文本型, 参考, 
.参数 For表达式OUT, 文本型, 参考, 
.参数 For变量名OUT, 文本型, 参考 可空, 
.参数 For起始值OUT, 文本型, 参考 可空, 
.参数 For操作行OUT, 文本型, 参考 可空, 

.局部变量 ipos, 空白型, , , 
.局部变量 返回值, 逻辑型, , , 
.局部变量 For表达式l, 文本型, 静态, , 
.局部变量 For变量名l, 文本型, 静态, , 
.局部变量 For起始值l, 文本型, 静态, , 
.局部变量 For操作行l, 文本型, , , 
.局部变量 For, 文本型, , , 
.局部变量 临时变量, 变体型, , , 
.局部变量 临时变量堆, 类变量集, , , 

.如果真 (等于 (GetProcInfo (For行文本, 1).取数值 (), 0))
    异常 (1, 相加 (“期待'('”, For行文本))
    返回 (返回值)
.如果真结束
.如果真 (等于 (GetProcInfo (For行文本, 2).取数值 (), 0))
    异常 (1, 相加 (“期待')'”, For行文本))
    返回 (返回值)
.如果真结束

赋值 (ipos, 倒找文本 (For行文本, “)”, , 假))

赋值 (For表达式l, 取文本中间 (For行文本, 2, 相减 (ipos, 2)))

.如果真 (等于 (取文本长度 (For表达式l), 0))
    异常 (7, 相加 (“For循环 条件表达式为空”, For行文本))
    返回 (假)
.如果真结束

赋值 (ipos, GetCharPos (For表达式l, “;”))
.如果真 (小于或等于 (ipos, 0))
    异常 (1, 相加 (“期待';'”, For行文本))
    返回 (假)
.如果真结束
 ' For (i=9;i<20,i++)

赋值 (For变量名l, 取文本中间 (For表达式l, 1, 相减 (ipos, 1))) ' 取分号前面一段 i=9
赋值 (For表达式l, 取文本中间 (For表达式l, 相加 (ipos, 1), 取文本长度 (For表达式l))) ' For 条件'-- i<20

赋值 (ipos, GetCharPos (For表达式l, “;”)) ' 第二个分号
.如果真 (小于或等于 (ipos, 0))
    异常 (1, 相加 (“期待';'”, For行文本))
    返回 (假)
.如果真结束

赋值 (For, 取文本中间 (For表达式l, 1, 相减 (ipos, 1))) ' 表达式，判断
赋值 (For表达式l, 取文本中间 (For表达式l, 相加 (ipos, 1), 取文本长度 (For表达式l))) ' For 操作'-- i++
赋值 (For操作行l, For表达式l)


.如果真 (不等于 (删首尾空 (For变量名l), “”))
    赋值 (ipos, GetCharPos (For变量名l, “=”)) ' 取 i=9 的= 号位置
    .如果真 (小于或等于 (ipos, 0))
        异常 (1, 相加 (“期待'='”, For行文本))
        返回 (假)
    .如果真结束
    赋值 (临时变量堆, G当前执行类模块.取变量堆 ())
    .如果 (临时变量堆.分析声明语句 (For变量名l))
        G当前执行类模块.置变量堆 (临时变量堆)
        
    .否则
        .如果 (G当前执行类模块.变量赋值行 (For变量名l, ipos))
            
        .否则
            异常 (2, 相加 (“变量未定义：”, For变量名l))
            返回 (假)
        .如果结束
        
    .如果结束
    
.如果真结束




赋值 (For表达式OUT, For)
赋值 (For起始值OUT, For起始值l)
赋值 (For变量名OUT, For变量名l)
赋值 (For操作行OUT, For操作行l)

赋值 (返回值, 真)
返回 (返回值)


.子程序 分析While循环, 逻辑型, 公开, 
.参数 While行文本, 文本型, 参考, 
.参数 While表达式OUT, 文本型, 参考, 

.局部变量 ipos, 空白型, , , 
.局部变量 返回值, 逻辑型, , , 
.局部变量 While表达式l, 文本型, 静态, , 
.局部变量 While变量名l, 文本型, 静态, , 
.局部变量 临时变量, 文本型, , , 

.如果真 (等于 (GetProcInfo (While行文本, 1).取数值 (), 0))
    异常 (1, 相加 (“期待'('”, While行文本))
    返回 (返回值)
.如果真结束
.如果真 (等于 (GetProcInfo (While行文本, 2).取数值 (), 0))
    异常 (1, 相加 (“期待')'”, While行文本))
    返回 (返回值)
.如果真结束
赋值 (ipos, 倒找文本 (While行文本, “)”, , 假))

赋值 (While表达式l, 取文本中间 (While行文本, 2, 相减 (ipos, 2)))
.如果真 (等于 (取文本长度 (While表达式l), 0))
    异常 (7, 相加 (“条件表达式为空”, While行文本))
    返回 (假)
.如果真结束

赋值 (返回值, 真)
赋值 (While表达式OUT, While表达式l)

返回 (返回值)


.类模块 判断类, , , 

.程序集变量 表达式, 文本型, , "0", 
.程序集变量 判断通过, 逻辑型, , "0", 
.程序集变量 跳转, 文本型, , "0", 
.程序集变量 结束位置, 文本型, , "0", 
.程序集变量 数量, 空白型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 置通过, 空白型, 公开, 
.参数 通过吗, 逻辑型, , 

.如果真 (小于或等于 (数量, 0))
    返回 ()
.如果真结束
赋值 (判断通过 [数量], 通过吗)


.子程序 置表达式, 空白型, 公开, 
.参数 表达式Ex, 文本型, , 

.如果真 (小于或等于 (数量, 0))
    返回 ()
    
.如果真结束
赋值 (表达式 [数量], 表达式Ex)


.子程序 压入, 整数型, 公开, 
.参数 表达式Ex, 文本型, 参考, 
.参数 跳转Ex, 文本型, 参考 可空, 
.参数 判断通过Ex, 逻辑型, 参考 可空, 
.参数 结束位置Ex, 文本型, 参考 可空, 

赋值 (数量, 相加 (数量, 1))
重定义数组 (表达式, 真, 数量)
赋值 (表达式 [数量], 表达式Ex)
重定义数组 (跳转, 真, 数量)
赋值 (跳转 [数量], 跳转Ex)
重定义数组 (判断通过, 真, 数量)
赋值 (判断通过 [数量], 判断通过Ex)
重定义数组 (结束位置, 真, 数量)
赋值 (结束位置 [数量], 结束位置Ex)

返回 (数量)


.子程序 取出, 整数型, 公开, 
.参数 表达式OUT, 文本型, 参考 可空, 
.参数 跳转OUT, 文本型, 参考 可空, 
.参数 判断通过OUT, 逻辑型, 参考 可空, 
.参数 清空, 逻辑型, 可空, 
.参数 结束位置OUT, 文本型, 参考 可空, 

.如果真 (小于或等于 (数量, 0))
    返回 (-1)
.如果真结束
赋值 (表达式OUT, 表达式 [数量])
赋值 (跳转OUT, 跳转 [数量])
赋值 (判断通过OUT, 判断通过 [数量])
赋值 (结束位置OUT, 结束位置 [数量])

.如果真 (清空)
    赋值 (数量, 相减 (数量, 1))
    重定义数组 (表达式, 真, 数量)
    重定义数组 (跳转, 真, 数量)
    重定义数组 (判断通过, 真, 数量)
    重定义数组 (结束位置, 真, 数量)
    
.如果真结束
返回 (数量)


.子程序 取结束位置, 文本型, 公开, 
.如果真 (大于 (数量, 0))
    返回 (结束位置 [数量])
.如果真结束
返回 (“”)


.子程序 置结束位置, 空白型, 公开, 
.参数 位置, 文本型, 参考, 

.如果真 (大于 (数量, 0))
    赋值 (结束位置 [数量], 位置)
.如果真结束


.子程序 分析IF判断, 文本型, 公开, 
.参数 lpLine, 文本型, 参考, 
.参数 表达式OUT, 文本型, , 
.参数 跳转文本OUT, 文本型, 参考, 
.参数 标签OUT, 文本型, 参考 可空, 

.局部变量 表达式Ex, 文本型, , , 
.局部变量 S, 文本型, , , 
.局部变量 iPos, 空白型, , , 


.如果真 (等于 (GetProcInfo (lpLine, 1).取数值 (), 0))
    异常 (1, 相加 (lpLine, “ 期待'('”))
    返回 (“”)
.如果真结束
.如果真 (等于 (GetProcInfo (lpLine, 2).取数值 (), 0))
    异常 (1, 相加 (lpLine, “ 期待')'”))
    返回 (“”)
.如果真结束

赋值 (iPos, 倒找文本 (lpLine, “)”, , 假))
赋值 (跳转文本OUT, 删首尾空 (取文本右边 (lpLine, 相减 (取文本长度 (lpLine), iPos))))

赋值 (表达式Ex, 删首尾空 (取文本左边 (lpLine, iPos)))

 ' 跳转文本OUT ＝ 到小写 (删首尾空 (X取文本中间 (lpLine, GetProcInfo (lpLine, 2).取数值 () ＋ 1)))

赋值 (表达式OUT, 表达式Ex)
赋值 (S, 取文本左边 (跳转文本OUT, 4))

.如果真 (等于 (S, “then”))
    赋值 (跳转文本OUT, “”) ' 删首尾空 (X取文本右边 (跳转文本, X取文本长度 (跳转文本) － 4))
.如果真结束
.如果真 (等于 (取文本左边 (S, 2), “就”))
    赋值 (跳转文本OUT, “”) ' 删首尾空 (X取文本右边 (跳转文本, X取文本长度 (跳转文本) － 1))
.如果真结束
.如果真 (或者 (等于 (S, “跳到标签”), 等于 (S, “goto”)))
    
    赋值 (标签OUT, 删首尾空 (取文本右边 (跳转文本OUT, 相减 (取文本长度 (跳转文本OUT), 取文本长度 (S)))))
    
    赋值 (跳转文本OUT, S)
.如果真结束
返回 (表达式Ex)


.类模块 PE构造_EXE, , , 本类模块正在编写中

.子程序 注入引入函数, 空白型, , 


.子程序 加入资源段, 空白型, , 
.参数 资源, 字节集, , 



.子程序 指定程序入口, 空白型, , 


.子程序 构造PE文件头, 空白型, , 


.子程序 导出文件, 空白型, , 
.参数 文件名, 文本型, , 



.子程序 加入代码段, 空白型, , 
.参数 代码, 字节集, , 
.参数 是否公开, 逻辑型, , 



.类模块 PE构造_DLL, , , 待编写

.程序集 __HIDDEN_TEMP_MOD__, , , 

.子程序 _取代码, 字节集, , 


.子程序 置代码, 空白型, , 
.参数 被置代码, 字节集, , 



.子程序 mov_eax_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 mov_eax_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 mov_ptr_eax, 空白型, , 
.参数 地址, 整数型, , 



.子程序 mov_ecx_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 mov_ptr_常数, 空白型, , 
.参数 地址, 整数型, , 
.参数 常数, 整数型, , 



.子程序 loop, 空白型, , 以ECX计次循环指令,ECX不为零时循环,每次循环ECX递减1
.参数 编号, 整数型, , 



.子程序 jmp_eax, 空白型, , 


.子程序 add_eax_常数, 空白型, , 加法指令
.参数 常数, 整数型, , 



.子程序 sub_eax_常数, 空白型, , 减法指令
.参数 常数, 整数型, , 



.子程序 imul_eax_常数, 空白型, , 乘法指令
.参数 常数, 整数型, , 



.子程序 idiv_ebx, 空白型, , 除法指令


.子程序 cmp_eax_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 je_整数, 整数型, , 等于则转移指令


.子程序 jg_整数, 整数型, , 大于则转移


.子程序 je_字节, 整数型, , 等于则转移指令


.子程序 jg_字节, 整数型, , 大于则转移


.子程序 push_eax, 空白型, , 


.子程序 push_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 push_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 call_eax, 空白型, , 


.子程序 call_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 ret, 空白型, , 


.子程序 ret_参数数, 空白型, , 
.参数 参数数, 整数型, , 



.子程序 inc_ptr, 空白型, , 递增1指令
.参数 地址, 整数型, , 



.子程序 dec_eax, 空白型, , 递减1指令


.子程序 取代码长度, 整数型, , 


.子程序 pop_eax, 空白型, , 


.子程序 创建转移编号, 整数型, , 


.子程序 判断字节结束, 空白型, , 
.参数 编号, 整数型, , 



.子程序 判断整数结束, 空白型, , 
.参数 编号, 整数型, , 



.子程序 检测代码是否错误, 逻辑型, , 


.子程序 inc_eax, 空白型, , 


.子程序 jne_字节, 整数型, , 不等于则转移指令


.子程序 shr_eax_常数, 空白型, , 右移
.参数 常数, 整数型, , 



.子程序 shl_eax_常数, 空白型, , 左移
.参数 常数, 整数型, , 



.子程序 add_eax_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 sub_eax_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 imul_eax_edx, 空白型, , 


.子程序 mov_ecx_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 mov_edx_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 pop_ecx, 空白型, , 


.子程序 push_ecx, 空白型, , 


.子程序 mov_eax_ptr_edx, 空白型, , 


.子程序 mov_eax_ptr_eax, 空白型, , 


.子程序 cmp_ptr_常数, 空白型, , 
.参数 地址, 整数型, , 
.参数 常数, 整数型, , 



.子程序 mov_ptr_edx_eax, 空白型, , 


.子程序 mov_edx_eax, 空白型, , 


.子程序 mov_ecx_eax, 空白型, , 


.子程序 inc_ptr_eax, 空白型, , 


.子程序 cmp_eax_edx, 空白型, , 


.子程序 jge_字节, 整数型, , 大于或等于则转移


.子程序 jl_字节, 整数型, , 小于则转移


.子程序 jle_字节, 整数型, , 小于或等于则转移


.子程序 add_edx_字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 jmp_字节, 整数型, , 


.子程序 跳转字节到此, 空白型, , 
.参数 编号, 整数型, , 



.子程序 and_eax_整数, 空白型, , 位与运算
.参数 数值, 整数型, , 



.子程序 idiv_ecx, 空白型, , 


.子程序 mov_eax_ebx, 空白型, , 


.子程序 mov_ebx_eax, 空白型, , 


.子程序 mov_ptr_ebx_eax, 空白型, , 


.子程序 mov_eax_ptr_ebx, 空白型, , 


.子程序 nop, 空白型, , 空指令


.子程序 mov_ebx_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 xor_eax_ebx, 空白型, , 异或运算


.子程序 not_eax, 空白型, , 取反指令


.子程序 shl_ebx_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 shr_ebx_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 mov_eax_edx, 空白型, , 


.子程序 add_ebx_字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 cmp_eax_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 sub_edx_字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 inc_ptr_edx, 空白型, , 


.子程序 add_ebx_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 push_ebx, 空白型, , 


.子程序 pop_ebx, 空白型, , 


.子程序 add_ebx_eax, 空白型, , 


.子程序 add_eax_edx, 空白型, , 


.子程序 push_edx, 空白型, , 


.子程序 pop_edx, 空白型, , 


.子程序 sub_ebx_eax, 空白型, , 


.子程序 mov_ebx_edx, 空白型, , 


.子程序 inc_ecx, 空白型, , 


.子程序 push_ebp, 空白型, , 


.子程序 pop_ebp, 空白型, , 


.子程序 mov_ebp_esp, 空白型, , 


.子程序 mov_eax_ptr_ebp加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 pushad, 空白型, , 


.子程序 popad, 空白型, , 


.子程序 mov_eax_ptr_ds整数, 空白型, , 等于mov_eax_ptr
.参数 地址, 整数型, , 



.子程序 mov_eax_ptr_eax加整数, 空白型, , 
.参数 数值, 整数型, , 



.子程序 lea_ecx_ptr_eax加整数, 空白型, , 
.参数 数值, 整数型, , 



.子程序 mov_edi_eax, 空白型, , 


.子程序 mov_edi_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 mov_edi_常数, 空白型, , 
.参数 数值, 整数型, , 



.子程序 test_eax_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 add_ecx_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 call_ebx, 空白型, , 


.子程序 mov_esp_ebp, 空白型, , 


.子程序 mov_esi_ptr_ebp加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_esi_eax, 空白型, , 


.子程序 mov_eax_esi, 空白型, , 


.子程序 mov_esi_ebx, 空白型, , 


.子程序 mov_eax_ptr_esp加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_ecx_ptr_eax加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_ecx_ptr_edx加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_edx_ptr_ecx加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 call, 空白型, , 
.参数 偏移地址, 整数型, , 



.子程序 mov_eax_ptr_eax加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_ebx_ptr_eax加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_ecx_ptr_ebx加整数, 空白型, , 
.参数 数值, 整数型, , 



.子程序 lea_ecx_ptr_esp加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 xor_edi_edi, 空白型, , 


.子程序 push_edi, 空白型, , 


.子程序 mov_ecx_edi, 空白型, , 


.子程序 push_esi, 空白型, , 


.子程序 mov_ptr_ecx加字节_eax, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_ecx_ptr_ecx加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 十六进制到十进制, 整数型, , 
.参数 原数, 文本型, , 



.子程序 右移位, 整数型, , 
.参数 目标数据, 整数型, , 
.参数 移动位数, 整数型, , 



.子程序 左移位, 整数型, , 
.参数 目标数据, 整数型, , 
.参数 移动位数, 整数型, , 



.子程序 取文本型变量指针, 整数型, , 
.参数 a, 文本型, 参考, 



.子程序 取日期时间型变量指针, 整数型, , 
.参数 a, 日期时间型, 参考, 



.子程序 取字节集型变量指针, 整数型, , 
.参数 a, 字节集, , 



.子程序 取整数型变量指针, 整数型, , 
.参数 a, 整数型, 参考, 



.子程序 取长整数变量指针, 整数型, , 
.参数 a, 长整数型, 参考, 



.子程序 取字节型数组变量指针, 整数型, , 
.参数 a, 字节型, 参考 数组, 



.子程序 取双精度小数型变量指针, 整数型, , 
.参数 a, 双精度小数型, 参考, 



.子程序 取小数型变量指针, 整数型, , 
.参数 a, 小数型, 参考, 



.子程序 取字节型变量指针, 整数型, , 
.参数 a, 字节型, 参考, 



.子程序 _取字节集长度, 整数型, , 
.参数 字节集数据, 字节集, 参考, 



.子程序 对象执行, 整数型, , 
.参数 子程序入口地址, 整数型, , 
.参数 参数个数, 整数型, 可空, 
.参数 参数, 整数型, 可空 数组, 



.子程序 复制字节集, 整数型, , 
.参数 源字节集, 字节集, 参考, 
.参数 目的字节集, 字节集, 参考, 
.参数 复制大小, 整数型, , 



.子程序 复制内存, 整数型, , 
.参数 源地址, 整数型, , 
.参数 目的地址, 整数型, , 
.参数 复制大小, 整数型, , 



.子程序 拷贝字节集到内存, 整数型, , 
.参数 源字节集, 字节集, 参考, 
.参数 目的地址, 整数型, , 
.参数 复制大小, 整数型, , 



.子程序 拷贝内存到字节集, 整数型, , 
.参数 源地址, 整数型, , 
.参数 目的字节集, 字节集, 参考, 
.参数 复制大小, 整数型, , 



.子程序 运行汇编代码, 整数型, , 
.参数 代码, 字节集, , 
.参数 参数个数, 整数型, 可空, 
.参数 参数, 整数型, 可空 数组, 



.子程序 test_eax_eax, 空白型, , 


.子程序 pop_esi, 空白型, , 


.子程序 leave, 空白型, , 


.子程序 loopz, 空白型, , 等于则循环,ECX不为零且标志Z=1时循环. 
.参数 编号, 整数型, , 



.子程序 loopnz, 空白型, , 不等于则循环,ECX不为零且标志Z=0时循环
.参数 编号, 整数型, , 



.子程序 dec_ebx, 空白型, , 


.子程序 dec_ecx, 空白型, , 


.子程序 dec_edx, 空白型, , 


.子程序 mov_edx_常数, 空白型, , 
.参数 常数, 整数型, , 



.子程序 mov_esi_常数, 空白型, , 
.参数 数值, 整数型, , 



.子程序 mov_ecx_esi, 空白型, , 


.子程序 lea_ecx_ptr_esi加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 in_al_dx, 空白型, , 


.子程序 in_ax_dx, 空白型, , 


.子程序 in_al_端口号, 空白型, , 
.参数 端口号, 整数型, , 



.子程序 in_ax_端口号, 空白型, , 
.参数 端口号, 整数型, , 



.子程序 out_端口号_ax, 空白型, , 
.参数 端口号, 整数型, , 



.子程序 out_dx_al, 空白型, , 


.子程序 mov_eax_ptr_edx加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_edx_ptr_edi加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_edx_ptr_edi加整数, 空白型, , 
.参数 数值, 整数型, , 



.子程序 lea_eax_ptr_eax加字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 mov_esi_ptr, 空白型, , 
.参数 地址, 整数型, , 



.子程序 add_esi_常数, 空白型, , 加法指令
.参数 常数, 整数型, , 



.子程序 add_esp_字节, 空白型, , 
.参数 字节, 整数型, , 



.子程序 inc_esi, 空白型, , 


.子程序 inc_edi, 空白型, , 


.类模块 标签类, , , 

.程序集变量 标签名称, 文本型, , "0", 
.程序集变量 行, 空白型, , "0", 
.程序集变量 数量, 空白型, , , 
.程序集变量 当前GOTO, 文本型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
清除数组 (行)
清除数组 (标签名称)


.子程序 添加标签, 逻辑型, 公开, 
.参数 标签名, 文本型, 参考, 
.参数 行Ex, 空白型, , 

.如果真 (或者 (大于 (取标签索引 (标签名), 0), 小于或等于 (行Ex, 0)))
    异常 (1, 相加 (“重复定义标签名”, 标签名))
    返回 (假)
.如果真结束

赋值 (数量, 相加 (数量, 1))
重定义数组 (标签名称, 真, 数量)
赋值 (标签名称 [数量], 标签名)
重定义数组 (行, 真, 数量)
赋值 (行 [数量], 行Ex)
返回 (真)


.子程序 取标签索引, 整数型, 公开, 
.参数 标签名, 文本型, , 

.局部变量 I, 空白型, , , 

.如果真 (小于或等于 (数量, 0))
    返回 (数量)
.如果真结束
.计次循环首 (数量, I)
    .如果真 (等于 (到小写 (标签名), 到小写 (标签名称 [I])))
        返回 (行 [I])
    .如果真结束
    
.计次循环尾 ()
返回 (0)


.子程序 取数量, 整数型, 公开, 
返回 (数量)

.子程序 取GOTO, 文本型, 公开, 
返回 (当前GOTO)

.子程序 置GOTO, 空白型, 公开, 
.参数 GOTO, 文本型, , 

赋值 (当前GOTO, GOTO)


.类模块 类执行模块, , , 

.程序集变量 sReturnFromFunc, 变体型, , , 调用过程返回的
.程序集变量 当前类型, 空白型, , , 
.程序集变量 当前状态, 整数型, , , 0　为执行，1为暂停
.程序集变量 当前过程, 文本型, , , 当前所执行的过程名称
.程序集变量 当前错误, 文本型, , , 
.程序集变量 变量堆, 类变量集, , , 
.程序集变量 当前执行行, 文本型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 取变量堆, 类变量集, 公开, 
返回 (变量堆)


.子程序 置变量堆, 空白型, 公开, 
.参数 TEMP, 类变量集, , 

赋值 (变量堆, TEMP)


.子程序 置状态, 空白型, 公开, 
.参数 A, 空白型, , 

赋值 (当前状态, A)


.子程序 取状态, 整数型, 公开, 
返回 (当前状态)


.子程序 取执行结果, 变体型, 公开, 
返回 (sReturnFromFunc)


.子程序 ReadOp, 文本型, , 
.参数 Str1, 文本型, 参考, 

.局部变量 rets, 文本型, , , 
.局部变量 C1, 文本型, , , 
.局部变量 返回值, 文本型, , , 

 ' 读入操作符
 ' 参数： Str1 处理的字符串
 ' 返回：  取到的操作符， "" 为错误！
 ' Str1 ：处理后字符串
赋值 (C1, ReadChar (Str1))
赋值 (返回值, “”)
.判断循环首 (不等于 (C1, “”))
    .如果 (或者 (等于 (C1, “*”), 等于 (C1, “%”), 等于 (C1, “^”), 等于 (C1, “-”), 等于 (C1, “+”), 等于 (C1, “/”), 等于 (C1, “&”), 等于 (C1, “\”), 等于 (C1, “>”), 等于 (C1, “<”), 等于 (C1, “=”), 等于 (C1, “|”)))
        赋值 (返回值, C1)
        返回 (返回值)
    .否则
        .如果真 (等于 (ISBlank (C1), 假))
            RetChar (Str1, C1)
            返回 (返回值)
        .如果真结束
        
    .如果结束
    
    赋值 (C1, ReadChar (Str1))
    
.判断循环尾 ()
返回 (“”)


.子程序 IsOp, 逻辑型, , 
.参数 C1, 文本型, , 
.参数 类型, 空白型, 可空, 

.判断开始 (小于或等于 (类型, 0))
    .如果 (或者 (等于 (C1, “*”), 等于 (C1, “%”), 等于 (C1, “^”), 等于 (C1, “-”), 等于 (C1, “+”), 等于 (C1, “/”), 等于 (C1, “&”), 等于 (C1, “\”), 等于 (C1, “>”), 等于 (C1, “<”), 等于 (C1, “=”), 等于 (C1, “|”)))
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    
.判断 (等于 (类型, 1)) ' 逻辑运算符
    .如果 (或者 (等于 (C1, “>”), 等于 (C1, “<”), 等于 (C1, “=”)))
        返回 (真)
    .否则
        返回 (假)
    .如果结束
    
.默认
    
.判断结束
返回 (假)

.子程序 ReadField, 文本型, , 
.参数 str1, 文本型, , 

返回 (“”)


.子程序 ReadFunction, 变体型, 公开, 
.参数 Str1, 文本型, 参考, 
.参数 声明, 逻辑型, 可空, 读取声明语句

.局部变量 C1, 文本型, , , 
.局部变量 C2, 文本型, , , 
.局部变量 C3, 文本型, , , 
.局部变量 C, 文本型, , "0", 
.局部变量 Rets, 变体型, , , 
.局部变量 Vars, 逻辑型, , , 当前可能是变量
.局部变量 i, 空白型, , , 
.局部变量 错误信息, 文本型, , , 
.局部变量 调用类执行模块, 类执行模块, , , 
.局部变量 临时类, 类执行模块, , , 
.局部变量 临时堆栈, 类变量集, , , 
.局部变量 是否括号, 逻辑型, , , 
.局部变量 当前类型X, 空白型, , , 

.如果真 (不等于 (当前错误, “”))
    异常 (2, 当前错误)
    赋值 (当前错误, “”)
    返回 (Rets)
.如果真结束

赋值 (当前类型X, 0)
Rets.赋值 (字符 (0), )

赋值 (C1, ReadChar (Str1))
.判断循环首 (并且 (不等于 (C1, “(”), 不等于 (C1, “”)))
    赋值 (C2, 相加 (C2, C1))
    赋值 (C1, ReadChar (Str1))
    .如果真 (或者 (IsOp (C1), 等于 (C1, “)”), 等于 (C1, “”), 等于 (C1, “,”))) ' 如果标识符后是操作符,则认为是变量名
        赋值 (Vars, 真)
        RetChar (Str1, C1)
        跳出循环 ()
    .如果真结束
    
.判断循环尾 ()
赋值 (是否括号, 等于 (C1, “(”))

赋值 (C2, 删首尾空 (C2)) ' 去除边上空白
.如果真 (等于 (C2, “)”))
    Rets.清除 ()
    返回 (Rets)
.如果真结束

.如果真 (Vars) ' ======================= 这里读取变量--
    .如果真 (等于 (取文本右边 (C2, 1), “)”))
        赋值 (C2, 取文本左边 (C2, 相减 (取文本长度 (C2), 1)))
    .如果真结束
    .如果 (等于 (声明, 假))
        赋值 (Rets, ReturnData (到小写 (C2)))
    .否则
        Rets.赋值 (C2, )
    .如果结束
    
    返回 (Rets)
     ' ===========================================
.如果真结束

 ' ----------===读取函数====-----------------=
 ' ---文本型函数---
赋值 (C2, 到大写 (C2))
.判断开始 (或者 (等于 (C2, “ASC”), 等于 (C2, “取代码”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #整数型)
    Rets.赋值 (取代码 (C1, ), )
.判断 (或者 (等于 (C2, “CHR”), 等于 (C2, “字符”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #文本型)
    Rets.赋值 (字符 (到字节 (C1)), )
.判断 (或者 (等于 (C2, “CSTR”), 等于 (C2, “到文本”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #文本型)
    Rets.赋值 (C1, )
.判断 (或者 (等于 (C2, “LEFT”), 等于 (C2, “取文本左边”)))
    取参数组 (Str1, C, 2)
    .如果真 (等于 (取文本长度 (C [1]), 0))
        赋值 (错误信息, “Left 函数,被取的文本不能为空”)
    .如果真结束
    .如果真 (小于或等于 (到数值 (C [2]), 0))
        赋值 (错误信息, 相加 (错误信息, “ 所取的数目必须>0”))
    .如果真结束
    .如果真 (等于 (错误信息, “”))
        Rets.赋值 (取文本左边 (C [1], 到数值 (C [2])), )
    .如果真结束
    赋值 (当前类型X, #文本型)
    
.判断 (或者 (等于 (C2, “LEN”), 等于 (C2, “取文本长度”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #整数型)
    Rets.赋值 (取文本长度 (C1), )
    
.判断 (或者 (等于 (C2, “MID”), 等于 (C2, “取文本中间”)))
    取参数组 (Str1, C, 3)
    .如果真 (等于 (取文本长度 (C [1]), 0))
        赋值 (错误信息, “MID 函数,被取的文本不能为空”)
    .如果真结束
    .如果真 (小于或等于 (到数值 (C [2]), 0))
        赋值 (错误信息, 相加 (错误信息, “ ,开始位置必须大于0”))
    .如果真结束
    .如果真 (并且 (等于 (到数值 (C [3]), 0), 等于 (错误信息, “”)))
        Rets.赋值 (取文本中间 (C [1], 到数值 (C [2]), 取文本长度 (C [1])), )
    .如果真结束
    .如果真 (并且 (大于 (到数值 (C [3]), 0), 等于 (错误信息, “”)))
        Rets.赋值 (取文本中间 (C [1], 到数值 (C [2]), 到数值 (C [3])), )
    .如果真结束
    赋值 (当前类型X, #文本型)
    
.判断 (或者 (等于 (C2, “RIGHT”), 等于 (C2, “取文本右边”)))
    取参数组 (Str1, C, 2)
    .如果真 (小于或等于 (取文本长度 (C [1]), 0))
        赋值 (错误信息, “Right 函数,被取的文本不能为空”)
    .如果真结束
    .如果真 (小于或等于 (到数值 (C [2]), 0))
        赋值 (错误信息, 相加 (错误信息, “,所取的数目必须大于0”))
    .如果真结束
    .如果真 (等于 (错误信息, “”))
        Rets.赋值 (取文本右边 (C [1], 到数值 (C [2])), )
    .如果真结束
    赋值 (当前类型X, #文本型)
    
.判断 (或者 (等于 (C2, “TRIM”), 等于 (C2, “删首尾空”)))
    赋值 (当前类型X, #文本型)
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (删首尾空 (C1), )
.判断 (或者 (等于 (C2, “INSTR”), 等于 (C2, “寻找文本”)))
    赋值 (当前类型X, #文本型)
    取参数组 (Str1, C, 3)
    .如果真 (并且 (不等于 (C [3], “”), 小于 (到数值 (C [3]), 1)))
        赋值 (错误信息, 相加 (错误信息, “ 寻找文本 函数,<参数3>直始位置必须>0”))
    .如果真结束
    
    .如果真 (等于 (错误信息, “”))
        Rets.赋值 (寻找文本 (C [1], C [2], 到数值 (C [3]), 假), )
    .如果真结束
    
.判断 (或者 (等于 (C2, “REPLACE”), 等于 (C2, “文本替换”)))
    取参数组 (Str1, C, 4)
    .如果真 (或者 (等于 (C [1], “”), 等于 (C [2], “”), 等于 (C [3], “”)))
        赋值 (错误信息, “ 文本替换 函数,三个参数都是必须参数!”)
    .如果真结束
    .如果真 (等于 (错误信息, “”))
        Rets.赋值 (文本替换 (C [1], 到数值 (C [2]), 到数值 (C [3]), C [4]), )
    .如果真结束
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “SPACE”), 等于 (C2, “取空白文本”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #文本型)
    Rets.赋值 (取空白文本 (到数值 (C1)), )
.判断 (或者 (等于 (C2, “STRING”), 等于 (C2, “取重复文本”)))
    赋值 (当前类型X, #文本型)
    取参数组 (Str1, C, 2)
    Rets.赋值 (取重复文本 (到数值 (C [1]), C [2]), )
.判断 (或者 (等于 (C2, “UCASE”), 等于 (C2, “到大写”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (到大写 (C1), )
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “LCASE”), 等于 (C2, “到小写”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (到小写 (C1), )
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “LTRIM”), 等于 (C2, “删首空”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (删首空 (C1), )
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “RTRIM”), 等于 (C2, “删尾空”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #文本型)
    Rets.赋值 (删尾空 (C1), )
.判断 (或者 (等于 (C2, “TRIMALL”), 等于 (C2, “删全部空”))) ' ==================== 文本型函数 结束 ==================**
    赋值 (C1, GetExp (Str1).取文本 ())
    赋值 (当前类型X, #文本型)
    Rets.赋值 (删全部空 (C1), )
.判断 (或者 (等于 (C2, “CINT”), 等于 (C2, “取整”))) ' ------------------ 数值型函数 开始->--------------------
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (取整 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “ROUND”), 等于 (C2, “四舍五入”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (四舍五入 (到数值 (C1), ), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “FIX”), 等于 (C2, “绝对取整”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (绝对取整 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “SQR”), 等于 (C2, “求平方根”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求平方根 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “SIN”), 等于 (C2, “求正弦”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求正弦 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “COS”), 等于 (C2, “求余弦”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求余弦 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “TAN”), 等于 (C2, “求正切”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求正切 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “ATN”), 等于 (C2, “求反正切”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求反正切 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “LOG”), 等于 (C2, “求自然对数”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求自然对数 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “EXP”), 等于 (C2, “求反对数”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    Rets.赋值 (求反对数 (到数值 (C1)), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “RANDOMIZE”), 等于 (C2, “置随机数种子”)))
    赋值 (C1, GetExp (Str1).取文本 ())
    置随机数种子 (到数值 (C1))
.判断 (或者 (等于 (C2, “RND”), 等于 (C2, “取随机数”)))
    取参数组 (Str1, C)
    .判断开始 (等于 (取数组成员数 (C), 1))
        Rets.赋值 (取随机数 (到数值 (C [1]), ), )
    .判断 (等于 (取数组成员数 (C), 2))
        Rets.赋值 (取随机数 (到数值 (C [1]), 到数值 (C [2])), )
    .默认
        Rets.赋值 (取随机数 (), )
    .判断结束
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “取绝对值”), 等于 (C2, “ABS”))) ' ==================数值型函数 结束=====================**
    取参数组 (Str1, C)
    Rets.赋值 (取绝对值 (到数值 (C [1])), )
    赋值 (当前类型X, #双精度小数型)
.判断 (或者 (等于 (C2, “GETCMDLINE”), 等于 (C2, “取命令行”))) ' ------------------环境存取函数 开始->-------------------
    取命令行 (C)
    Rets.赋值 (JoinArr (C), )
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “取运行目录”), 等于 (C2, “GETRUNPATH”)))
    Rets.赋值 (取运行目录 (), )
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “GETRUNFILENAME”), 等于 (C2, “取执行文件名”)))
    Rets.赋值 (取执行文件名 (), )
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “读环境变量”), 等于 (C2, “GETENV”)))
    取参数组 (Str1, C, 1)
    .如果真 (等于 (取文本长度 (删首尾空 (C [1])), 0))
        赋值 (错误信息, “读取的环境变量名不能为空”)
    .如果真结束
    .如果真 (等于 (错误信息, “”))
        Rets.赋值 (读环境变量 (删首尾空 (C [1])), )
    .如果真结束
    赋值 (当前类型X, #文本型)
.判断 (或者 (等于 (C2, “PUTENV”), 等于 (C2, “写环境变量”))) ' ===================环境存取函数 结束===================**
    取参数组 (Str1, C, 2)
    .如果真 (等于 (取文本长度 (删首尾空 (C [1])), 0))
        赋值 (错误信息, “读取的环境变量名不能为空”)
    .如果真结束
    .如果真 (等于 (错误信息, “”))
        Rets.赋值 (写环境变量 (删首尾空 (C [1]), C [2]), )
    .如果真结束
    赋值 (当前类型X, #逻辑型)
.判断 (或者 (等于 (C2, “增减时间”), 等于 (C2, “TIMECHG”))) ' ----------------- 时间类函数 开始->--------------------------
    取参数组 (Str1, C, 3)
    .如果真 ()

.子程序 取参数组, 整数型, , 
.参数 Str1, 文本型, 参考, 
.参数 参数, 文本型, 参考 数组, 用于存放结果的数组
.参数 数量, 空白型, 可空, 

.局部变量 C1, 文本型, , , 
.局部变量 I, 空白型, , , 

赋值 (I, 1)

.如果 (大于 (数量, 0))
    重定义数组 (参数, 假, 数量)
.否则
    重定义数组 (参数, 假, 1)
.如果结束
赋值 (Str1, 删首空 (Str1))

.如果真 (或者 (等于 (取文本左边 (Str1, 1), “)”), 等于 (Str1, “”)))
    .如果真 (小于或等于 (数量, 0))
        重定义数组 (参数, 假, 0)
    .如果真结束
    
    返回 (0)
.如果真结束
赋值 (参数 [1], GetExp (Str1).取文本 ())
.判断循环首 (并且 (真, 不等于 (Str1, “”), 不等于 (Str1, “)”)))
    赋值 (C1, ReadChar (Str1))
    .判断循环首 (并且 (ISBlank (C1), 不等于 (C1, “”)))
        赋值 (C1, ReadChar (Str1))
    .判断循环尾 ()
    .如果 (等于 (C1, “,”))
        赋值 (I, 相加 (I, 1))
        .如果真 (并且 (大于 (数量, 0), 大于 (I, 数量)))
            跳出循环 ()
        .如果真结束
        .如果真 (小于或等于 (数量, 0))
            重定义数组 (参数, 真, I)
            
        .如果真结束
        赋值 (参数 [I], GetExp (Str1).取文本 ())
    .否则
        .如果真 (或者 (等于 (C1, “)”), 等于 (C1, “”)))
            RetChar (Str1, C1)
            跳出循环 ()
        .如果真结束
        赋值 (参数 [I], 相加 (参数 [I], C1))
    .如果结束
    
.判断循环尾 ()

返回 (I)


.子程序 用户函数调用, 文本型, , 
.参数 过程名, 文本型, , 
.参数 vLst, 文本型, 参考 可空 数组, 
.参数 调用类执行模块, 类执行模块, 参考 可空, 

.局部变量 pName, 文本型, , , 
.局部变量 I, 空白型, , , 
.局部变量 TheData, 文本型, , , 
.局部变量 pParmLst, 文本型, , "0", 
.局部变量 lVarName, 文本型, , , 
.局部变量 ipos, 空白型, , , 
.局部变量 nVarType, 文本型, , , 
.局部变量 返回值, 文本型, , , 
.局部变量 临时变量, 变体型, , , 
.局部变量 PCount, 空白型, , , 参数数量，传过来的
.局部变量 临时变量堆, 类变量集, , , 

赋值 (过程名, 删首空 (过程名))
赋值 (返回值, 字符 (0))
.如果 (是否为空 (vLst))
    赋值 (PCount, 0)
.否则
    赋值 (PCount, 取数组成员数 (vLst))
.如果结束
.如果真 (等于 (PCount, -1))
    赋值 (PCount, 0)
.如果真结束

临时变量.赋值 (0, )

赋值 (pName, 删首尾空 (过程名)) ' 取得（之前的函数名

.如果真 (等于 (取文本长度 (pName), 0))
    异常 (1, 相加 (“需要函数或过程名:”, 过程名))
    返回 (返回值)
.如果真结束
.如果真 (不等于 (PCount, G过程类实体.过程取参数量 (pName)))
    异常 (12, 相加 (pName, “ 参数数量不正确”))
    返回 (返回值)
.如果真结束


赋值 (pParmLst, 分割文本 (G过程类实体.过程取变量列表 (pName), “,”, ))
.如果真 (等于 (PCount, 0)) ' 没有参数
    赋值 (返回值, G过程类实体.过程取代码段 (pName))
    返回 (返回值)
.如果真结束

赋值 (临时变量堆, 调用类执行模块.取变量堆 ())
.计次循环首 (取数组成员数 (pParmLst), I)
    赋值 (TheData, 删首尾空 (pParmLst [I]))
    赋值 (ipos, 寻找文本 (TheData, “ ”, , 假))
    赋值 (nVarType, 取文本中间 (TheData, 1, ipos)) ' 参数类型
    .如果 (大于 (ipos, 0))
        赋值 (lVarName, 删首尾空 (取文本中间 (TheData, ipos, 取文本长度 (TheData)))) ' 参数名
    .否则
        异常 (3, 相加 (“需要类型:”, TheData))
        返回 (返回值)
    .如果结束
    赋值 (nVarType, 删首尾空 (到小写 (nVarType)))
    赋值 (临时变量, GetExp (vLst [I]))
    
    
    赋值 (PCount, 临时变量堆.变量添加变量 (lVarName, 变量名称到类型 (nVarType), 假))
    临时变量堆.变量赋值 (PCount, 临时变量)
    
.计次循环尾 ()
调用类执行模块.置变量堆 (临时变量堆)

赋值 (返回值, G过程类实体.过程取代码段 (pName))
赋值 (当前过程, pName)

赋值 (pName, “”)
赋值 (lVarName, “”)
赋值 (I, 0)
清除数组 (vLst)
清除数组 (pParmLst)
返回 (返回值)

.子程序 GetValue, 变体型, 公开, 
.参数 Str1, 文本型, 参考, 
.参数 声明, 逻辑型, 可空, 读取声明语句

.局部变量 C1, 文本型, , , 
.局部变量 错误信息, 文本型, , , 
.局部变量 返回值, 变体型, , , 
.局部变量 OK, 逻辑型, , , 
.局部变量 当前类型, 空白型, , , 

.如果真 (不等于 (当前错误, “”))
    异常 (2, 当前错误)
    赋值 (当前错误, “”)
    返回 (返回值)
.如果真结束

赋值 (C1, ReadChar (Str1))
.判断循环首 (并且 (等于 (C1, “ ”), 不等于 (C1, “”)))
    赋值 (C1, ReadChar (Str1))
.判断循环尾 ()
.判断开始 (等于 (C1, 字符 (34)))
    返回值.赋值 (ReadString (Str1), )
    .如果 (声明)
        返回值.赋值 (置双引号 (返回值.取文本 (), 真), )
    .否则
        
    .如果结束
    赋值 (当前类型, #文本型)
    赋值 (OK, 真)
.判断 (等于 (C1, “(”))
    赋值 (返回值, GetExp (Str1))
    赋值 (C1, ReadChar (Str1))
    .判断循环首 (并且 (等于 (C1, 字符 (32)), 不等于 (C1, “”)))
        赋值 (C1, ReadChar (Str1))
    .判断循环尾 ()
    .如果真 (不等于 (C1, “)”))
        赋值 (错误信息, “需要')'”)
    .如果真结束
    赋值 (OK, 真)
.判断 (并且 (大于或等于 (C1, “0”), 小于或等于 (C1, “9”)))
    返回值.赋值 (相加 (C1, ReadNumber (Str1)), )
    赋值 (当前类型, #双精度小数型)
    赋值 (OK, 真)
.默认
    
.判断结束

.如果真 (等于 (OK, 假))
    RetChar (Str1, C1)
    赋值 (返回值, ReadFunction (Str1, 声明))
.如果真结束


 ' C1 ＝ ReadChar (Str1)
 ' .如果 (并且 (等于 (C1, “)”), 等于 (OK, 假)))
    
.否则
     ' RetChar (Str1, C1)
.如果结束






.如果真 (不等于 (当前错误, “”))
    返回值.清除 ()
.如果真结束
.如果真 (不等于 (错误信息, “”))
    赋值 (当前错误, 错误信息)
.如果真结束
.如果真 (并且 (等于 (当前类型, #文本型), 声明))
    返回值.赋值 (置双引号 (返回值.取文本 (), 真), )
.如果真结束

返回 (返回值)


.子程序 GetExp, 变体型, 公开, 
.参数 Str1, 文本型, 参考, 

.局部变量 Val1, 文本型, , , 
.局部变量 Val2, 文本型, , , 
.局部变量 Op1, 文本型, , , 
.局部变量 Op2, 文本型, , , 
.局部变量 Val3, 文本型, , , 
.局部变量 NewVal, 变体型, , , 
.局部变量 lStr1, 文本型, , , 
.局部变量 优先, 逻辑型, , , 
.局部变量 上次操作符, 文本型, , , 
.局部变量 下次操作符, 文本型, , , 
.局部变量 匿名局部变量_7880, 空白型, , , 


 ' 变量堆.Dump ()



.如果真 (不等于 (当前错误, “”))
    异常 (2, 当前错误)
    赋值 (当前错误, “”)
    返回 (NewVal)
.如果真结束
赋值 (NewVal, GetValue (Str1))
赋值 (Val1, NewVal.取文本 ())
 ' 输出调试文本 (“Val1:” ＋ Val1 ＋ “ Str1=” ＋ Str1)

赋值 (Op1, ReadOp (Str1))

.判断循环首 (并且 (不等于 (Str1, “”), 不等于 (Op1, “”)))
    赋值 (上次操作符, ReadChar (Str1)) ' 是否双元操作符
    .如果 (IsOp (上次操作符))
        赋值 (上次操作符, 相加 (Op1, 上次操作符))
    .否则
        RetChar (Str1, 上次操作符)
        赋值 (上次操作符, Op1)
    .如果结束
    
    
    
    赋值 (Val2, GetValue (Str1).取文本 ()) ' 上次操作符的下个数据值
    
    赋值 (Op2, ReadOp (Str1)) ' 操作符的下一个字符,判断是否是双目操作符
    赋值 (下次操作符, ReadChar (Str1))
    
    .如果 (IsOp (下次操作符))
        赋值 (下次操作符, 相加 (Op2, 下次操作符))
    .否则
        RetChar (Str1, 下次操作符)
        赋值 (下次操作符, Op2)
    .如果结束
    
    .判断循环首 (不等于 (下次操作符, “”))
        赋值 (优先, 假)
        .判断开始 (并且 (或者 (等于 (下次操作符, “*”), 等于 (下次操作符, “^”), 等于 (下次操作符, “/”), 等于 (下次操作符, “\”), 等于 (下次操作符, “%”)), 或者 (等于 (上次操作符, “>”), 等于 (上次操作符, “<”), 等于 (上次操作符, “=”), 等于 (上次操作符, “<>”), 等于 (上次操作符, “>=”), 等于 (上次操作符, “<=”), 等于 (上次操作符, “&&”), 等于 (上次操作符, “||”), 等于 (上次操作符, “+”), 等于 (上次操作符, “-”), 等于 (上次操作符, “&”))))
            赋值 (Val3, GetValue (Str1).取文本 ())
            赋值 (Val2, CompStr (Val2, 下次操作符, Val3).取文本 ())
            赋值 (Op2, ReadOp (Str1))
            
            赋值 (下次操作符, ReadChar (Str1))
            .如果 (IsOp (下次操作符))
                赋值 (下次操作符, 相加 (Op2, 下次操作符))
            .否则
                RetChar (Str1, 下次操作符)
                赋值 (下次操作符, Op2)
            .如果结束
            
            赋值 (优先, 真)
        .判断 (并且 (或者 (等于 (下次操作符, “+”), 等于 (下次操作符, “-”)), 或者 (等于 (上次操作符, “>”), 等于 (上次操作符, “<”), 等于 (上次操作符, “=”), 等于 (上次操作符, “<>”), 等于 (上次操作符, “>=”), 等于 (上次操作符, “<=”), 等于 (上次操作符, “&&”), 等于 (上次操作符, “||”), 等于 (上次操作符, “&”))))
            赋值 (Val3, GetValue (Str1).取文本 ())
            赋值 (Val2, CompStr (Val2, 下次操作符, Val3).取文本 ())
            赋值 (Op2, ReadOp (Str1))
            
            赋值 (下次操作符, ReadChar (Str1))
            .如果 (IsOp (下次操作符))
                赋值 (下次操作符, 相加 (Op2, 下次操作符))
            .否则
                RetChar (Str1, 下次操作符)
                赋值 (下次操作符, Op2)
            .如果结束
            赋值 (优先, 真)
            
        .判断 (并且 (或者 (等于 (下次操作符, “>”), 等于 (下次操作符, “<”), 等于 (下次操作符, “<>”), 等于 (下次操作符, “=”), 等于 (下次操作符, “>=”), 等于 (下次操作符, “<=”)), 或者 (等于 (上次操作符, “&&”), 等于 (上次操作符, “||”), 等于 (上次操作符, “&”))))
            赋值 (Val3, GetValue (Str1).取文本 ())
            赋值 (Val2, CompStr (Val2, 下次操作符, Val3).取文本 ())
            赋值 (Op2, ReadOp (Str1))
            
            赋值 (下次操作符, ReadChar (Str1))
            .如果 (IsOp (下次操作符))
                赋值 (下次操作符, 相加 (Op2, 下次操作符))
            .否则
                RetChar (Str1, 下次操作符)
                赋值 (下次操作符, Op2)
            .如果结束
            赋值 (优先, 真)
        .默认
            
        .判断结束
        
        .如果真 (不等于 (当前错误, “”))
            异常 (2, 当前错误)
            赋值 (当前错误, “”)
            返回 (NewVal)
        .如果真结束
        
        .如果真 (等于 (优先, 假))
            RetChar (Str1, 下次操作符)
            赋值 (下次操作符, “”)
            跳出循环 ()
        .如果真结束
        
        
    .判断循环尾 ()
    
    赋值 (NewVal, CompStr (NewVal.取文本 (), 上次操作符, Val2))
    
    .如果真 (不等于 (当前错误, “”))
        异常 (2, 当前错误)
        赋值 (当前错误, “”)
        返回 (NewVal)
    .如果真结束
    
    赋值 (Op1, ReadOp (Str1))
.判断循环尾 ()
返回 (NewVal)


.子程序 CompStr, 变体型, , 
.参数 Val1, 文本型, , 
.参数 Op, 文本型, , 
.参数 Val2, 文本型, , 
.参数 Op2, 文本型, 参考 可空, 

.局部变量 NewVal, 变体型, , , 

.判断开始 (等于 (Op, “-”))
    NewVal.赋值 (相减 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “+”))
    NewVal.赋值 (相加 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “*”))
    NewVal.赋值 (相乘 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “/”))
    .如果真 (等于 (到数值 (Val2), 0))
        赋值 (当前错误, “除数不能为于0”)
        返回 (NewVal)
    .如果真结束
    NewVal.赋值 (相除 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “&”))
    NewVal.赋值 (相加 (到文本 (Val1), 到文本 (Val2)), )
.判断 (等于 (Op, “>”))
    NewVal.赋值 (大于 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “=”))
    NewVal.赋值 (等于 (Val1, Val2), )
.判断 (等于 (Op, “<”))
    NewVal.赋值 (小于 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “\”))
    .如果真 (等于 (到数值 (Val2), 0))
        赋值 (当前错误, “不能求整除于0”)
        返回 (NewVal)
    .如果真结束
    NewVal.赋值 (整除 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “^”))
    NewVal.赋值 (求次方 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “>=”)) ' >= 运算
    NewVal.赋值 (大于或等于 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “<=”)) ' <= 运算符
    NewVal.赋值 (小于或等于 (到数值 (Val1), 到数值 (Val2)), )
.判断 (等于 (Op, “<>”)) ' <> 运算符
    NewVal.赋值 (不等于 (Val1, Val2), )
.判断 (等于 (Op, “&&”))
    NewVal.赋值 (并且 (不等于 (到数值 (Val1), 0), 不等于 (到数值 (Val2), 0)), )
.判断 (等于 (Op, “||”))
    NewVal.赋值 (或者 (不等于 (到数值 (Val1), 0), 不等于 (到数值 (Val2), 0)), )
.判断 (等于 (Op, “%”))
    .如果真 (等于 (到数值 (Val2), 0))
        赋值 (当前错误, “不能求整除于0”)
        返回 (NewVal)
    .如果真结束
    
    NewVal.赋值 (求余数 (到数值 (Val1), 到数值 (Val2)), )
    
.判断 (不等于 (Op, “”))
    赋值 (当前错误, 相加 (“当前不被支持的操作符:”, Op))
.默认
    
.判断结束


输出调试文本 (相加 (Val1, “ 和 ”, Val2, “　进行”, Op, “ 运算结果:”, NewVal.取文本 ()))

返回 (NewVal)


.子程序 执行代码段, 空白型, 公开, 
.参数 代码内容, 文本型, , 
.参数 过程名称, 文本型, 可空, 

.局部变量 e_pos, 空白型, , , 
.局部变量 n_pos, 空白型, , , 
.局部变量 h_pos, 空白型, , , 
.局部变量 i_pos, 空白型, , , 
.局部变量 I, 空白型, , , 
.局部变量 vLine, 文本型, 静态, "0", 
.局部变量 lVariableName, 文本型, , , 
.局部变量 lVariableType, 文本型, , , 
.局部变量 lVariableData, 变体型, , , 
.局部变量 sTemp1, 文本型, , , 
.局部变量 sTemp2, 文本型, , , 
.局部变量 Temp3, 文本型, , , 
.局部变量 TheToken, 文本型, , , 
.局部变量 sline, 文本型, , , 
.局部变量 nForln, 空白型, , , 
.局部变量 nLoop, 空白型, , , 
.局部变量 nLoopExpr, 文本型, , , 
.局部变量 nArrIndex, 空白型, , , 
.局部变量 IfSkip, 逻辑型, , , 
.局部变量 skip, 逻辑型, , , 
.局部变量 lVarNameLst, 文本型, , "0", 
.局部变量 TempI, 逻辑型, , , 
.局部变量 TempJ, 空白型, , , 
.局部变量 TempK, 空白型, , , 
.局部变量 sOldProc, 文本型, , , 
.局部变量 StrLineA, 文本型, , , 
.局部变量 临时变量, 变体型, , , 
.局部变量 变量定义语句, 逻辑型, , , 
.局部变量 OK, 空白型, , , 碰到Call 时 调用函数,是否为内置函数的标识
.局部变量 匿名局部变量_4897, 空白型, , , 
.局部变量 WHILE堆, 循环类, , , 2007-07-18
.局部变量 FOR堆, 循环类, , , 2007-07-18
.局部变量 For表达式, 文本型, , , 
.局部变量 For变量名, 文本型, , , 
.局部变量 For起始值, 文本型, , , 
.局部变量 For操作行, 文本型, , , 2007-8-6,如C语言的操作
.局部变量 匿名局部变量_4903, 空白型, , , 
.局部变量 IfThenPart, 文本型, , , 
.局部变量 IF堆, 判断类, , , 2007-07-18
.局部变量 又如, 整数型, , , 
.局部变量 匿名局部变量_4907, 空白型, , , 
.局部变量 m_SwitchLabel_A, 文本型, , , 
.局部变量 SWitch堆, 判断类, , , 2007-07-19
.局部变量 匿名局部变量_4910, 空白型, , , 
.局部变量 当前Break类型, 空白型, , , 1为switch,2为for,3,为while
.局部变量 strEnd, 文本型, , , 结束符
.局部变量 匿名局部变量_4913, 空白型, , , 
.局部变量 标签堆, 标签类, , , 2007-07-24

 ' 输出调试文本 (“ 当前执行:” ＋ 代码内容)

 ' .如果真 (并且 (等于 (当前过程, “”), 不等于 (过程名称, “”)))
     ' 当前过程 ＝ 过程名称
.如果真结束
 ' .如果真 (不等于 (当前过程, 过程名称))
     ' 当前过程 ＝ 过程名称
.如果真结束

赋值 (vLine, 分割文本 (代码内容, #换行符, ))
 ' I ＝ 1
 ' 易语言的计次循环,还真的是算好次数的不能在循环里更改计数值

.判断循环首 (小于或等于 (I, 取数组成员数 (vLine)))
    赋值 (I, 相加 (I, 1))
    
    .如果真 (大于 (I, 取数组成员数 (vLine)))
        跳出循环 ()
    .如果真结束
    
    赋值 (当前执行行, vLine [I])
    
    赋值 (变量定义语句, 假)
    赋值 (For表达式, “”)
    赋值 (For变量名, “”)
    赋值 (For起始值, “”)
    赋值 (For操作行, “”)
    
    .如果真 (不等于 (当前错误, “”))
        异常 (9, 当前错误)
        跳出循环 ()
    .如果真结束
    
    
    .判断开始 (等于 (当前状态, 1)) ' 暂停
        .判断循环首 (等于 (当前状态, 1))
            处理事件 ()
        .判断循环尾 ()
    .判断 (等于 (当前状态, 2))
        返回 ()
    .默认
        
    .判断结束
    
    赋值 (sline, 删首尾空 (RemoveBlanks (vLine [I])))
    .如果真 (小于或等于 (取文本长度 (sline), 0))
        到循环尾 ()
    .如果真结束
    
    .如果真 (ISBlank (取文本右边 (sline, 1)))
        赋值 (sline, 取文本左边 (sline, 相减 (取文本长度 (sline), 1)))
    .如果真结束
    
    .如果真 (或者 (等于 (到小写 (sline), “doevents;”), 等于 (到小写 (sline), “处理事件;”)))
        处理事件 ()
        到循环尾 ()
    .如果真结束
    
    .如果真 (或者 (等于 (到小写 (sline), “end if;”), 等于 (sline, “如果结束;”)))
        .如果真 (小于或等于 (IF堆.取出 (), 0))
            异常 (1, 相加 (“缺少　如果”, sline))
            跳出循环 ()
        .如果真结束
        IF堆.取出 (真) ' 出栈,本次判断结束
        赋值 (又如, 0)
        到循环尾 ()
    .如果真结束
    .如果真 (或者 (等于 (到小写 (sline), “else”), 等于 (sline, “否则”)))
        .如果真 (小于或等于 (IF堆.取出 (), 0))
            异常 (1, 相加 (“缺少　如果”, sline))
            跳出循环 ()
        .如果真结束
        
        IF堆.取出 (IfSkip)
        .如果 (等于 (IfSkip, 假)) ' 如果先前一个IF没有成功，那么这个就置为成功
            IF堆.置通过 (取反 (IfSkip))
        .否则
            赋值 (I, 到数值 (IF堆.取结束位置 ())) ' 否则此次的判断结束
        .如果结束
        到循环尾 ()
    .如果真结束
    
    .如果真 (大于 (IF堆.取出 (), 0)) ' 有判断＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
        IF堆.取出 (Temp3, IfSkip)
        .如果真 (等于 (IfSkip, 假))
            赋值 (I, 相减 (到数值 (Temp3), 1))
            到循环尾 ()
        .如果真结束
        
    .如果真结束
    
     ' ＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
    
    赋值 (StrLineA, 到小写 (sline))
    .判断开始 (或者 (等于 (StrLineA, “break;”), 等于 (StrLineA, “中断;”), 等于 (StrLineA, “continue;”), 等于 (StrLineA, “到循环尾;”), 等于 (StrLineA, “跳出循环;”)))
        .如果真 (并且 (等于 (当前Break类型, 1), 不等于 (StrLineA, “跳出循环;”))) ' switch
            SWitch堆.取出 (Temp3, , 真)
            .如果 (大于 (到数值 (Temp3), I))
                赋值 (I, 到数值 (Temp3))
                到循环尾 ()
            .否则
                跳出循环 ()
            .如果结束
            
        .如果真结束
        .如果真 (等于 (当前Break类型, 2)) ' for
            FOR堆.取出 (Temp3)
            .如果 (大于 (到数值 (Temp3), I))
                .如果 (或者 (等于 (StrLineA, “continue;”), 等于 (StrLineA, “到循环尾;”)))
                    赋值 (I, 相减 (到数值 (Temp3), 1))
                .否则
                    赋值 (I, 到数值 (Temp3))
                .如果结束
                
                到循环尾 ()
            .否则
                跳出循环 ()
            .如果结束
            
        .如果真结束
        .如果真 (等于 (当前Break类型, 3)) ' while
            WHILE堆.取出 (Temp3)
            .如果 (大于 (到数值 (Temp3), I))
                .如果 (或者 (等于 (StrLineA, “continue;”), 等于 (StrLineA, “到循环尾;”)))
                    赋值 (I, 相减 (到数值 (Temp3), 1))
                .否则
                    赋值 (I, 到数值 (Temp3))
                .如果结束
                赋值 (I, 到数值 (Temp3))
                到循环尾 ()
            .否则
                跳出循环 ()
            .如果结束
            
        .如果真结束
        返回 () ' 结整当前过程执行
        
    .判断 (或者 (等于 (StrLineA, “exit;”), 等于 (StrLineA, “结束;”)))
        跳出循环 ()
    .默认
        
    .判断结束
    
    .如果真 (大于 (标签堆.取数量 (), 0))
        .如果真 (并且 (大于 (标签堆.取标签索引 (sline), 0), 等于 (标签堆.取GOTO (), sline))) ' 标签语句
            标签堆.置GOTO (“”)
            到循环尾 ()
        .如果真结束
        
    .如果真结束
     ' ==============================================================================
    .如果真 (或者 (等于 (到小写 (sline), “end switch;”), 等于 (sline, “测试表达式结束;”)))
        .如果真 (等于 (SWitch堆.取出 (Temp3, , 真), -1))
            异常 (3, “没有＇测试表达式＇却找到了＇测试表达式结束＇命令”)
            跳出循环 ()
        .如果真结束
        到循环尾 ()
    .如果真结束
     ' ==============================================================================
    赋值 (TempJ, GetCharPos (sline, “:”))
    .如果真 (大于 (TempJ, 0))
        赋值 (sTemp1, 到小写 (取文本左边 (sline, TempJ)))
        赋值 (TempI, 或者 (等于 (到小写 (sTemp1), “case:”), 等于 (sTemp1, “测试结果:”)))
        .如果真 (TempI)
            .如果真 (小于或等于 (SWitch堆.取出 (Temp3, IfSkip), 0))
                异常 (1, 相加 (“不该出现的 ”, sline))
                跳出循环 ()
            .如果真结束
            
            .如果真 (IfSkip) ' 上次测试成功---那么直接结束本次测试表达式,将I的值置为 End Switch 位置
                赋值 (I, 到数值 (Temp3))
                到循环尾 ()
            .如果真结束
            
            赋值 (Temp3, sline)
            赋值 (Temp3, 删首尾空 (取文本右边 (Temp3, 相减 (取文本长度 (Temp3), 取文本长度 (sTemp1))))) ' 取得 case: 后的内容
             ' 这里要调用表达式计算
            赋值 (sTemp2, Temp3)
            .如果 (IsOp (取文本左边 (Temp3, 1), 1))
                赋值 (sTemp1, Temp3)
            .否则
                赋值 (sTemp1, 相加 (“=”, Temp3))
            .如果结束
            SWitch堆.取出 (Temp3)
            
            .如果 (或者 (等于 (sTemp2, “默认”), 等于 (sTemp1, “default”))) ' 这个不用测试了
                赋值 (IfSkip, 真)
            .否则
                赋值 (临时变量, GetExp (相加 (Temp3, sTemp1)))
                赋值 (IfSkip, 临时变量.取逻辑值 ()) ' 判断表达式是否成立
            .如果结束
            
            赋值 (TempJ, GetNextLine (vLine, 相加 (I, 1), “case|测试结果”, “switch|测试表达式”, “end switch;|测试表达式结束;”)) ' 不管本次测试有没通过,先取下一个Case的位置
            
            .如果真 (等于 (IfSkip, 假)) ' 下一个测试
                .如果真 (小于或等于 (TempJ, 0)) ' 没有下一个Case  了
                    SWitch堆.取出 (Temp3)
                    赋值 (TempJ, 到数值 (Temp3))
                .如果真结束
                赋值 (I, 相减 (TempJ, 1))
            .如果真结束
            
            SWitch堆.置通过 (IfSkip)
            到循环尾 ()
        .如果真结束
        
    .如果真结束
     ' ================================================================
    .如果真 (或者 (等于 (到小写 (sline), “next;”), 等于 (sline, “计次环尾;”)))
        FOR堆.取出 (For表达式, , , TempJ, , , For操作行)
        赋值 (For操作行, 删首尾空 (For操作行))
        
        .如果真 (大于 (取文本长度 (For操作行), 0)) ' 先执行FOR语句的操作句
            赋值 (For操作行, 相加 (For操作行, “;”))
            执行代码段 (For操作行) ' 操作FOR行语句
        .如果真结束
        
        赋值 (sline, For表达式)
        
        .如果 (或者 (不等于 (GetExp (sline).取数值 (), 0), 等于 (For表达式, “”))) ' ************************
            
            赋值 (I, 到数值 (TempJ)) ' 表达式为真，重新赋与I的值，达到循环的效果
        .否则
            FOR堆.取出 (真) ' 取出并清空
        .如果结束
        
        到循环尾 ()
        
    .如果真结束
     ' -==============================================================
    .如果真 (或者 (等于 (到小写 (sline), “loop;”), 等于 (sline, “判断环尾;”)))
        WHILE堆.取出 (For表达式, , , TempJ)
        
        .如果真 (或者 (等于 (For表达式, “”), 小于或等于 (TempJ, 0)))
            异常 (3, “判断循环缺少 表达式”)
            跳出循环 ()
        .如果真结束
        .如果 (GetExp (For表达式).取逻辑值 ())
            赋值 (I, TempJ)
        .否则
            WHILE堆.取出 (真)
            
        .如果结束
        到循环尾 ()
        
    .如果真结束
     ' =================================================================
    
    .判断开始 (或者 (等于 (取文本右边 (StrLineA, 3), “++;”), 等于 (取文本右边 (StrLineA, 3), “--;”)))
        赋值 (StrLineA, TidyLine (StrLineA))
        .如果 (变量赋值行 (StrLineA, 0, 取文本右边 (StrLineA, 2)))
            
        .否则
            赋值 (当前错误, 相加 (“找不到变量：”, StrLineA))
            
        .如果结束
        到循环尾 ()
    .默认
        
    .判断结束
    
     ' e_pos ＝ GetCharPos (sline, “ ”)
    赋值 (e_pos, GetKeyWord (sline)) ' 得到关键字位置
     ' 输出调试文本 (X取文本中间 (sline, 1, e_pos － 1))
    
     ' h_pos ＝ GetCharPos (sline, “.”)
    .如果真 (大于 (e_pos, 0))
        赋值 (TheToken, 到小写 (删首尾空 (取文本左边 (sline, 相减 (e_pos, 1)))))
        .判断开始 (或者 (等于 (TheToken, “redim”), 等于 (TheToken, “重定义数组”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            .如果 (Redim行 (sline))
                
            .否则
                异常 (1, “重定义数组 错误!”)
            .如果结束
            到循环尾 ()
            
            
        .判断 (或者 (等于 (TheToken, “return”), 等于 (TheToken, “返回”)))
            赋值 (sline, TidyLine (sline))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            赋值 (sReturnFromFunc, GetExp (sline))
            输出调试文本 (相加 (“sReturnFromFunc:”, sReturnFromFunc.取文本 ()))
            跳出循环 ()
            
        .判断 (或者 (等于 (TheToken, “const”), 等于 (TheToken, “常量”)))
            .如果真 (等于 (EolPos (sline), 0))
                异常 (5, “期待结束符 ';'”)
                跳出循环 ()
            .如果真结束
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            赋值 (TempJ, GetCharPos (sline, “=”))
            .如果真 (小于或等于 (TempJ, 0))
                异常 (1, “常量必须在定义时赋值”)
                跳出循环 ()
            .如果真结束
            赋值 (lVariableName, 删首尾空 (取文本中间 (sline, 1, 相减 (TempJ, 1))))
            赋值 (lVariableData, GetExp (删首尾空 (取文本中间 (sline, 相加 (TempJ, 1), 取文本长度 (sline)))))
            .如果真 (是否为关键字 (lVariableName))
                异常 (8, “关键字不能用作标识符”)
                跳出循环 ()
            .如果真结束
            变量堆.变量添加变量 (lVariableName, #字符型, 真, 过程名称)
            变量堆.变量赋值 (变量堆.取数量 (), lVariableData, 真)
            赋值 (lVariableName, “”)
            lVariableData.清除 ()
            赋值 (TempJ, 0)
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “call”), 等于 (TheToken, “调用过程”)))
            赋值 (Temp3, TidyLine (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            
            .如果真 (等于 (EolPos (sline), 0))
                异常 (5, “期待结束符 ';'”)
                跳出循环 ()
            .如果真结束
            赋值 (sline, “”)
            GetExp (Temp3)
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “destroy”), 等于 (TheToken, “清除数组”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            赋值 (TempJ, 变量堆.数组取变量索引 (sline))
            .如果 (小于或等于 (TempJ, 0))
                赋值 (TempJ, G数组取变量索引 (sline))
                .如果 (大于 (TempJ, 0))
                    G数组销毁数组 (TempJ)
                .否则
                    异常 (2, 相加 (“清除数组 语句,找不到变量名:”, sline))
                    跳出循环 ()
                .如果结束
                
            .否则
                变量堆.数组销毁数组 (TempJ)
            .如果结束
            
            赋值 (sline, “”)
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “msgbox”), 等于 (TheToken, “echo”), 等于 (TheToken, “信息框”)))
            .如果真 (等于 (EolPos (sline), 0))
                异常 (5, “期待结束符 ';'”)
                跳出循环 ()
            .如果真结束
            赋值 (sline, TidyLine (sline))
            GetExp (sline)
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “int”), 等于 (TheToken, “char”), 等于 (TheToken, “long”), 等于 (TheToken, “float”), 等于 (TheToken, “bool”), 等于 (TheToken, “短整型”), 等于 (TheToken, “长整型”), 等于 (TheToken, “字符型”), 等于 (TheToken, “浮点型”), 等于 (TheToken, “布尔型”)))
            赋值 (变量定义语句, 真)
            .如果真 (等于 (EolPos (sline), 0))
                异常 (5, “期待结束符 ';'”)
                跳出循环 ()
            .如果真结束
            赋值 (sline, TidyLine (sline))
            .如果 (变量堆.分析声明语句 (sline, e_pos, 过程名称))
                到循环尾 ()
            .否则
                跳出循环 ()
            .如果结束
            
            
        .判断 (或者 (等于 (TheToken, “enum”), 等于 (TheToken, “枚举”)))
            .如果真 (等于 (EolPos (sline), 0))
                异常 (5, “期待';'”)
                跳出循环 ()
            .如果真结束
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            .如果真 (等于 (DoEnum (sline, 变量堆), 假))
                跳出循环 ()
            .如果真结束
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “goto”), 等于 (TheToken, “跳到标签”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            赋值 (TempJ, 标签堆.取标签索引 (sline))
            标签堆.置GOTO (sline)
            
            .如果 (小于或等于 (TempJ, 0))
                赋值 (TempJ, GetGoto (vLine, sline))
                .如果真 (小于或等于 (TempJ, 0))
                    异常 (1, 相加 (“找不到标签”, sline))
                    返回 ()
                .如果真结束
                
            .否则
                
            .如果结束
            赋值 (I, 相减 (TempJ, 1))
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “switch”), 等于 (TheToken, “测试表达式”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            SWitch堆.压入 (sline, 到文本 (GetNextLine (vLine, 相加 (I, 1), “switch|测试表达式|6|10”, “end switch;|测试表达式结束;|11|15”)))
            赋值 (当前Break类型, 1)
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “if”), 等于 (TheToken, “如果”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            .如果真 (等于 (IF堆.分析IF判断 (sline, Temp3, IfThenPart, sTemp1), “”))
                跳出循环 ()
            .如果真结束
            赋值 (IfSkip, GetExp (Temp3).取逻辑值 ())
            
            .如果 (并且 (不等于 (IfThenPart, “goto”), 不等于 (IfThenPart, “跳到标签”)))
                赋值 (TempJ, GetNextLine (vLine, 相加 (I, 1), “else|否则”, “if|如果”, “end if;|如果结束;”)) ' ESLE　或　否则的对应位置
                赋值 (TempK, GetNextLine (vLine, 相加 (I, 1), “if|如果|2|4”, “end if;|如果结束;|7|9”)) ' 找　End if；或　如果结束；的位置
                
                .如果真 (小于或等于 (TempK, 0)) ' 没有与之对应的　如果结束
                    异常 (3, 相加 (“有”, TheToken, “，没有　＇End　If＇　或　＇如果结束＇”))
                    跳出循环 ()
                .如果真结束
                
                .如果真 (或者 (小于或等于 (TempJ, 0), 大于 (TempJ, TempK)))
                    赋值 (TempJ, TempK)
                .如果真结束
                
                IF堆.压入 (Temp3, 到文本 (TempJ), IfSkip, 到文本 (TempK))
                
                
                
            .否则
                .如果真 (IfSkip)
                    赋值 (TempJ, 标签堆.取标签索引 (sTemp1))
                    标签堆.置GOTO (sTemp1)
                    
                    .如果 (小于或等于 (TempJ, 0))
                        赋值 (TempJ, GetGoto (vLine, sTemp1))
                        .如果真 (小于或等于 (TempJ, 0))
                            异常 (1, 相加 (“找不到标签”, sTemp1))
                            返回 ()
                        .如果真结束
                        
                    .否则
                        
                    .如果结束
                    赋值 (I, 相减 (TempJ, 1)) ' 因为自动会加１,这样又转到标签语句了．使用这个可以清空当前GOTO
                    到循环尾 ()
                .如果真结束
                
            .如果结束
            
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “for”), 等于 (TheToken, “计次循环”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            .如果真 (等于 (FOR堆.分析For循环 (sline, For表达式, For变量名, For起始值, For操作行), 假))
                跳出循环 ()
            .如果真结束
            
            赋值 (TempJ, GetNextLine (vLine, 相加 (I, 1), “for|计次循环|3|4”, “next;|计次环尾;|5|5”))
            .如果真 (小于或等于 (TempJ, 0))
                异常 (3, “有计次循环，没有＇Next;＇　或 ＇计次环尾＇”)
                跳出循环 ()
            .如果真结束
            
            FOR堆.压入 (For表达式, For变量名, For起始值, I, 到文本 (TempJ), For操作行) ' 压入FOR堆里
            赋值 (当前Break类型, 2)
            赋值 (sline, For表达式)
            .如果 (或者 (不等于 (GetExp (sline).取数值 (), 0), 等于 (For表达式, “”))) ' For表达式不成立
                
            .否则
                赋值 (I, 相减 (TempJ, 1))
            .如果结束
            到循环尾 ()
            
        .判断 (或者 (等于 (TheToken, “while”), 等于 (TheToken, “判断循环”)))
            赋值 (sline, 删首尾空 (取文本右边 (sline, 相减 (取文本长度 (sline), 取文本长度 (TheToken)))))
            .如果真 (等于 (WHILE堆.分析While循环 (sline, For表达式), 假))
                跳出循环 ()
            .如果真结束
            赋值 (TempJ, GetNextLine (vLine, 相加 (I, 1), “while|判断循环|5|4”, “loop;|判断环尾;|5|5”))
            .如果真 (小于或等于 (TempJ, 0))
                异常 (3, “判断循环，没有＇loop;＇　或 ＇判断环尾＇”)
                跳出循环 ()
            .如果真结束
            赋值 (sTemp1, For表达式)
            .如果 (等于 (GetExp (sTemp1).取数值 (), 0))
                赋值 (I, TempJ)
            .否则
                WHILE堆.压入 (For表达式, , , I)
            .如果结束
            
            赋值 (当前Break类型, 3)
            到循环尾 ()
        .默认
            
        .判断结束
        
        
    .如果真结束
    
    .如果真 (或者 (等于 (sline, “”), 变量定义语句)) ' 判断是否为定义语句中的＂＝＂号
        到循环尾 ()
    .如果真结束
    
    赋值 (n_pos, GetCharPos (sline, “=”))
    .如果真 (大于 (n_pos, 0))
        赋值 (sline, TidyLine (sline))
        赋值 (sTemp1, 取文本中间 (sline, 相减 (n_pos, 1), 1))
        .如果 (或者 (等于 (sTemp1, “+”), 等于 (sTemp1, “-”), 等于 (sTemp1, “*”), 等于 (sTemp1, “/”), 等于 (sTemp1, “&”), 等于 (sTemp1, “%”), 等于 (sTemp1, “\”))) ' i+=d
            .如果 (变量赋值行 (sline, n_pos, 相加 (sTemp1, “=”)))
                
            .否则
                赋值 (当前错误, 相加 (“找不到变量：”, sline))
            .如果结束
            
        .否则
            .如果 (变量赋值行 (sline, n_pos))
                
            .否则
                赋值 (当前错误, 相加 (“找不到变量：”, sline))
            .如果结束
            
        .如果结束
        
        到循环尾 ()
        
        
    .如果真结束
    
    .如果真 (等于 (取文本右边 (sline, 1), “:”)) ' 标签定义
        标签堆.添加标签 (sline, I)
        到循环尾 ()
    .如果真结束
    .如果真 (并且 (不等于 (sline, “”), 等于 (取文本右边 (sline, 1), “;”))) ' 单独的行
        .如果真 (并且 (大于 (GetProcInfo (sline, 1).取数值 (), 0), 大于 (GetProcInfo (sline, 2).取数值 (), 0)))
            GetExp (TidyLine (sline))
            到循环尾 ()
        .如果真结束
        异常 (1, 相加 (“无效的语句:”, sline))
        
    .如果真结束
    
.判断循环尾 ()




 ' Clean up
赋值 (lVariableName, “”)
赋值 (lVariableName, “”)
赋值 (lVariableType, “”)
lVariableData.清除 ()

 ' <:-) Colon(s) Expanded
赋值 (sTemp1, “”)
赋值 (sTemp2, “”)
赋值 (TheToken, “”)
赋值 (sline, “”)
 ' <:-) Colon(s) Expanded
赋值 (nLoopExpr, “”)
赋值 (e_pos, 0)
赋值 (n_pos, 0)
赋值 (h_pos, 0)
赋值 (i_pos, 0)
赋值 (I, 0)
赋值 (nForln, 0)
赋值 (nLoop, 0)
 ' <:-) Colon(s) Expanded
清除数组 (vLine)

赋值 (TempJ, 0)

.子程序 Redim行, 逻辑型, , 
.参数 sLine, 文本型, 参考, 

.局部变量 sTemp1, 文本型, , , 
.局部变量 bool, 文本型, , , 
.局部变量 TempJ, 空白型, , , 
.局部变量 保留, 逻辑型, , , 
.局部变量 iPos, 空白型, , , 

赋值 (sLine, RemoveEol (sLine))

.如果真 (HasSqrBrackets (sLine))
    赋值 (sTemp1, GetExp (GetArrayInfo (sLine, 2).取文本 ()).取文本 ())
    赋值 (iPos, 倒找文本 (sLine, “,”, , 假))
    .如果真 (大于 (iPos, 0))
        赋值 (bool, 到小写 (删首尾空 (取文本右边 (sLine, 相减 (取文本长度 (sLine), iPos)))))
        赋值 (保留, 或者 (等于 (bool, “真”), 等于 (bool, “true”)))
    .如果真结束
    赋值 (sLine, GetArrayInfo (sLine, 1).取文本 ())
    赋值 (TempJ, 变量堆.数组取变量索引 (sLine))
    .如果 (小于或等于 (TempJ, 0))
        赋值 (TempJ, G数组取变量索引 (sLine))
        .如果真 (小于或等于 (TempJ, 0))
            返回 (假)
        .如果真结束
        G数组重定义尺寸 (TempJ, 到数值 (sTemp1), 保留)
    .否则
        变量堆.数组重定义尺寸 (TempJ, 到数值 (sTemp1), 保留)
    .如果结束
    
    
.如果真结束
返回 (真)


.子程序 GetGoto, 整数型, , 找到当前标记为GOTO标签的那一行
.参数 vLine, 文本型, 参考 数组, 
.参数 sGoto, 文本型, 参考, 

.局部变量 I, 空白型, , , 
.局部变量 sTrA, 文本型, , , 

.计次循环首 (取数组成员数 (vLine), I)
    赋值 (sTrA, RemoveBlanks (vLine [I]))
    .如果真 (等于 (到小写 (sTrA), 到小写 (sGoto)))
        返回 (I)
    .如果真结束
    
.计次循环尾 ()
返回 (0)


.子程序 GetNextLine, 整数型, , 找到对应的Block块结束位置
.参数 vLine, 文本型, 参考 数组, 
.参数 iPos, 整数型, , 当前行
.参数 strStart, 文本型, , 开始符
.参数 strEnd, 文本型, 可空, 结束符
.参数 strEndIt, 文本型, 可空, 

.局部变量 I, 空白型, , , 
.局部变量 e, 空白型, , , 
.局部变量 s, 文本型, , , 
.局部变量 strEndZ, 文本型, , "0", 
.局部变量 strStartZ, 文本型, , "0", 
.局部变量 strEndItZ, 文本型, , "0", 
.局部变量 H, 空白型, , , 

赋值 (e, 0)
赋值 (strEnd, 到小写 (strEnd))
赋值 (strStart, 到小写 (strStart))
.如果真 (等于 (是否为空 (strEndIt), 假))
    赋值 (strEndItZ, 分割文本 (strEndIt, “|”, ))
.如果真结束

.如果真 (等于 (是否为空 (strEnd), 假))
    赋值 (strEndZ, 分割文本 (strEnd, “|”, ))
.如果真结束

赋值 (strStartZ, 分割文本 (strStart, “|”, ))
.如果 (等于 (取数组成员数 (strStartZ), 2)) ' 寻找下一语句
    .变量循环首 (iPos, 取数组成员数 (vLine), 1, I)
        赋值 (s, 删首尾空 (RemoveSingleLineComment (RemoveBlanks (vLine [I]))))
        赋值 (H, GetKeyWord (s))
        .如果真 (大于 (H, 1))
            赋值 (s, 取文本左边 (s, 相减 (H, 1)))
            
        .如果真结束
        
        .如果 (或者 (等于 (s, strStartZ [1]), 等于 (s, strStartZ [2])))
            .如果真 (等于 (e, 0))
                返回 (I)
            .如果真结束
            
        .否则
            .如果真 (或者 (等于 (s, strEndZ [1]), 等于 (s, strEndZ [2])))
                赋值 (e, 相加 (e, 1))
            .如果真结束
            .如果真 (或者 (等于 (s, strEndItZ [1]), 等于 (s, strEndItZ [2])))
                赋值 (e, 相减 (e, 1))
            .如果真结束
            
        .如果结束
        
    .变量循环尾 ()
.否则
    
    
    
    
    赋值 (e, 1)
    .变量循环首 (iPos, 取数组成员数 (vLine), 1, I) ' 寻找下一语句并排除某句
        赋值 (s, RemoveSingleLineComment (RemoveBlanks (vLine [I])))
        
        .如果 (或者 (等于 (s, strEndZ [1]), 等于 (s, strEndZ [2])))
            赋值 (e, 相减 (e, 1))
        .否则
            .如果真 (或者 (等于 (取文本左边 (s, 到数值 (strStartZ [3])), strStartZ [1]), 等于 (取文本左边 (s, 到数值 (strStartZ [4])), strStartZ [2])))
                赋值 (e, 相加 (e, 1))
            .如果真结束
            
        .如果结束
        
        
        .如果真 (等于 (e, 0))
            返回 (I)
        .如果真结束
        
    .变量循环尾 ()
    返回 (0)
    
.如果结束

返回 (0)


.子程序 ReturnData, 变体型, , 
.参数 LookFor, 文本型, 参考, 

.局部变量 iTmp, 文本型, , , 
.局部变量 lTmp, 空白型, , , 
.局部变量 K, 空白型, , , 
.局部变量 StrTmp, 文本型, , , 
.局部变量 返回值, 变体型, , , 
.局部变量 临时变量, 变体型, , , 

赋值 (iTmp, 删首尾空 (LookFor))

.如果真 (等于 (取文本左边 (iTmp, 1), “$”)) ' 十六进制
    赋值 (iTmp, 取文本右边 (iTmp, 相减 (取文本长度 (iTmp), 1)))
    赋值 (LookFor, 相加 (“0x”, iTmp))
    返回值.赋值 (到数值 (iTmp), )
    返回 (返回值)
.如果真结束

赋值 (lTmp, 变量堆.数组取变量索引 (GetArrayInfo (iTmp, 1).取文本 ()))
.如果真 (并且 (HasSqrBrackets (iTmp), 大于 (lTmp, 0)))
    赋值 (K, GetArrayInfo (iTmp, 2).取数值 ()) ' 得到数组维数信息
    
    赋值 (返回值, 变量堆.数组取值 (lTmp, K))
    输出调试文本 (相加 (LookFor, “得到值”, “ ”, 返回值.取文本 ()))
    .如果 (等于 (变量堆.取类型 (lTmp, 真), #字符型))
        赋值 (当前类型, #文本型)
        .如果真 (等于 (取文本左边 (返回值.取文本 (), 1), 字符 (34)))
            返回值.赋值 (ReadChar (返回值.取文本 ()), )
        .如果真结束
        返回值.赋值 (ReadString (返回值.取文本 ()), )
        返回 (返回值)
    .否则
        返回 (返回值)
    .如果结束
    
    
.如果真结束
赋值 (lTmp, 变量堆.变量取变量索引 (iTmp))
.如果真 (大于 (lTmp, 0))
    赋值 (返回值, 变量堆.变量取值 (lTmp))
    .如果 (等于 (变量堆.取类型 (lTmp), #字符型))
        赋值 (当前类型, #文本型)
        .如果真 (等于 (取文本左边 (返回值.取文本 (), 1), 字符 (34)))
            返回值.赋值 (ReadChar (返回值.取文本 ()), )
        .如果真结束
        返回值.赋值 (ReadString (返回值.取文本 ()), )
    .否则
        
    .如果结束
    返回 (返回值)
.如果真结束


.如果真 (小于或等于 (lTmp, 0))
    赋值 (lTmp, G数组取变量索引 (GetArrayInfo (iTmp, 1).取文本 ()))
.如果真结束
.如果真 (并且 (HasSqrBrackets (iTmp), 大于 (lTmp, 0)))
    赋值 (K, GetArrayInfo (iTmp, 2).取数值 ())
    赋值 (返回值, G数组取值 (lTmp, K))
    输出调试文本 (相加 (LookFor, “得到值”, “ ”, 返回值.取文本 ()))
    .如果 (等于 (G取类型 (lTmp, 真), #字符型))
        赋值 (当前类型, #文本型)
        .如果真 (等于 (取文本左边 (返回值.取文本 (), 1), 字符 (34)))
            返回值.赋值 (ReadChar (返回值.取文本 ()), )
        .如果真结束
        返回值.赋值 (ReadString (返回值.取文本 ()), )
    .否则
        
    .如果结束
    返回 (返回值)
.如果真结束

.如果真 (小于或等于 (lTmp, 0))
    赋值 (lTmp, G变量取变量索引 (iTmp, 当前过程))
.如果真结束
.如果真 (大于 (lTmp, 0))
    赋值 (返回值, G变量取值 (lTmp))
    输出调试文本 (相加 (LookFor, “得到值”, “ ”, 返回值.取文本 ()))
    .如果 (等于 (G取类型 (lTmp), #字符型))
        赋值 (当前类型, #文本型)
        .如果真 (等于 (取文本左边 (返回值.取文本 (), 1), 字符 (34)))
            返回值.赋值 (ReadChar (返回值.取文本 ()), )
        .如果真结束
        返回值.赋值 (ReadString (返回值.取文本 ()), )
    .否则
        
    .如果结束
    返回 (返回值)
.如果真结束


.如果 (等于 (取文本左边 (iTmp, 1), “-”))
    赋值 (StrTmp, 删首尾空 (取文本右边 (iTmp, 相减 (取文本长度 (LookFor), 1))))
.否则
    赋值 (StrTmp, 删首尾空 (iTmp))
.如果结束

.如果 (是否为数字 (StrTmp))
    输出调试文本 (相加 (“得到数字:”, iTmp))
    返回值.赋值 (到数值 (iTmp), )
.否则
    异常 (2, 相加 (“找不到标识符：”, StrTmp))
    返回值.清除 ()
.如果结束

返回 (返回值)

.子程序 变量赋值行, 逻辑型, 公开, 
.参数 sline, 文本型, 参考, 
.参数 n_pos, 整数型, , 
.参数 加加, 文本型, 参考 可空, 

.局部变量 lVariableName, 文本型, , , 
.局部变量 TempJ, 整数型, , , 
.局部变量 lVariableData, 变体型, , , 
.局部变量 nArrindex, 整数型, , , 
.局部变量 临时变量, 变体型, , , 

赋值 (sline, TidyLine (sline))
.如果 (或者 (不等于 (加加, “”), 小于或等于 (n_pos, 0)))
    .如果 (或者 (等于 (加加, “++”), 等于 (加加, “--”)))
        赋值 (lVariableName, 删首尾空 (取文本左边 (sline, 相减 (取文本长度 (sline), 2))))
    .否则
        .如果 (大于 (寻找文本 (加加, “=”, , 假), 0))
            赋值 (lVariableName, 到小写 (删首尾空 (取文本左边 (sline, 相减 (n_pos, 2)))))
        .否则
            赋值 (lVariableName, 到小写 (删首尾空 (取文本中间 (sline, 1, 相减 (n_pos, 1)))))
        .如果结束
        
    .如果结束
    
.否则
    赋值 (lVariableName, 到小写 (删首尾空 (取文本中间 (sline, 1, 相减 (n_pos, 1)))))
    
.如果结束

.如果真 (HasSqrBrackets (lVariableName))
    赋值 (lVariableName, GetArrayInfo (lVariableName, 1).取文本 ())
    
.如果真结束

.如果 (不等于 (加加, “”))
    
.否则
    赋值 (lVariableData, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
    输出调试文本 (相加 (“变量赋值:”, lVariableData.取文本 ()))
    
.如果结束

赋值 (TempJ, 变量堆.数组取变量索引 (lVariableName))
.如果真 (大于 (TempJ, 0)) ' 本地数组型变量优先
    赋值 (nArrindex, GetExp (GetArrayInfo (sline, 2).取文本 ()).取数值 ())
    .判断开始 (等于 (加加, “++”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相加 (lVariableData.取数值 (), 1), )
    .判断 (等于 (加加, “--”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相减 (lVariableData.取数值 (), 1), )
    .判断 (等于 (加加, “+=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相加 (lVariableData.取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “-=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相减 (lVariableData.取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “*=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相乘 (lVariableData.取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “/=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “被除数不能为0”)
            返回 (真)
        .如果真结束
        lVariableData.赋值 (相除 (lVariableData.取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “&=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相加 (lVariableData.取文本 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取文本 ()), )
    .判断 (等于 (加加, “%=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能求余数于0”)
            返回 (真)
        .如果真结束
        lVariableData.赋值 (求余数 (lVariableData.取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “\=”))
        赋值 (lVariableData, 变量堆.数组取值 (TempJ, nArrindex))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能整除于0”)
            返回 (真)
        .如果真结束
        lVariableData.赋值 (整除 (lVariableData.取数值 (), 临时变量.取数值 ()), )
    .默认
        
    .判断结束
    .如果 (小于或等于 (nArrindex, 0))
        变量堆.数组销毁数组 (TempJ)
        变量堆.数组重定义尺寸 (TempJ, lVariableData.取数组成员数 ())
        .计次循环首 (lVariableData.取数组成员数 (), nArrindex)
            临时变量.赋值 (lVariableData.取文本 (nArrindex), )
            变量堆.数组赋值 (TempJ, nArrindex, 临时变量)
        .计次循环尾 ()
    .否则
        变量堆.数组赋值 (TempJ, nArrindex, lVariableData) ' 前面已经计算过表达式的值　了
    .如果结束
    返回 (真)
.如果真结束

赋值 (TempJ, 变量堆.变量取变量索引 (lVariableName))
.如果真 (大于 (TempJ, 0)) ' 本地变量优先
    .判断开始 (等于 (加加, “++”))
        lVariableData.赋值 (相加 (变量堆.变量取值 (TempJ).取数值 (), 1), )
    .判断 (等于 (加加, “--”))
        lVariableData.赋值 (相减 (变量堆.变量取值 (TempJ).取数值 (), 1), )
    .判断 (等于 (加加, “+=”))
        lVariableData.赋值 (相加 (变量堆.变量取值 (TempJ).取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “-=”))
        lVariableData.赋值 (相减 (变量堆.变量取值 (TempJ).取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “*=”))
        lVariableData.赋值 (相乘 (变量堆.变量取值 (TempJ).取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “/=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “被除数不能为0”)
            返回 (真)
        .如果真结束
        lVariableData.赋值 (相除 (变量堆.变量取值 (TempJ).取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “&=”))
        lVariableData.赋值 (相加 (变量堆.变量取值 (TempJ).取文本 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取文本 ()), )
    .判断 (等于 (加加, “%=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能求余数于0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (求余数 (变量堆.变量取值 (TempJ).取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “\=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能整除于0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (整除 (变量堆.变量取值 (TempJ).取数值 (), 临时变量.取数值 ()), )
    .默认
        
    .判断结束
     ' 输出调试文本 (“赋值给变量：” ＋ lVariableName ＋ “　值：” ＋ lVariableData.取文本 ())
    变量堆.变量赋值 (TempJ, lVariableData)
    返回 (真)
.如果真结束

赋值 (TempJ, G数组取变量索引 (lVariableName))
.如果真 (大于 (TempJ, 0)) ' 全局数组型变量优先
    赋值 (nArrindex, GetExp (GetArrayInfo (sline, 2).取文本 ()).取数值 ())
    .判断开始 (等于 (加加, “++”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相加 (lVariableData.取数值 (), 1), )
    .判断 (等于 (加加, “--”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相减 (lVariableData.取数值 (), 1), )
    .判断 (等于 (加加, “+=”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相加 (lVariableData.取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “-=”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相减 (lVariableData.取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “*=”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相乘 (lVariableData.取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “/=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “被除数不能为0”)
            返回 (真)
        .如果真结束
        
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相除 (lVariableData.取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “&=”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        lVariableData.赋值 (相加 (lVariableData.取文本 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取文本 ()), )
    .判断 (等于 (加加, “%=”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能求余数于0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (求余数 (lVariableData.取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “\=”))
        赋值 (lVariableData, G数组取值 (TempJ, nArrindex))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能整除于0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (整除 (lVariableData.取数值 (), 临时变量.取数值 ()), )
    .默认
        
    .判断结束
    
    .如果 (小于或等于 (nArrindex, 0))
        变量堆.数组销毁数组 (TempJ)
        变量堆.数组重定义尺寸 (TempJ, lVariableData.取数组成员数 ())
        .计次循环首 (lVariableData.取数组成员数 (), nArrindex)
            临时变量.赋值 (lVariableData.取文本 (nArrindex), )
            变量堆.数组赋值 (TempJ, nArrindex, 临时变量)
        .计次循环尾 ()
    .否则
        变量堆.数组赋值 (TempJ, nArrindex, lVariableData) ' 前面已经计算过表达式的值　了
    .如果结束
    
    返回 (真)
.如果真结束

赋值 (TempJ, G变量取变量索引 (lVariableName))
.如果真 (大于 (TempJ, 0)) ' 全局变量最后优先
    .判断开始 (等于 (加加, “++”))
        lVariableData.赋值 (相加 (G变量取值 (TempJ).取数值 (), 1), )
    .判断 (等于 (加加, “--”))
        lVariableData.赋值 (相减 (G变量取值 (TempJ).取数值 (), 1), )
    .判断 (等于 (加加, “+=”))
        lVariableData.赋值 (相加 (G变量取值 (TempJ).取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “-=”))
        lVariableData.赋值 (相减 (G变量取值 (TempJ).取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “*=”))
        lVariableData.赋值 (相乘 (G变量取值 (TempJ).取数值 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取数值 ()), )
    .判断 (等于 (加加, “/=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “被除数不能为0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (相除 (G变量取值 (TempJ).取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “&=”))
        lVariableData.赋值 (相加 (G变量取值 (TempJ).取文本 (), GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))).取文本 ()), )
    .判断 (等于 (加加, “%=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能求余数于0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (求余数 (G变量取值 (TempJ).取数值 (), 临时变量.取数值 ()), )
    .判断 (等于 (加加, “\=”))
        赋值 (临时变量, GetExp (删首尾空 (取文本中间 (sline, 相加 (n_pos, 1), 取文本长度 (sline)))))
        .如果真 (等于 (临时变量.取数值 (), 0))
            异常 (1, “不能整除于0”)
            返回 (真)
        .如果真结束
        
        lVariableData.赋值 (整除 (G变量取值 (TempJ).取数值 (), 临时变量.取数值 ()), )
    .默认
        
    .判断结束
     ' 输出调试文本 (“赋值给变量：” ＋ lVariableName ＋ “　值：” ＋ lVariableData.取文本 ())
    G变量赋值 (TempJ, lVariableData)
    返回 (真)
.如果真结束
返回 (假)


.类模块 类变量集, , , 

.程序集变量 匿名程序集变量_5054, 空白型, , , 
.程序集变量 变量集, 变量类型, , "0", 保存脚本中的所有变量的数组
.程序集变量 数组变量集, 数组类型, , "0", 保存脚本中的所有数组变量的数组
.程序集变量 变量数量, 整数型, , , 变量的总数
.程序集变量 数组变量数量, 整数型, , , 数组变量的总数
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用



.子程序 Dump, 文本型, 公开, 
.局部变量 l, 空白型, , , 
.局部变量 a, 文本型, , , 

赋值 (a, GDump ())

.变量循环首 (1, 变量数量, 1, l)
    赋值 (a, 相加 (a, “变量:”, 变量集 [l], 名称, “ 值: ”, 变量集.取文本 ( [l], 值, ), #换行符))
.变量循环尾 ()

.计次循环首 (数组变量数量, l)
    赋值 (a, 相加 (a, “数组变量[”, 数组变量集 [l], 名称, “] 值:”, 数组变量集.Dump ( [l], 值)))
.计次循环尾 ()

输出调试文本 (a)
返回 (a)

.子程序 取数量, 整数型, 公开, 
返回 (变量数量)

.子程序 取数组数量, 整数型, , 
返回 (数组变量数量)


.子程序 变量取值, 变体型, 公开, 
.参数 索引, 空白型, , 



 ' 输出调试文本 (“取变量：” ＋ 变量集 [索引].值.取文本 ())

返回 (变量集 [索引], 值)

.子程序 变量赋值, 空白型, 公开, 
.参数 索引, 空白型, , 
.参数 值, 变体型, , 
.参数 内置, 逻辑型, 可空, 

.如果真 (并且 (变量集 [索引], 只读, 等于 (内置, 假)))
    异常 (2, “不能给常量赋值”)
    返回 ()
.如果真结束
赋值 (变量集 [索引], 值, 值)
 ' 输出调试文本 (“给变量：” ＋ 值.取文本 ())


.子程序 变量类型的默认值, 变体型, , 
.参数 变量类型, 整数型, , 

.局部变量 临时变量, 变体型, , , 

.判断开始 (等于 (变量类型, #短整型))
    临时变量.赋值 (0, )
.判断 (等于 (变量类型, #长整型))
    临时变量.赋值 (0, )
.判断 (等于 (变量类型, #浮点型))
    临时变量.赋值 (0, )
.判断 (等于 (变量类型, #字符型))
    临时变量.赋值 (“”, )
.判断 (等于 (变量类型, #布尔型))
    临时变量.赋值 (假, )
.判断 (等于 (变量类型, #未知类型))
    临时变量.赋值 (“”, )
.默认
    
.判断结束
返回 (临时变量)

.子程序 变量是否为数组, 逻辑型, , 
.参数 变量名, 文本型, , 
.参数 过程名称, 文本型, 可空, 

.局部变量 索引, 空白型, , , 

赋值 (索引, 数组取变量索引 (变量名, 过程名称))
.如果真 (大于 (索引, 0))
    返回 (真)
.如果真结束
返回 (假)

.子程序 变量添加变量, 整数型, 公开, 
.参数 变量名, 文本型, , 
.参数 变量类型, 整数型, , 
.参数 是否只读, 逻辑型, , 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 i, 空白型, , , 

赋值 (i, 变量取变量索引 (变量名, 过程名称))
.如果真 (大于 (i, 0))
    返回 (i)
.如果真结束

赋值 (变量数量, 相加 (变量数量, 1))
重定义数组 (变量集, 真, 变量数量)
赋值 (变量集 [变量数量], 名称, 变量名)
赋值 (变量集 [变量数量], 类型, 变量类型)
赋值 (变量集 [变量数量], 只读, 是否只读)
赋值 (变量集 [变量数量], 过程, 过程名称)
变量集.赋值 ( [变量数量], 值, 变量类型的默认值 (变量类型), )
输出调试文本 (相加 (“添加变量:”, 变量名, “ 在过程:”, 过程名称))

 ' .如果真 (等于 (变量名, “gy”))
     ' 暂停 ()
    
.如果真结束
返回 (变量数量)

.子程序 变量取变量索引, 整数型, , 
.参数 变量名, 文本型, , 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 计数, 整数型, , , 

 ' 置错误提示管理 (&查找出错)
.如果真 (等于 (变量数量, 0))
    返回 (0)
.如果真结束
.计次循环首 (变量数量, 计数)
    .如果真 (等于 (到小写 (变量集 [计数], 名称), 到小写 (变量名)))
        .如果 (并且 (大于 (取文本长度 (过程名称), 0), 大于 (取文本长度 (变量集 [计数], 过程), 0)))
            .如果真 (等于 (到小写 (变量集 [计数], 过程), 到小写 (过程名称)))
                返回 (计数)
            .如果真结束
            
        .否则
            返回 (计数)
        .如果结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (0)

.子程序 分析声明语句, 逻辑型, 公开, 
.参数 sLine, 文本型, 参考, 
.参数 e_pos, 空白型, 可空, 
.参数 过程名称, 文本型, 参考 可空, 

.局部变量 TempJ, 空白型, , , 
.局部变量 TempK, 空白型, , , 
.局部变量 lVariableType, 文本型, , , 
.局部变量 lVariableName, 文本型, , , 
.局部变量 lVarNameLst, 文本型, , "0", 
.局部变量 lVariableData, 变体型, , , 
.局部变量 sTemp, 文本型, , , 
.局部变量 S, 文本型, , , 
.局部变量 S1, 文本型, , , 
.局部变量 多, 逻辑型, , , 

赋值 (sLine, TidyLine (sLine))
.如果真 (小于或等于 (e_pos, 0))
    赋值 (e_pos, GetKeyWord (sLine, 真))
    .如果真 (小于或等于 (e_pos, 0))
        返回 (假)
    .如果真结束
    
.如果真结束

赋值 (lVariableType, 到小写 (删首尾空 (取文本左边 (sLine, 相减 (e_pos, 1)))))
.如果真 (等于 (是否为关键字 (lVariableType, 真), 假)) ' 非定义语句
    返回 (假)
.如果真结束

赋值 (lVariableName, 删首尾空 (取文本中间 (sLine, 相加 (e_pos, 1), 取文本长度 (sLine)))) ' 取 int  后的一段
 ' lVarNameLst ＝ 分割文本 (lVariableName, “,”, )
赋值 (sTemp, lVariableName)

.判断循环首 (不等于 (sTemp, “”))
    赋值 (S, “”)
    赋值 (多, 假)
    赋值 (S, G当前执行类模块.GetValue (sTemp, 真).取文本 ())
    .如果 (并且 (等于 (S, “”), 多))
        异常 (1, 相加 (sLine, “ 存在无效的逗号”))
        返回 (假)
    .否则
        .如果真 (等于 (S, “”))
            跳出循环 ()
        .如果真结束
        
    .如果结束
    
    
    赋值 (S1, ReadChar (sTemp))
    .如果 (等于 (S1, “=”))
        .如果真 (HasSqrBrackets (S)) ' 数组不支持声明明赋值
            异常 (1, 相加 (sLine, “ 数组变量不支持声明时赋值!”))
            返回 (假)
        .如果真结束
        .如果 (或者 (等于 (lVariableType, “字符型”), 等于 (lVariableType, “char”)))
            赋值 (S, 相加 (S, “=”, 置双引号 (G当前执行类模块.GetExp (sTemp).取文本 (), 真)))
        .否则
            赋值 (S, 相加 (S, “=”, G当前执行类模块.GetExp (sTemp).取文本 ()))
        .如果结束
        
    .否则
        RetChar (sTemp, S1)
    .如果结束
    
    
    .如果 (等于 (取数组成员数 (lVarNameLst), 0))
        重定义数组 (lVarNameLst, 真, 1)
    .否则
        重定义数组 (lVarNameLst, 真, 相加 (取数组成员数 (lVarNameLst), 1))
    .如果结束
    赋值 (lVarNameLst [取数组成员数 (lVarNameLst)], S)
    赋值 (S1, ReadChar (sTemp))
    .如果 (不等于 (S1, “,”))
        RetChar (sTemp, S1)
        跳出循环 ()
    .否则
        
    .如果结束
    
    
.判断循环尾 ()



.计次循环首 (取数组成员数 (lVarNameLst), TempK)
    赋值 (lVariableName, 删首尾空 (lVarNameLst [TempK]))
    赋值 (TempJ, GetCharPos (lVariableName, “=”))
    .如果真 (大于 (TempJ, 0))
        赋值 (sTemp, 取文本右边 (lVariableName, 相减 (取文本长度 (lVariableName), TempJ)))
        .如果 (或者 (等于 (lVariableType, “字符型”), 等于 (lVariableType, “char”)))
            lVariableData.赋值 (置双引号 (删首尾空 (sTemp), 假), )
        .否则
            赋值 (lVariableData, G当前执行类模块.GetExp (删首尾空 (sTemp)))
        .如果结束
        
        赋值 (lVariableName, 删尾空 (取文本中间 (lVariableName, 1, 相减 (TempJ, 1))))
        .如果真 (是否为关键字 (lVariableName))
            返回 (假)
        .如果真结束
        .如果真 (等于 (变量添加变量 (lVariableName, 变量名称到类型 (lVariableType), 假, 过程名称), 0))
            返回 (假)
        .如果真结束
        变量赋值 (变量数量, lVariableData)
        输出调试文本 (相加 (“定义变量：”, lVariableName, “　值：　”, lVariableData.取文本 ()))
        
        赋值 (sLine, “”)
        到循环尾 ()
        
    .如果真结束
    .如果 (HasSqrBrackets (lVariableName))
        赋值 (sTemp, GetArrayInfo (lVariableName, 1).取文本 ())
        赋值 (TempJ, GetArrayInfo (lVariableName, 2).取数值 ())
        数组添加变量 (sTemp, 变量名称到类型 (lVariableType), TempJ, 过程名称)
    .否则
        .如果真 (是否为关键字 (lVariableName))
            返回 (假)
        .如果真结束
        .如果真 (等于 (变量添加变量 (lVariableName, 变量名称到类型 (lVariableType), 假, 过程名称), 0))
            返回 (假)
        .如果真结束
        
    .如果结束
    lVariableData.清除 ()
    赋值 (lVariableName, “”)
    赋值 (TempJ, 0)
    
.计次循环尾 ()
返回 (真)

.子程序 数组取变量索引, 整数型, , 
.参数 变量名, 文本型, , 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 计数, 整数型, , , 

.如果真 (等于 (数组变量数量, 0))
    返回 (0)
.如果真结束
.计次循环首 (数组变量数量, 计数)
    .如果真 (等于 (到小写 (数组变量集 [计数], 名称), 到小写 (变量名)))
        .如果 (并且 (大于 (取文本长度 (过程名称), 0), 大于 (取文本长度 (数组变量集 [计数], 过程), 0)))
            .如果真 (等于 (到小写 (数组变量集 [计数], 过程), 到小写 (过程名称)))
                返回 (计数)
            .如果真结束
            
        .否则
            返回 (计数)
        .如果结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (0)

.子程序 数组取值, 变体型, 公开, 
.参数 索引, 空白型, , 
.参数 值索引, 空白型, , 

.局部变量 临时变量, 变体型, , , 
.局部变量 匿名局部变量_7855, 空白型, , , 

置错误提示管理 (&索引出错)
.如果真 (大于 (索引, 0))
    返回 (数组变量集.取值 ( [索引], 值, 值索引))
.如果真结束
返回 (临时变量)


.子程序 数组赋值, 空白型, 公开, 
.参数 索引, 空白型, , 
.参数 值索引, 空白型, , 
.参数 值, 变体型, , 

.如果真 (小于或等于 (索引, 0))
    异常 (4, “索引超出下标”)
    返回 ()
.如果真结束

数组变量集.设值 ( [索引], 值, 值索引, 值)

.子程序 数组重定义尺寸, 空白型, 公开, 
.参数 索引, 空白型, , 
.参数 大小, 空白型, , 
.参数 保留, 逻辑型, 可空, 

数组变量集.重定义大小 ( [索引], 值, 大小, 保留)

.子程序 数组添加变量, 整数型, 公开, 用户声明了变量数组，应该调用此程序分配内存
.参数 变量名, 文本型, , 
.参数 变量类型, 整数型, , 
.参数 变量尺寸, 空白型, 可空, 
.参数 过程名称, 文本型, 可空, 查询变量索引时参考过程名 这样可用局部变量

.局部变量 计数, 空白型, , , 

.如果真 (大于 (数组取变量索引 (变量名, 过程名称), 0))
    返回 (0)
.如果真结束

赋值 (数组变量数量, 相加 (数组变量数量, 1))
重定义数组 (数组变量集, 真, 数组变量数量)
赋值 (数组变量集 [数组变量数量], 名称, 变量名)
赋值 (数组变量集 [数组变量数量], 类型, 变量类型)
赋值 (数组变量集 [数组变量数量], 过程, 过程名称)
.如果真 (大于 (变量尺寸, 0))
    数组变量集.重定义大小 ( [数组变量数量], 值, 变量尺寸, 假)
.如果真结束
返回 (数组变量数量)

.子程序 数组取上标, 整数型, 公开, 
.参数 索引, 空白型, , 

返回 (数组变量集.取数量 ( [索引], 值))

.子程序 数组销毁数组, 空白型, 公开, 
.参数 索引, 空白型, , 

.如果真 (小于或等于 (索引, 0))
    异常 (4, “索引超出下标”)
    返回 ()
.如果真结束
数组变量集.清除所有 ( [索引], 值)

.子程序 取类型, 整数型, 公开, 
.参数 索引, 空白型, , 
.参数 是否数组, 逻辑型, 可空, 

.如果 (是否数组)
    返回 (数组变量集 [索引], 类型)
.否则
    返回 (变量集 [索引], 类型)
.如果结束



.程序集 __HIDDEN_TEMP_MOD__, , , 

.子程序 X取文本长度, 整数型, , 取出中英文数字混合的可见长度，如“我爱China”结果为 7,一个汉字记一个长度
.参数 Expresstion, 文本型, , 



.子程序 X取文本中间, 文本型, , 易的“取文本中间”命令替代物，如 X取文本中间("我爱China",2,3) 结果为 "爱Ch"
.参数 Expresstion, 文本型, , 要操作的表达式
.参数 X开始位置, 整数型, , 开始的位置
.参数 X长度, 整数型, 可空, 取出的长度



.子程序 X取文本左边, 文本型, , 易的“取文本左边”命令替代物，如 X取文本左边("我爱China",6) 结果为 "我爱Chin"
.参数 Expression, 文本型, , 要操作的文本
.参数 X长度, 整数型, , 要取出的长度



.子程序 X取文本右边, 文本型, , 易的“取文本右边”命令替代物，如 X取文本右边("我爱China",6) 结果为 "爱China"
.参数 Expression, 文本型, , 表达式，要操作的文本
.参数 X长度, 整数型, , 要取的长度



.子程序 X寻找文本, 整数型, , 易的“取寻找文本”命令替代物，如 X寻找文本("我爱China","C") 结果为 3 而用易的命令结果为 5
.参数 要操作的文本, 文本型, , 
.参数 要找的文本, 文本型, , 
.参数 起始位置, 整数型, 可空, 
.参数 区分大小写, 逻辑型, 可空, 



.子程序 X子文本替换, 文本型, , 
.参数 要操作的文本, 文本型, , 
.参数 要被替换的文本, 文本型, , 
.参数 用作替换的文本, 文本型, 可空, 
.参数 替换次数, 整数型, 可空, 
.参数 区分大小写, 逻辑型, 可空, 



.子程序 X文本替换, 文本型, , 易的“文本替换”命令的替代物，如 X文本替换("我爱China",2,3,"你") 结果为 "我你ina"
.参数 要操作的文本, 文本型, , 
.参数 起始位置, 整数型, , 
.参数 替换长度, 整数型, , 
.参数 用作替换的文本, 文本型, 可空, 



.子程序 X去除重复文本, 文本型, , 
.参数 Expression, 文本型, , 
.参数 分隔符, 文本型, 可空, 




 ' 不属于任何一个程序集、类模块的函数：
