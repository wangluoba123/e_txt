 ' 文件类型：未知类型

 ' 程序名称：鱼刺类_多线程应用
 ' 程序描述：参照了很多代码

*子程序 为 面向过程 调用。
*类 为 面向对象 调用。
@备注:
对细节的控制已经很严格了。
如果依然存在BUG请联系我，非常感谢。
 ' 程序作者：易语言
 ' 邮政编码：
 ' 联系地址：本源码来自易语言资源网(www.5A5X.com)
 ' 联系电话：
 ' 传真号码：
 ' 电子信箱：
 ' 主页地址：www.5A5X.com
 ' 版权声明：             易语言资源网注意事项
--============   www.5A5X.com  =============--
* 易语言资源网为易语言官方站、易语言官方论坛提供辅助资源站；本易语言资源网( www.5A5X.com)所有软件和资料均为软件作者提供和网友推荐发布而来，其版权归该软件和程序源码的合法拥有者所有，本站易语言资源网整理收集仅供易语言用户学习和易语言技术研究探讨使用，不得用于任何商业用途。如果由于以上原因造成的版权纠纷本站概不负责！
* 本站资源未经许可,任何网站不得非法盗链及抄袭本站资源；如引用，请注明来自易语言资源网，谢谢合作！
--============   www.5A5X.com  =============--
 ' 版本号：5.1
 ' 创建号：0.1



.常量 注释, "“★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★
* ★XTTTTTTTTTTTTTTTTTTTTTTTTTTTT[★
* ★U模块名称：鱼刺类_多线程应用     版本：v5.1              U★
* ★U模块作者：(Bints)鱼刺-魔力无限  QQ号：521573            U★
* ★U版权所有：逆向思维工作室        QQ群：87555687          U★
* ★U作者小站：www.nixsw.com         Emal：Bints@vip.qq.com  U★
* ★^TTTTTTTTTTTTTTTTTTTTTTTTTTTTa★
* ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★”", , 
.常量 更新日志, "“鱼刺类_多线程应用 - 更新日志

5.1.0(2015-10-11)
*完成端口 增加完成端口面向过程
*线程操作 线程_创建 增加返回线程ID
*线程操作 增加投递信息A/W 利用线程消息队列可以做一些事情哦
*鱼刺类_线程操作 增加 取ID 可取回线程ID
*鱼刺类_线程操作 增加投递信息A/W
*鱼刺类_线程池_自销毁 增加新线程池方案。此方案特点无需销毁。(空闲超时自动销毁)
*DLL命令增加(_获取消息)函数 方便配合线程投递消息的接收

5.0.4(2015-02-24)
*鱼刺类_队列 优化释放了过程

5.0.3(2014-11-18)
*鱼刺类_队列 兼容了压入空数据(之前无法压入空数据)

5.0.2(2014-10-17)
*鱼刺类_线程池Ex 去除了暂停方法的参数
*鱼刺类_线程池Ex 修正方法创建的一处隐患
*线程池Ex 同步类更新

5.0.1(2014-9-11)
*鱼刺类_线程池Ex 修正在某些不规范使用 暂停() 方法的情况下会造成无法销毁的问题
*线程池Ex 修正在某些不规范使用 暂停() 函数的情况下会造成无法销毁的问题
*鱼刺类_读写锁 优化写锁定过程
*读写锁 优化写锁定过程
*其他 部分方法和函数名简化

5.0.0(2014-9.10)
*其他 模块更名为 鱼刺类_多线程应用
*鱼刺类_线程池Ex 增加方法 事件_暂停 放在线程子程序做快速暂停关卡
*线程池Ex 增加方法 事件_暂停 放在线程子程序做快速暂停关卡
*鱼刺类_读写锁 新增读写锁面向对象版
*读写锁 新增读写锁面向过程版
*鱼刺类_线程操作 优化类管理机制
*鱼刺类_线程程操作 线程_创建/线程_创建int 增加参数 是否在UI线程
*线程操作 线程_创建/线程_创建int 增加参数 是否在UI线程

4.9.7(2014-7-22)
*鱼刺类_线程池Ex 增加方法 取_最大线程容量
*线程池Ex 同步更新

4.9.6(2014-7-8)
*鱼刺类_完成端口 清空方法 加入 参数_是否在UI线程

4.9.5(2014-7-6)
*鱼刺类_队列 新增压入时可过滤重复参数

4.9.4(2014-6-29)
*鱼刺类_线程操作 修正一处原子隔离的先后顺序

4.9.3(2014-6-19)
*鱼刺类_线程池 修复因事件逻辑先后造成的销毁不及时的BUG
*线程池 同步修复BUG
*鱼刺类_线程池Ex 同步修复BUG
*线程池Ex 同步修复BUG
*鱼刺类_线程池Ex 增加创建/销毁/暂停/等待任务动态新参数 是否在UI线程
*线程池Ex 同步增加新参数

4.9.2(2014-6-7)
*鱼刺类_线程池 增加创建/销毁新参数 是否在UI线程
*线程池 同步增加新参数

4.9.1(2014-5-16)
*鱼刺类_线程池 增加可设置初始栈大小（控制初始栈大小减小资源且可创建更多条线程）
*线程池 同步增加可设置初始栈大小
*鱼刺类_线程池Ex 增加可设置初始栈大小
*鱼刺类_线程池Ex 增加可中途改变初始栈大小
*线程池Ex 同步增加可设置初始栈大小
*鱼刺类_线程操作 增加可设置初始栈大小
*线程操作 同步增加可设置初始栈大小

4.8.8(2014-4-27)
*鱼刺类_信号量 修改部分bug和注释
*信号量 修改部分bug和注释

4.8.6(2014-1-26)
*鱼刺类_线程池Ex 改进扩展线程控制方式
*鱼刺类_线程池Ex 修正在特性情况下可能造成线程池残留一个线程的问题
*鱼刺类_线程池 优化销毁过程降低资源浪费

4.8.5（2014-1-25）
*类回调 修正指针释放不彻底问题
*鱼刺类_队列 改进缓冲区增量和收缩机制

4.8.4（2014-1-25）
*鱼刺类_原子锁 重写原子操作类为面向对象方式

4.8.3（2014-1-24）
*线程池 废除数组存储信息机制改为内存指针
*线程池Ex 废除数组存储信息机制改为内存指针
*线程池 同步鱼刺类_线程池的所有更新
*线程池Ex 同步鱼刺类_线程池Ex的所有更新
*鱼刺类_线程池 销毁顺序方式调整
*鱼刺类_线程池Ex 销毁顺序方式调整

4.8.2（2014-1-24）
*鱼刺类_线程池Ex 动态线程机制更新 修正在某些情况下动态线程调度过慢的问题

4.8.1（2014-1-24）
*鱼刺类_线程池 去除一处不必要的原子操作

4.8（2014-1-23）
*鱼刺类_线程池Ex 创建和销毁架构全面升级 废除旧版通知机制
*鱼刺类_线程池Ex 调度线程和任务函数全面升级 更少的系统资源浪费
*鱼刺类_线程池Ex 动态线程超时收回时间机制更新 修改后不需要等下次调度就能生效
*鱼刺类_线程池Ex 修正线程池在暂停状态下被销毁时会触发任务调度的问题

4.7.9（2014-1-22）
*鱼刺类_线程池 创建和销毁机制更新 废除旧版等待机制”", , 
.常量 PAGE_EXECUTE_READWRITE, "64", , 
.常量 MEM_COMMIT, "4096", , 
.常量 MEM_RELEASE, "32768", , 
.常量 sizeof_int, "4", , 
.常量 , , , 
.常量 , , , 
.常量 线程池_未启动, "0", 公开, 
.常量 线程池_正在工作, "1", 公开, 
.常量 线程池_正在创建, "2", 公开, 
.常量 线程池_正在销毁, "3", 公开, 


 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 5 3 系统核心支持库




数据类型 临界许可, 公开, 临界许可类
    .成员 标识, 整数型, , , DebugInfo 这个只要大于0就表示许可证存在
    .成员 LockCount, 整数型, , , 
    .成员 RecursionCount, 整数型, , , 
    .成员 OwningThread, 整数型, , , 
    .成员 LockSemaphore, 整数型, , , 
    .成员 SpinCount, 整数型, , , 

数据类型 消息结构, 公开, MSG
    .成员 hwnd, 整数型, , , 
    .成员 message, 整数型, , , 
    .成员 wParam, 整数型, , , 
    .成员 lParam, 整数型, , , 
    .成员 time, 整数型, , , 
    .成员 pt, 坐标型, , , 

数据类型 坐标型, 公开, POINTAPI
    .成员 x, 整数型, , , 
    .成员 y, 整数型, , , 

.全局变量 DefaultHeap, 整数型, , , 

.DLL命令 _COM初始化, 整数型, "ole32", "CoInitialize", 公开, COM初始化
    .参数 pvReserved, 整数型, , 值为0

.DLL命令 _COM初始化结束, 空白型, "ole32", "CoUninitialize", 公开, COM初始化结束

.DLL命令 _关闭对象, 逻辑型, "kernel32", "CloseHandle", 公开, 关闭对象 用处很多 非0表示成功 0表示失败
    .参数 hObject, 整数型, , 欲关闭的一个对象的句柄。

.DLL命令 _等待对象, 整数型, "kernel32", "WaitForSingleObject", 公开, 等待对象。返回值：0表示对象已置位，258表示超时，-1表示失败或对象已失效。
    .参数 hHandle, 整数型, , 指定为等待的对象句柄。
    .参数 dwMilliseconds, 整数型, , 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。

.DLL命令 _延时, 整数型, "kernel32", "Sleep", 公开, 执行挂起一段时间。若进程/线程挂起到参数所指定的时间则返回0，若有信号中断则返回剩余秒数。
    .参数 Time, 整数型, , 要延时的毫秒数

.DLL命令 _取错误代码, 整数型, "", "GetLastError", 公开, 该函数返回调用线程最近的错误代码值，错误代码以单线程为基础来维护的，多线程不重写各自的错误代码值。（写库文件名会坑！）

.DLL命令 _获取消息A, 整数型, "user32", "GetMessageA", 公开, 函数GetMessage 是 从调用线程的消息队列里取得一个消息并将其放于指定的结构。此函数可取得与指定窗口联系的消息和由PostThreadMesssge寄送的线程消息。 如果函数取得WM_QUIT之外的其他消息，返回非零值。如果函数取得WM_QUIT消息，返回值是零。如果出现了错误，返回值是-1。例如，当hWnd是无效的窗口句柄或lpMsg是无效的指针时。若想获得更多的错误信息，请调用GetLastError函数。
    .参数 lpMsg, 消息结构, , 用来保存消息结构的变量。
    .参数 hwnd, 整数型, , 取得其消息的窗口的句柄。当其值取Null时，GetMessage为任何属于调用线程的窗口检索消息，线程消息通过PostThreadMessage寄送给调用线程。
    .参数 wMsgFilterMin, 整数型, , 指定被检索的最小消息值的整数。
    .参数 wMsgFilterMax, 整数型, , 指定被检索的最大消息值的整数。

.DLL命令 _获取消息W, 整数型, "user32", "GetMessageW", 公开, 函数GetMessage 是 从调用线程的消息队列里取得一个消息并将其放于指定的结构。此函数可取得与指定窗口联系的消息和由PostThreadMesssge寄送的线程消息。 如果函数取得WM_QUIT之外的其他消息，返回非零值。如果函数取得WM_QUIT消息，返回值是零。如果出现了错误，返回值是-1。例如，当hWnd是无效的窗口句柄或lpMsg是无效的指针时。若想获得更多的错误信息，请调用GetLastError函数。
    .参数 lpMsg, 消息结构, , 用来保存消息结构的变量。
    .参数 hwnd, 整数型, , 取得其消息的窗口的句柄。当其值取Null时，GetMessage为任何属于调用线程的窗口检索消息，线程消息通过PostThreadMessage寄送给调用线程。
    .参数 wMsgFilterMin, 整数型, , 指定被检索的最小消息值的整数。
    .参数 wMsgFilterMax, 整数型, , 指定被检索的最大消息值的整数。

.DLL命令 GetLastError, 整数型, "", "GetLastError", , 该函数返回调用线程最近的错误代码值，错误代码以单线程为基础来维护的，多线程不重写各自的错误代码值。（写库文件名会坑！）

.DLL命令 CloseHandle, 逻辑型, "kernel32", "CloseHandle", , 关闭对象 用处很多 非0表示成功 0表示失败
    .参数 hObject, 整数型, , 欲关闭的一个对象的句柄

.DLL命令 WaitForSingleObject, 整数型, "kernel32", "WaitForSingleObject", , 等待对象
    .参数 hHandle, 整数型, , 指定为等待的对象句柄。
    .参数 dwMilliseconds, 整数型, , 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。

.DLL命令 WaitForMultipleObject, 整数型, "kernel32", "WaitForMultipleObject", , 监测一个对象的状态。如事件对象、线程、进程。返回值：0表示对象已置位，258表示超时，-1表示失败或对象已失效。
    .参数 dwCount, 整数型, , 对象句柄的数量。
    .参数 lpHandle, 整数型, 数组, 指向一组句柄的变量
    .参数 bWaotALL, 逻辑型, , 如果指定为TRUE,函数仅在所有对象的状态都变成 置位 时才返回，如果指定FALSE ,任意一个对象的状态变成 置位 时都返回。
    .参数 dwMilliseconds, 整数型, , 指定以ms(毫秒)为单位的超时时间

.DLL命令 MsgWaitForMultipleObjects, 整数型, "user32", "MsgWaitForMultipleObjects", , 等待多个对象
    .参数 nCount, 整数型, , 对象数量
    .参数 pHandles, 整数型, 传址, 对象数组
    .参数 fWaitAll, 逻辑型, , 
    .参数 dwMilliseconds, 整数型, , 
    .参数 dwWakeMask, 整数型, , 

.DLL命令 CreateThread, 整数型, "kernel32", "CreateThread", , 创建线程
    .参数 lpThreadAttributes, 整数型, , 
    .参数 dwStackSize, 整数型, , 
    .参数 lpStartAddress, 子程序指针, , &子程序指针
    .参数 lpParameter, 整数型, , 附加参数
    .参数 dwCreationFlags, 整数型, , 
    .参数 lpThreadId, 整数型, 传址, 

.DLL命令 CreateThread_Int, 整数型, "kernel32", "CreateThread", , 创建线程
    .参数 lpThreadAttributes, 整数型, , 
    .参数 dwStackSize, 整数型, , 
    .参数 lpStartAddress, 整数型, , 到整数(&子程序指针)
    .参数 lpParameter, 整数型, , 
    .参数 dwCreationFlags, 整数型, , 
    .参数 lpThreadId, 整数型, 传址, 

.DLL命令 GetThreadPriority, 整数型, "kernel32", "GetThreadPriority", , 取线程优先级
    .参数 线程句柄, 整数型, , 

.DLL命令 SetThreadPriority, 整数型, "kernel32", "SetThreadPriority", , 置线程优先级
    .参数 线程句柄, 整数型, , 
    .参数 优先级, 整数型, , 

.DLL命令 SetThreadAffinityMask, 整数型, "kernel32", "SetThreadAffinityMask", , 设置CPU亲和性/绑定CPU
    .参数 hThread, 整数型, , 
    .参数 亲和性, 整数型, , 

.DLL命令 SuspendThread, 整数型, "kernel32", "SuspendThread", , 挂起线程
    .参数 hThread, 整数型, , 线程句柄

.DLL命令 ResumeThread, 整数型, "kernel32", "ResumeThread", , 恢复线程
    .参数 hThread, 整数型, , 线程句柄

.DLL命令 GetExitCodeThread, 整数型, "kernel32", "GetExitCodeThread", , 取线程状态
    .参数 hThread, 空白型, , 
    .参数 lpExitCode, 空白型, 传址, 

.DLL命令 TerminateThread, 逻辑型, "kernel32", "TerminateThread", , 终止线程
    .参数 hThread, 整数型, , 线程句柄
    .参数 dwExitCode, 整数型, , 退出代码 默认0

.DLL命令 GetCurrentThread, 整数型, "kernel32", "GetCurrentThread", , 获取当前线程的伪句柄

.DLL命令 GetCurrentThreadId, 整数型, "kernel32", "GetCurrentThreadId", , 取当前线程一个唯一的线程标识符

.DLL命令 InitializeCriticalSection_临界许可, 空白型, "kernel32", "InitializeCriticalSection", , 创建许可证
    .参数 lpCriticalSection, 临界许可, 传址, 

.DLL命令 DeleteCriticalSection_临界许可, 整数型, "kernel32", "DeleteCriticalSection", , 销毁许可证
    .参数 lpCriticalSection, 临界许可, 传址, 

.DLL命令 EnterCriticalSection_临界许可, 空白型, "kernel32", "EnterCriticalSection", , 进入许可区
    .参数 lpCriticalSection, 临界许可, 传址, 

.DLL命令 LeaveCriticalSection_临界许可, 空白型, "kernel32", "LeaveCriticalSection", , 退出许可区
    .参数 lpCriticalSection, 临界许可, 传址, 

.DLL命令 TryEnterCriticalSection_临街许可, 逻辑型, "kernel32", "TryEnterCriticalSection", , 尝试进入许可证
    .参数 lpCriticalSection, 临界许可, 传址, 临界许可

.DLL命令 InitializeCriticalSection_int, 空白型, "kernel32", "InitializeCriticalSection", , 创建许可证
    .参数 lpCriticalSection, 整数型, , 

.DLL命令 DeleteCriticalSection_int, 空白型, "kernel32", "DeleteCriticalSection", , 销毁许可证
    .参数 lpCriticalSection, 整数型, , 

.DLL命令 EnterCriticalSection_int, 空白型, "kernel32", "EnterCriticalSection", , 进入许可区
    .参数 lpCriticalSection, 整数型, , 

.DLL命令 LeaveCriticalSection_int, 空白型, "kernel32", "LeaveCriticalSection", , 退出许可区
    .参数 lpCriticalSection, 整数型, , 

.DLL命令 TryEnterCriticalSection_int, 逻辑型, "kernel32", "TryEnterCriticalSection", , 尝试进入许可证
    .参数 lpCriticalSection, 整数型, , 许可证指针

.DLL命令 CreateMutex, 整数型, "kernel32", "CreateMutexA", , 创建互斥量 失败返回0
    .参数 Attributes, 整数型, , 安全属性
    .参数 Init, 逻辑型, , 是否立即拥有
    .参数 Name, 文本型, , 名称

.DLL命令 CreateMutex_int, 整数型, "kernel32", "CreateMutexA", , 创建互斥量 失败返回0
    .参数 Attributes, 整数型, , 安全属性
    .参数 Init, 逻辑型, , 是否立即拥有
    .参数 Name, 整数型, 传址, 名称

.DLL命令 OpenMutex, 整数型, "kernel32", "OpenMutexA", , 打开以创建的互斥量 失败返回0
    .参数 Access, 整数型, , 权限
    .参数 Inherit, 逻辑型, , 是否立即拥有
    .参数 Name, 文本型, , 名称

.DLL命令 ReleaseMutex, 逻辑型, "kernel32", "ReleaseMutex", , 退出/释放互斥量 成功返回真 失败返回假
    .参数 handle, 整数型, , 互斥量对象句柄

.DLL命令 CreateIoCompletionPort, 整数型, "kernel32", "CreateIoCompletionPort", , 函数关联一个已打开的文件实例和新建的或已存在的I/0完成端口，或者创建一个未关联任何文件的I/O完成端口。
    .参数 Handle, 整数型, , 是关联的文件句柄。
    .参数 ExistingCompletionPort, 整数型, , 是已经存在的完成端口。如果为NULL，则为新建一个IOCP
    .参数 CompletionKey, 整数型, , 传送给处理函数的参数
    .参数 NumberOfConcurrentThreads, 整数型, , 有多少个线程在访问这个消息队列。当参数不为0的时候，系统忽略该参数，当该参数为0表示允许同时相等数目于处理器个数的线程访问该消息队列

.DLL命令 PostQueuedCompletionStatus, 逻辑型, "kernel32", "PostQueuedCompletionStatus", , 投递任务
    .参数 CompletionPort, 整数型, , 指定想向其发送一个完成数据包的完成端口对象
    .参数 dwNumberOfBytesTransferred, 整数型, , 指定―个值,直接传递给GetQueuedCompletionStatus函数中对应的参数
    .参数 dwCompletionKey, 整数型, , 指定―个值,直接传递给GetQueuedCompletionStatus函数中对应的参数
    .参数 lpOverlapped, 整数型, , 指定―个值,直接传递给GetQueuedCompletionStatus函数中对应的参数

.DLL命令 GetQueuedCompletionStatus, 逻辑型, "kernel32", "GetQueuedCompletionStatus", , 实现从指定的IOCP获取CP。当CP队列为空时，对此函数的调用将被阻塞
    .参数 CompletionPort, 整数型, , 指定的IOCP
    .参数 lpNumberOfBytesTransferred, 整数型, 传址, 一次完成后的I/O操作所传送数据的字节数
    .参数 lpCompletionKey, 整数型, 传址, 当文件I/O操作完成后，用于存放与之关联的CK
    .参数 lpOverlapped, 整数型, 传址, 为调用IOCP机制所引用的OVERLAPPED结构
    .参数 dwMilliseconds, 整数型, , 用于指定调用者等待CP的时间

.DLL命令 InterlockedIncrement, 整数型, "kernel32", "InterlockedIncrement", , 原子锁_递增
    .参数 Lplong_整数变量, 整数型, 传址, 变量

.DLL命令 InterlockedDecrement, 整数型, "kernel32", "InterlockedDecrement", , 原子锁_递减
    .参数 Lplong_整数变量, 整数型, 传址, 变量

.DLL命令 InterlockedExchange, 整数型, "kernel32", "InterlockedExchange", , 原子锁_交换赋值
    .参数 Target, 整数型, 传址, 变量
    .参数 Value, 整数型, , 赋值的值

.DLL命令 InterlockedExchangeAdd, 整数型, "kernel32", "InterlockedExchangeAdd", , 原子锁_运算
    .参数 Addend, 整数型, 传址, 被运算的变量
    .参数 Value, 整数型, , 被运算的值

.DLL命令 InterlockedCompareExchange, 整数型, "kernel32", "InterlockedCompareExchange", , 原子锁_三目运算
    .参数 Destination, 整数型, 传址, 被运算的变量
    .参数 Exchange, 整数型, , 赋值的值
    .参数 Comperand, 整数型, , 对比的值

.DLL命令 InterlockedIncrement_ptr, 整数型, "kernel32", "InterlockedIncrement", , 原子锁_递增
    .参数 Lplong_整数变量, 整数型, , 内存指针

.DLL命令 InterlockedDecrement_ptr, 整数型, "kernel32", "InterlockedDecrement", , 原子锁_递减
    .参数 Lplong_整数变量, 整数型, , 内存指针

.DLL命令 InterlockedExchange_ptr, 整数型, "kernel32", "InterlockedExchange", , 原子锁_交换赋值
    .参数 Target, 整数型, , 内存指针
    .参数 Value, 整数型, , 赋值的值

.DLL命令 InterlockedExchangeAdd_ptr, 整数型, "kernel32", "InterlockedExchangeAdd", , 原子锁_运算
    .参数 Addend, 整数型, , 被运算的内存指针
    .参数 Value, 整数型, , 被运算的值

.DLL命令 InterlockedCompareExchange_ptr, 整数型, "kernel32", "InterlockedCompareExchange", , 原子锁_三目运算
    .参数 Destination, 整数型, , 被运算的内存指针
    .参数 Exchange, 整数型, , 赋值的值
    .参数 Comperand, 整数型, , 对比的值

.DLL命令 GetProcessHeap, 整数型, "kernel32", "GetProcessHeap", , 获取当前堆句柄 用以获取和调用过程的堆句柄

.DLL命令 HeapCreate, 整数型, "kernel32", "HeapCreate", , 创建一个堆
    .参数 dwFlags, 整数型, , 创建方式 内存块标志。 为1 不检测独占
    .参数 len, 整数型, , 默认大小
    .参数 Exlen, 整数型, , 扩展大小 0为无限制

.DLL命令 HeapDestroy, 逻辑型, "Kernel32", "HeapDestroy", , 释放堆
    .参数 hHeap, 整数型, , 堆句柄

.DLL命令 HeapAlloc, 整数型, "Kernel32", "HeapAlloc", , 在指定的堆上分配内存。
    .参数 hHeap, 整数型, , 堆句柄 表明从此参数指定的堆上进行内存分配。
    .参数 dwFlags, 整数型, , 内存分配的标志。一般为 8 
    .参数 dwBytes, 整数型, , 需要分配的内存区域大小，以字节为单位。

.DLL命令 HeapFree, 整数型, "kernel32", "HeapFree", , 
    .参数 hHeap, 整数型, , 堆句柄 内存块所在的堆。
    .参数 dwFlags, 整数型, , 内存块标志。 为1 不检测独占
    .参数 lpMem, 整数型, , 所需要释放的内存块的指针

.DLL命令 HeapReAlloc, 整数型, "Kernel32", "HeapReAlloc", , 调整内存快
    .参数 hHeap, 整数型, , 堆句柄
    .参数 dwFlags, 整数型, , 方式 1=不进行独占检测 8=扩展的新内存初始化为0  16=禁止移动内存快（建议缩小时用）
    .参数 lPMemory, 整数型, , 指向用HeapAlloc分配堆中内存时返回的指针 内存快句柄
    .参数 dwBytes, 整数型, , 指定新的大小值

.DLL命令 CreateSemaphore, 整数型, "kernel32", "CreateSemaphoreA", , 创建一个新的信号机  如执行成功，返回信号机对象的句柄；零表示出错。会设置GetLastError。即使返回一个有效的句柄，但倘若它指出同名的一个信号机已经存在，那么GetLastError也会返回ERROR_ALREADY_EXISTS
    .参数 信号量安全特性, 整数型, , SECURITY_ATTRIBUTES，指定一个SECURITY_ATTRIBUTES结构，或传递零值（将参数声明为ByVal As 并传递零值）――表示采用不允许继承的默认描述符。该参数定义了信号机的安全特性
    .参数 信号量初始计数, 整数型, , 设置信号机的初始计数。可设置零到lMaximumCount之间的一个值
    .参数 信号量最大计数, 整数型, , 设置信号机的最大计数
    .参数 信号量对象的名称, 文本型, , 指定信号机对象的名称。用vbNull可创建一个未命名的信号机对象。如果已经存在拥有这个名字的一个信号机，就直接打开现成的信号机。这个名字可能不与一个现有的互斥体、事件、可等待计时器或文件映射的名称相符;

.DLL命令 OpenSemaphore, 整数型, "kernel32", "OpenSemaphoreA", , 打开命名信号量对象
    .参数 dwDesiredAccess, 整数型, , 权限,2031619
    .参数 是否继承, 逻辑型, , 是否继承句柄
    .参数 lpName, 文本型, , 名称

.DLL命令 ReleaseSemaphore, 逻辑型, "kernel32", "ReleaseSemaphore", , 释放信号量对象
    .参数 hSemaphore, 整数型, , 句柄
    .参数 lReleaseCount, 整数型, , 增加的数量
    .参数 lpPreviousCount, 整数型, 传址, 之前的数量

.DLL命令 CreateEvent, 整数型, "kernel32", "CreateEventA", , 创建或打开一个命名的或无名的事件对象 如果函数调用成功，函数返回事件对象的句柄。如果对于命名的对象，在函数调用前已经被创建，函数将返回存在的事件对象的句柄
    .参数 lpEventAttributes, 整数型, , 一个指向SECURITY_ATTRIBUTES结构的指针，确定返回的句柄是否可被子进程继承。如果lpEventAttributes是NULL，此句柄不能被继承
    .参数 bManualReset, 逻辑型, , 指定将事件对象创建成手动复原还是自动复原。如果是TRUE，那么必须用ResetEvent函数来手工将事件的状态复原到无信号状态。如果设置为FALSE，当事件被一个等待线程释放以后，系统将会自动将事件状态复原为无信号状态。
    .参数 bInitialState, 逻辑型, , 指定事件对象的初始状态。如果为TRUE，初始状态为有信号状态；否则为无信号状态
    .参数 lpname, 文本型, 传址, 指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在MAX_PATH之内。名字是对大小写敏感的。

.DLL命令 CreateEvent_int, 整数型, "kernel32", "CreateEventA", , 创建或打开一个命名的或无名的事件对象 如果函数调用成功，函数返回事件对象的句柄。如果对于命名的对象，在函数调用前已经被创建，函数将返回存在的事件对象的句柄
    .参数 lpEventAttributes, 整数型, , 一个指向SECURITY_ATTRIBUTES结构的指针，确定返回的句柄是否可被子进程继承。如果lpEventAttributes是NULL，此句柄不能被继承
    .参数 bManualReset, 逻辑型, , 指定将事件对象创建成手动复原还是自动复原。如果是TRUE，那么必须用ResetEvent函数来手工将事件的状态复原到无信号状态。如果设置为FALSE，当事件被一个等待线程释放以后，系统将会自动将事件状态复原为无信号状态。
    .参数 bInitialState, 逻辑型, , 指定事件对象的初始状态。如果为TRUE，初始状态为有信号状态；否则为无信号状态
    .参数 lpname, 整数型, 传址, 指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在MAX_PATH之内。名字是对大小写敏感的。

.DLL命令 OpenEvent, 整数型, "kernel32", "OpenEventA", , 打开一个已创建的 Event事件对象。
    .参数 dwDesiredAccess, 整数型, , 
    .参数 bInheritHandle, 逻辑型, , 
    .参数 lpName, 文本型, 传址, 

.DLL命令 ResetEvent, 逻辑型, "kernel32", "ResetEvent", , 将事件对象设置为无信号状态
    .参数 hEvent, 整数型, , 

.DLL命令 SetEvent, 逻辑型, "kernel32", "SetEvent", , 将Event事件对象设置为发信号状态
    .参数 hEvent, 整数型, , 

.DLL命令 PulseEvent, 逻辑型, "kernel32", "PulseEvent", , 触发并重置
    .参数 hEvent, 整数型, , 

.DLL命令 RtlMoveMemory, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 pDest, 整数型, , 目标地址
    .参数 pSrc, 整数型, , 源地址
    .参数 ByteLen, 整数型, , 长度

.DLL命令 RtlMoveMemory_Eint_int, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 Dest, 整数型, , 目标地址
    .参数 Src, 整数型, 传址, 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_int_Eint, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 Dest, 整数型, 传址, 目标地址
    .参数 Src, 整数型, , 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_Ebin_int, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 Dest, 整数型, , 目标地址
    .参数 Src, 字节集, 传址, 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_int_Ebin, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 Dest, 字节集, 传址, 目标地址
    .参数 Src, 整数型, , 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_Estr_int, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 Dest, 整数型, , 目标地址
    .参数 Src, 文本型, 传址, 原地址
    .参数 length, 整数型, , 长度

.DLL命令 RtlMoveMemory_int_Estr, 逻辑型, "kernel32", "RtlMoveMemory", , 移动内存
    .参数 Dest, 文本型, 传址, 目标地址
    .参数 Src, 整数型, , 原地址
    .参数 length, 整数型, , 长度

.DLL命令 VirtualAlloc, 整数型, "kernel32", "VirtualAlloc", , 
    .参数 lpAddress, 整数型, , 
    .参数 dwSize, 整数型, , 
    .参数 flAllocationType, 整数型, , 
    .参数 flProtect, 整数型, , 

.DLL命令 VirtualFree, 整数型, "kernel32", "VirtualFree", , 
    .参数 lpAddress, 整数型, , 
    .参数 dwSize, 整数型, , 
    .参数 dwFreeType, 整数型, , 

.DLL命令 GetTickCount, 整数型, "kernel32", "GetTickCount", , 用于获取自windows启动以来经历的时间长度（毫秒）

.DLL命令 Sleep, 整数型, "kernel32", "Sleep", , 
    .参数 main, 整数型, , 毫秒

.DLL命令 GetInputState, 整数型, "user32", "GetInputState", , 用法,如果真(我的处理事件()≠0),处理事件()    比系统自带的"处理事件"比3倍以上

.DLL命令 EmptyWorkingSet, 整数型, "psapi", "EmptyWorkingSet", , 整理内存
    .参数 Phnd, 整数型, , 进程句柄

.DLL命令 OpenProcess, 整数型, "kernel32", "OpenProcess", , 打开进程
    .参数 访问级别, 整数型, , 2035711完全访问
    .参数 子进程继承, 整数型, , 1为子进程继承 0为不传承
    .参数 进程ID, 整数型, , 要打开的进程标识

.DLL命令 SetTimer, 整数型, "user32", "SetTimer", , 创建/设置定时器
    .参数 hWnd, 整数型, , 
    .参数 nIDEvent, 整数型, , 
    .参数 hTime, 整数型, , 
    .参数 hPtr, 整数型, , 

.DLL命令 KillTimer, 整数型, "user32", "KillTimer", , 销毁定时器
    .参数 hWnd, 整数型, , 
    .参数 nIDEvent, 整数型, , 

.DLL命令 lstrlen, 整数型, "kernel32", "lstrlenA", , 返回字符串长度
    .参数 lpString, 文本型, , 

.DLL命令 PostThreadMesssgeA, 逻辑型, "user32", "PostThreadMessageA", , 将一个消息放入（寄送）到指定线程的消息队列里，不等待线程处理消息就返回。
    .参数 idThread, 整数型, , 线程ID
    .参数 wMsg, 整数型, , 消息标识符
    .参数 wParam, 整数型, , 具体由消息决定
    .参数 lParam, 整数型, , 具体由消息决定

.DLL命令 PostThreadMesssgeW, 逻辑型, "user32", "PostThreadMessageW", , 将一个消息放入（寄送）到指定线程的消息队列里，不等待线程处理消息就返回。
    .参数 idThread, 整数型, , 线程ID
    .参数 wMsg, 整数型, , 消息标识符
    .参数 wParam, 整数型, , 具体由消息决定
    .参数 lParam, 整数型, , 具体由消息决定

.程序集 启动, , , 

.子程序 _启动子程序, 整数型, , 请在本子程序中放置易模块初始化代码
赋值 (DefaultHeap, GetProcessHeap ()) ' 获取下默认堆句柄
_临时子程序 () ' 在初始化代码执行完毕后调用测试代码
返回 (0) ' 可以根据您的需要返回任意数值

.子程序 _临时子程序, 空白型, , 
 ' 本名称子程序用作测试程序用，仅在开发及调试环境中有效，编译发布程序前将被系统自动清空，请将所有用作测试的临时代码放在本子程序中。 ***注意不要修改本子程序的名称、参数及返回值类型。
输出调试文本 (#注释)



 ' _text_Queue ()
 ' Demo ()

.子程序 _text_Queue, 空白型, , 
.局部变量 queue, 鱼刺类_队列, , , 
.局部变量 t, 整数型, , , 
.局部变量 bin, 字节集, , , 
.局部变量 len, 整数型, , , 
.局部变量 i, 整数型, , , 

赋值 (len, 1000000) ' 100W
' 本源码来自易语言资源网(www.5A5X.com)
赋值 (t, 取启动时间 ())
.计次循环首 (len, i)
    queue.压入整数 (i)
.计次循环尾 ()
.计次循环首 (queue.取队列长度 (), i)
    queue.弹出整数 (i)
.计次循环尾 ()
赋值 (t, 相减 (取启动时间 (), t))
输出调试文本 (i)
输出调试文本 (相加 (“整数 压入完弹出用时：”, 到文本 (t)))

返回 ()

赋值 (bin, 到字节集 (“鱼刺 你又调皮了唉！”))
赋值 (t, 取启动时间 ())
.计次循环首 (len, i)
    queue.压入字节集 (bin)
.计次循环尾 ()
.计次循环首 (queue.取队列长度 (), i)
    queue.弹出字节集 (bin)
.计次循环尾 ()
赋值 (t, 相减 (取启动时间 (), t))
输出调试文本 (到文本 (bin))
输出调试文本 (i)
输出调试文本 (相加 (“字节集 压入完弹出用时：”, 到文本 (t)))



.子程序 Demo, 空白型, , 
.局部变量 线程, 鱼刺类_线程操作, , , 
.局部变量 临界, 鱼刺类_临界许可, , , 
.局部变量 互斥, 鱼刺类_互斥锁, , , 
.局部变量 事件, 鱼刺类_事件, , , 
.局部变量 信号, 鱼刺类_信号量, , , 
.局部变量 原子, 鱼刺类_原子锁, , , 
.局部变量 线程池, 鱼刺类_线程池, , , 
.局部变量 线程池Ex, 鱼刺类_线程池Ex, , , 
.局部变量 读写锁1, 鱼刺类_读写锁, , , 
.局部变量 线程池_自销毁, 鱼刺类_线程池_自销毁, , , 
.局部变量 匿名局部变量_9126, 空白型, , , 
.局部变量 bool, 逻辑型, , , 
.局部变量 int, 整数型, , , 
.局部变量 临界许可, 临界许可, , , 
.局部变量 ret, 整数型, , , 


赋值 (bool, 线程.创建 (&Demo_Thread))
.判断循环首 (等于 (线程.是否已创建 (), 真))
    线程.等待 (10)
    _延迟 (10)
    线程.等待2 (20)
    线程.等待_msg (20)
.判断循环尾 ()
线程.投递信息A (0, 0, 0)
线程.投递信息W (0, 0, 0)
输出调试文本 (“线程操作”, bool)


临界.进入 ()
处理事件 ()
临界.退出 ()
输出调试文本 (“临界许可”)


赋值 (bool, 互斥.创建 ())
互斥.进入 ()
处理事件 ()
互斥.退出 ()
互斥.销毁 ()
输出调试文本 (“互斥”, bool)


赋值 (bool, 事件.创建 ())
事件.触发 ()
处理事件 ()
事件.等待进入 ()
事件.销毁 ()
输出调试文本 (“事件对象”, bool)


赋值 (bool, 信号.创建 (1, 2))
信号.增加 (1)
信号.递减 ()
信号.销毁 ()
输出调试文本 (“信号量”, bool)


原子.递增 ()
原子.赋值 (2)
原子.运算 (1)
输出调试文本 (“原子锁”, 原子.取值 ()) ' 3


线程池.创建 (2)
线程池.投递任务 (&Demo_Thread, 1)
线程池.取_状态 ()
线程池.取_是否空闲 ()
线程池.取_空闲线程数 ()
线程池.取_执行线程数 ()
线程池.取_队列任务数 ()
线程池.取_线程池容量 ()
赋值 (bool, 线程池.销毁 (0))
输出调试文本 (“线程池”, bool)


线程池Ex.创建 (2, 3)
线程池Ex.投递任务 (&Demo_Thread, 2)
线程池Ex.等待任务动态 ()
线程池Ex.暂停 ()
线程池Ex.继续 ()
线程池Ex.事件_暂停 ()
线程池Ex.取_状态 ()
线程池Ex.取_是否空闲 ()
线程池Ex.取_空闲线程数 ()
线程池Ex.取_执行线程数 ()
线程池Ex.取_队列任务数 ()
线程池Ex.取_线程池容量 ()
线程池Ex.置_最大线程数 (3)
线程池Ex.置_空闲回收时间 (100)
赋值 (bool, 线程池Ex.销毁 (0))
输出调试文本 (“线程池Ex”, bool)


赋值 (bool, 读写锁1.读锁定 ())
读写锁1.解锁 ()
赋值 (bool, 读写锁1.写锁定 ())
读写锁1.解锁 ()
输出调试文本 (“读写锁”, bool)



赋值 (bool, 线程_创建 (&Demo_Thread, , int))
线程_挂起 (int)
输出调试文本 (“挂起后状态”, WaitForSingleObject (int, 0))
线程_恢复 (int)
赋值 (bool, 线程_等待 (int, 5000))
线程_关闭句柄 (int)
输出调试文本 (“线程”, int, bool)


赋值 (int, _创建进入许可证 ())
_进入许可区 (int)
处理事件 ()
_退出许可区 (int)
_删除进入许可证 (int)
输出调试文本 (“许可证”, int)


赋值 (临界许可, 临界_创建 ())
临界_进入 (临界许可)
临界_退出 (临界许可)
临界_销毁 (临界许可)
输出调试文本 (“临界”, 临界许可.标识)


赋值 (int, 互斥_创建 ())
互斥_进入 (int)
互斥_退出 (int)
互斥_销毁 (int)
输出调试文本 (“互斥量”, int)


赋值 (int, 事件_创建 ())
事件_触发 (int)
事件_等待进入 (int)
事件_销毁 (int)
输出调试文本 (“事件对象”, int)


赋值 (int, 信号量_创建 (1, 2))
信号量_增加 (int, 1)
信号量_递减 (int)
信号量_销毁 (int)
输出调试文本 (“信号量”, int)

原子_赋值 (int, 0)
原子_递增 (int)
原子_递减 (int)
原子_运算 (int, 1)
原子_三目运算 (int, 0, 1)
原子_相加_asm (int, 1)
原子_相减_asm (int, 1)
输出调试文本 (“原子锁”, int)

赋值 (int, 线程池_创建 (2))
线程池_投递任务 (int, &Demo_Thread, 1)
线程池_取状态 (int)
线程池_取_是否空闲 (int)
线程池_取_空闲线程数 (int)
线程池_取_执行线程数 (int)
线程池_取_队列任务数 (int)
线程池_取_线程池容量 (int)
线程池_销毁 (int, 0)
输出调试文本 (“线程池”, int)


赋值 (int, 线程池Ex_创建 (2, 3))
线程池Ex_投递任务 (int, &Demo_Thread, 1)
线程池Ex_投递任务 (int, &Demo_Thread, 1)
线程池Ex_暂停 (int)
线程池Ex_继续 (int)
线程池Ex_事件_暂停 (int)
线程池Ex_等待任务动态 (int, 5000)
线程池Ex_取状态 (int)
线程池Ex_取_是否空闲 (int)
线程池Ex_取_空闲线程数 (int)
线程池Ex_取_执行线程数 (int)
线程池Ex_取_队列任务数 (int)
线程池Ex_取_线程池容量 (int)
线程池Ex_置_最大线程数 (int, 3)
线程池Ex_置_空闲回收时间 (int, 100)
线程池Ex_销毁 (int, 0)
输出调试文本 (“线程池Ex”, int)

赋值 (int, 读写锁_创建 ())
读写锁_读锁定 (int)
读写锁_解锁 (int)
读写锁_写锁定 (int)
读写锁_解锁 (int)
读写锁_销毁 (int)
输出调试文本 (“读写锁”, int)


线程池_自销毁.创建 (2, 100)
线程池_自销毁.置_线程空闲自销毁超时值 (100)
线程池_自销毁.投递任务 (&Demo_Thread, 1)
线程池_自销毁.取_状态 ()
线程池_自销毁.取_是否空闲 ()
线程池_自销毁.取_空闲线程数 ()
线程池_自销毁.取_执行线程数 ()
线程池_自销毁.取_队列任务数 ()
线程池_自销毁.取_线程池容量 ()
赋值 (bool, 线程池_自销毁.销毁 (0))
输出调试文本 (“线程池_自销毁”, bool)



.子程序 Demo_Thread, 空白型, , 
.参数 参数, 整数型, , 

_延时 (20)
输出调试文本 (参数)


.程序集 类回调, , , 类回调调用

.子程序 类回调_生成类函数地址, 整数型, , [只能在类里调用]
.参数 函数序号, 空白型, , 从1开始,([_初始化]和[_销毁]不管在什么位置都不计数）

.局部变量 this, 整数型, , , 
.局部变量 回调地址, 整数型, , , 
.局部变量 d, 字节集, , , 

.如果真 (等于 (函数序号, 0))
    返回 (0)
.如果真结束
赋值 (this, _读整数 (类回调_取上层函数首参 ()))
赋值 (回调地址, 类回调_取类函数地址 (this, _加法 (函数序号, 2)))
.如果真 (小于或等于 (回调地址, 0))
    返回 (0)
.如果真结束

赋值 (d, { 85, 139, 236, 106, 16, 83, 86, 87, 106, 0, 217, 60, 36, 219, 227, 104 })
赋值 (d, 相加 (d, 到字节集 (this), { 139, 196, 185, 16, 0, 0, 0, 43, 225, 141, 117, 8 }))
赋值 (d, 相加 (d, { 141, 60, 36, 252, 243, 164, 139, 77, 248, 139, 117, 244, 139, 125, 240, 80, 184 }))
赋值 (d, 相加 (d, 到字节集 (回调地址), { 104 }, 到字节集 (类回调_取返回码 ()), { 255, 224 }))
返回 (类回调_内存分配 (d))

.子程序 类回调_释放类函数地址, 空白型, , 用于释放生成代码后的返回指针，若你确定你的回调已经停用了才能释放
.参数 ptr, 整数型, , 类中函数指针

.如果真 (等于 (ptr, 0))
    返回 ()
.如果真结束
VirtualFree (ptr, 0, #MEM_RELEASE)

.子程序 类回调_内存分配, 整数型, , VirtualAlloc/VirtualFree
.参数 data, 字节集, 参考, 

.局部变量 hMem, 整数型, , , 
.局部变量 Ptr, 整数型, , , 
.局部变量 len, 整数型, , , 

赋值 (len, 取字节集长度 (data))
赋值 (hMem, VirtualAlloc (0, len, #MEM_COMMIT, #PAGE_EXECUTE_READWRITE))
RtlMoveMemory_Ebin_int (hMem, data, len)
返回 (hMem)

.子程序 类回调_取上层函数首参, 整数型, , 
置入代码 ({ 139, 69, 0, 139, 0, 139, 64, 8, 201, 195 })
返回 (0)
 ' mov eax, dword ptr [ebp+0]
 ' mov eax, dword ptr [eax]
 ' mov eax, dword ptr [eax+8]
 ' leave
 ' retn 0

.子程序 类回调_取类函数地址, 整数型, , 
.参数 this, 整数型, , 
.参数 index, 整数型, , 从1开始,[_初始化][_销毁],[xx]

.局部变量 偏移, 整数型, , , 

.如果真 (小于 (index, 1))
    返回 (0)
.如果真结束
赋值 (偏移, 相减 (相乘 (index, #sizeof_int), #sizeof_int))
返回 (_读整数 (_加法 (_读整数 (this), 偏移)))

.子程序 类回调_取返回码, 整数型, , 
.局部变量 static_ptr, 整数型, 静态, , 
.局部变量 data, 字节集, , , 

.如果真 (不等于 (static_ptr, 0))
    返回 (static_ptr)
.如果真结束
赋值 (data, { 139, 77, 252, 139, 93, 248, 139, 117, 244, 139, 125, 240, 217, 109, 236, 139, 229, 93, 141, 100, 12, 4, 247, 217, 139, 76, 12, 252, 255, 225 })
赋值 (static_ptr, 类回调_内存分配 (data))
返回 (static_ptr)

.程序集 _内部程序集, , , 

.子程序 调用子程序_asm, 整数型, , 调用子程序 返回指针
.参数 指针, 整数型, , 
.参数 参数一, 整数型, 可空, 
.参数 参数二, 整数型, 可空, 

返回 (_Call (指针, 参数一, 参数二))

.子程序 _Call, 整数型, , 
.参数 指针, 整数型, , 
.参数 参数一, 整数型, , 
.参数 参数二, 整数型, , 

置入代码 ({ 201, 88, 135, 4, 36, 255, 224 })
返回 (0)

.程序集 原子锁, , , 

.子程序 原子_递增_asm, 空白型, , 对提供的整数型变量+1。多线程中使用可避免赋值冲突。汇编版。
.参数 被加一的变量, 整数型, 参考, 

置入代码 ({ 139, 77, 8, 184, 1, 0, 0, 0, 240, 15, 193, 1 })

.子程序 原子_递减_asm, 空白型, , 对提供的整数型变量-1。多线程中使用可避免赋值冲突。汇编版。
.参数 被减一的变量, 整数型, 参考, 

置入代码 ({ 139, 77, 8, 184, 255, 255, 255, 255, 240, 15, 193, 1 })

.子程序 原子_相加_asm, 空白型, , 对提供的整数型变量加一定值。多线程中使用可避免赋值冲突。汇编版。
.参数 被增加的变量, 整数型, 参考, 
.参数 欲增加的量, 整数型, , 

置入代码 ({ 139, 77, 8, 139, 69, 12, 240, 15, 193, 1 })

.子程序 原子_相减_asm, 空白型, , 对提供的整数型变量减一定值。多线程中使用可避免赋值冲突。汇编版。
.参数 被相减的变量, 整数型, 参考, 
.参数 欲减少的量, 整数型, , 

置入代码 ({ 139, 77, 8, 139, 69, 12, 131, 240, 255, 64, 240, 15, 193, 1 })

.子程序 原子_递增, 整数型, , 返回递增结果。对提供的整数型变量+1。多线程中使用可避免赋值冲突。
.参数 被递增的整数型变量, 整数型, 参考, 

返回 (InterlockedIncrement (被递增的整数型变量))

.子程序 原子_递减, 整数型, , 返回递减结果。对提供的整数型变量-1。多线程中使用可避免赋值冲突。
.参数 被递减的整数型变量, 整数型, 参考, 

返回 (InterlockedDecrement (被递减的整数型变量))

.子程序 原子_赋值, 整数型, , 返回赋值前的数值。对提供的整数型变量赋值。多线程中使用可避免赋值冲突。
.参数 被赋值的整数型变量, 整数型, 参考, 
.参数 赋值的值, 整数型, , 

返回 (InterlockedExchange (被赋值的整数型变量, 赋值的值))

.子程序 原子_运算, 整数型, , 返回运算前的数值。对提供的整数型变量进行运算。多线程中使用可避免赋值冲突。
.参数 被运算的整数型变量, 整数型, 参考, 被运算的变量
.参数 被运算的值, 整数型, , 整数 或 负整数 例如：3就等于 原变量+3 ，-2就等于 原变量-2

返回 (InterlockedExchangeAdd (被运算的整数型变量, 被运算的值))

.子程序 原子_三目运算, 整数型, , 返回运算前的数值。对提供的整数型变量进行三目运算。多线程中使用可避免赋值冲突。
.参数 被运算的整数型变量, 整数型, 参考, 被运算的变量
.参数 被赋值的值, 整数型, , 被赋值的值
.参数 被对比的值, 整数型, , 被对比的值。如果 被运算的整数型变量 = 被对比的值 则 被运算的整数型变量 = 被赋值的值 否则无操作。

返回 (InterlockedCompareExchange (被运算的整数型变量, 被赋值的值, 被对比的值))

.子程序 原子_交换, 整数型, , 返回 "被交换的整数型变量一" 交换前的数值。
.参数 被交换的整数型变量一, 整数型, 参考, 被交换的整数型变量
.参数 被交换的整数型变量二, 整数型, 参考, 被交换的整数型变量

返回 (InterlockedExchange (被交换的整数型变量一, 被交换的整数型变量二))

.类模块 鱼刺类_原子锁, , , (面向对象) 原子锁。多用于解决整数型变量赋值冲突。

.程序集变量 int, 整数型, , , 内置变量
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 递增_asm, 空白型, , 对提供的整数型变量+1。多线程中使用可避免赋值冲突。汇编版。
原子_递增_asm (int)

.子程序 递减_asm, 空白型, , 对提供的整数型变量-1。多线程中使用可避免赋值冲突。汇编版。
原子_递减_asm (int)

.子程序 相加_asm, 空白型, , 对提供的整数型变量加一定值。多线程中使用可避免赋值冲突。汇编版。
.参数 被加数据, 整数型, , 

原子_相加_asm (int, 被加数据)

.子程序 相减_asm, 空白型, , 对提供的整数型变量减一定值。多线程中使用可避免赋值冲突。汇编版。
.参数 相减数据, 整数型, , 

原子_相减_asm (int, 相减数据)

.子程序 取值, 整数型, , 取内置变量的值
返回 (int)

.子程序 递增, 整数型, , 返回递增结果。对提供的整数型变量+1。多线程中使用可避免赋值冲突。
返回 (InterlockedIncrement (int))

.子程序 递减, 整数型, , 返回递减结果。对提供的整数型变量-1。多线程中使用可避免赋值冲突。
.参数 被递减的整数型变量, 整数型, 参考, 

返回 (InterlockedDecrement (int))

.子程序 赋值, 整数型, , 返回赋值前的数值。对提供的整数型变量赋值。多线程中使用可避免赋值冲突。
.参数 赋值的值, 整数型, , 

返回 (InterlockedExchange (int, 赋值的值))

.子程序 运算, 整数型, , 返回运算前的数值。对提供的整数型变量进行运算。多线程中使用可避免赋值冲突。
.参数 被运算的值, 整数型, , 整数 或 负整数 例如：3就等于 原变量+3 ，-2就等于 原变量-2

返回 (InterlockedExchangeAdd (int, 被运算的值))

.子程序 三目运算, 整数型, , 返回运算前的数值。对提供的整数型变量进行三目运算。多线程中使用可避免赋值冲突。
.参数 被赋值的值, 整数型, , 被赋值的值
.参数 被对比的值, 整数型, , 被对比的值。如果 被运算的整数型变量 = 被对比的值 则 被运算的整数型变量 = 被赋值的值 否则无操作。

返回 (InterlockedCompareExchange (int, 被赋值的值, 被对比的值))

.程序集 临界许可, , , 临界许可 是最简单有效的防止线程内数据交换冲突的办法之一

.子程序 临界_创建, 临界许可, , 
.局部变量 临界资源, 临界许可, , , 

InitializeCriticalSection_临界许可 (临界资源)
返回 (临界资源)

.子程序 临界_销毁, 逻辑型, , 
.参数 临界资源, 临界许可, , 

返回 (不等于 (DeleteCriticalSection_临界许可 (临界资源), 0))

.子程序 临界_进入, 空白型, , 
.参数 临界资源, 临界许可, , 

EnterCriticalSection_临界许可 (临界资源)

.子程序 临界_退出, 空白型, , 
.参数 临界资源, 临界许可, , 

LeaveCriticalSection_临界许可 (临界资源)

.子程序 临界_尝试进入, 逻辑型, , 
.参数 临界资源, 临界许可, , 

返回 (TryEnterCriticalSection_临街许可 (临界资源))


.类模块 鱼刺类_临界许可, , , 临界许可/临界资源(面向对象)。是最简单有效的防止线程内数据交换冲突的办法之一。(初始化类时自动创建临界资源，销毁类时自动销毁临界资源。) 

.程序集变量 临界资源, 临界许可, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
InitializeCriticalSection_临界许可 (临界资源)

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
DeleteCriticalSection_临界许可 (临界资源)

.子程序 进入, 空白型, , 
EnterCriticalSection_临界许可 (临界资源)

.子程序 退出, 空白型, , 
LeaveCriticalSection_临界许可 (临界资源)

.子程序 尝试进入, 逻辑型, , 
返回 (TryEnterCriticalSection_临街许可 (临界资源))

.程序集 线程池, , , 鱼刺类_线程池。(面向过程)

.子程序 线程池_任务函数, 空白型, , 
.参数 ptr, 整数型, , 

.局部变量 局部_参数一, 整数型, , , 
.局部变量 局部_参数二, 整数型, , , 
.局部变量 局部_函数地址, 整数型, , , 
.局部变量 局部_任务结果, 逻辑型, , , 

InterlockedIncrement_ptr (_加法 (ptr, 12)) ' 任务站递增
赋值 (局部_函数地址, _读整数Ex (ptr, 24)) ' event
.如果真 (不等于 (局部_函数地址, 0))
    SetEvent (局部_函数地址)
.如果真结束
赋值 (局部_任务结果, GetQueuedCompletionStatus (_读整数Ex (ptr, 4), 局部_参数一, 局部_参数二, 局部_函数地址, -1))
.判断循环首 (并且 (等于 (_读整数Ex (ptr, 8), 1), 不等于 (局部_函数地址, -2), 等于 (局部_任务结果, 真)))
     ' 先加执行后减队列是为了能精确判断 是否空闲()
    InterlockedIncrement_ptr (_加法 (ptr, 16)) ' 执行递增
    InterlockedDecrement_ptr (_加法 (ptr, 20)) ' 队列递减
    
     ' 执行任务楼
    调用子程序_asm (局部_函数地址, 局部_参数一, 局部_参数二)
    
    InterlockedDecrement_ptr (_加法 (ptr, 16)) ' 执行递减
    
    赋值 (局部_任务结果, GetQueuedCompletionStatus (_读整数Ex (ptr, 4), 局部_参数一, 局部_参数二, 局部_函数地址, -1))
.判断循环尾 ()
 ' API版的原子锁可得到递减后的结果 所以也可达到精确判断
赋值 (局部_参数一, InterlockedDecrement_ptr (_加法 (ptr, 12))) ' 任务站递减
.如果真 (等于 (局部_参数一, 0))
     ' 全部销毁消息都接收到了 直接销毁IOCP
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 4), 0)) ' 赋值
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, _读整数Ex (ptr, 24))
    .如果真 (不等于 (局部_函数地址, 0)) ' event
        赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 24), 0)) ' 赋值
        SetEvent (局部_函数地址)
        CloseHandle (局部_函数地址)
    .如果真结束
    
     ' 还原初始化状态
    _写整数Ex (ptr, 8, 0)
    
    _写整数Ex (ptr, 12, 0) ' 任务站
    _写整数Ex (ptr, 16, 0) ' 执行
    _写整数Ex (ptr, 20, 0) ' 队列
    
    _写整数 (ptr, #线程池_未启动) ' 赋值
    Sleep (10) ' 延时防止内存读取问题
    HeapFree (DefaultHeap, 0, ptr) ' 释放内存
.如果真结束
返回 ()

.子程序 线程池_创建, 整数型, , 创建并启动线程池，并开始等待任务投递。成功返回真，失败返回假。
.参数 参数_线程池容量, 整数型, 可空, 同时工作的线程数。留空为 5
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止创建时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_线程池容量, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 局_time, 整数型, , , 
.局部变量 局_int, 整数型, , , 
.局部变量 局_int2, 整数型, , , 
.局部变量 匿名局部变量_7055, 空白型, , , 
.局部变量 ptr, 整数型, , , 
.局部变量 int, 整数型, , , 

 ' 状态 IOCP 循环条件 任务站容量 执行线程数 队列任务数 Event
赋值 (ptr, HeapAlloc (DefaultHeap, 8, 28))
.如果真 (等于 (ptr, 0))
    返回 (0)
.如果真结束

.判断开始 (等于 (是否为空 (参数_线程池容量), 真))
    赋值 (局_线程池容量, 5)
.判断 (小于 (参数_线程池容量, 1))
    赋值 (局_线程池容量, 1)
.默认
    赋值 (局_线程池容量, 参数_线程池容量)
.判断结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束


赋值 (int, CreateIoCompletionPort (-1, 0, 0, 0))
.如果真 (等于 (int, 0))
    HeapAlloc (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束

_写整数Ex (ptr, 4, int) ' IOCP

_写整数Ex (ptr, 8, 1) ' 触发循环

赋值 (int, CreateEvent_int (0, 假, 假, 0))
.如果真 (不等于 (int, 0))
    _写整数Ex (ptr, 24, int)
.如果真结束

.计次循环首 (局_线程池容量, ) ' 一个个地创建线程。
    赋值 (局_time, CreateThread (0, 局_初始栈大小, &线程池_任务函数, ptr, 0, 0))
    .判断开始 (不等于 (局_time, 0))
        CloseHandle (局_time)
        赋值 (局_int, 相加 (局_int, 1)) ' 为了防止创建线超出系统程极限而导致时间等待过长。
        赋值 (局_int2, 0)
    .默认
        赋值 (局_int2, 相加 (局_int2, 1))
        .如果真 (大于或等于 (局_int2, 5)) ' 连续5次创建线程失败跳出。
            跳出循环 ()
        .如果真结束
        
    .判断结束
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()
.如果真 (大于 (局_int, 0))
     ' 下面是防止立即销毁时线程还没得到IOCP导致有部分线程未能被销毁。
    赋值 (局_time, GetTickCount ())
    赋值 (局_int2, 相加 (相乘 (局_int, 10), 1000))
    .判断循环首 (并且 (小于 (_读整数Ex (ptr, 12), 局_int), 小于 (相减 (GetTickCount (), 局_time), 局_int2)))
        .判断开始 (不等于 (int, 0))
            WaitForSingleObject (int, 20)
        .默认
            Sleep (1)
        .判断结束
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
.如果真 (不等于 (int, 0))
    _写整数Ex (ptr, 24, 0)
    CloseHandle (int)
.如果真结束
.如果真 (等于 (_读整数Ex (ptr, 12), 0))
    CloseHandle (_读整数Ex (ptr, 4))
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束

_写整数 (ptr, #线程池_正在工作)

返回 (ptr)

.子程序 线程池_销毁, 逻辑型, , 销毁线程池。成功或已经销毁返回真，失败返回假。（失败原因包括：线程池已经正销毁、线程池正在创建、到了超时时间） 
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_销毁方式, 整数型, 可空, 0=正常销毁（等待当前任务执行后返回 真 ），1=温柔销毁（等待投递进去的任务全部执行完毕后返回 真 ），2=强制销毁（丢出销毁命令后立即返回 真  注意：此方式执行成功后不代表线程池已经销毁！依然是按照正常销毁那样 当前任务执行完毕后线程池才算真正销毁。），3=强制温柔销毁(丢出温柔销毁命令后立即返回 真 。注意：此方式执行成功后不代表线程池已经销毁！依然是按照温柔销毁那样 投递进去的任务全部执行完毕后线程池才算真正销毁。)。提示：执行强制销毁后可通过 取_状态() 方法来继续探测线程池当前的状态。
.参数 参数_最长等待时间, 整数型, 可空, 注意：此参数只对非强制销毁有效。单位：毫秒，留空或 0 一直等待。 否则到了超时时间会立即返回 假 。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止销毁时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 局部_销毁方式, 整数型, , , 
.局部变量 局部_T, 整数型, , , 
.局部变量 event, 整数型, , , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (假)
.如果真结束
赋值 (局部_T, InterlockedCompareExchange_ptr (参数_线程池句柄, #线程池_正在销毁, #线程池_正在工作)) ' 三目运算 设置正在销毁状态
.判断开始 (等于 (局部_T, #线程池_未启动)) ' 0 = 已经结束
    返回 (真)
.判断 (不等于 (局部_T, #线程池_正在工作)) ' 2 = 正在创建  ' 3 = 正在销毁
    返回 (假)
.默认
    
.判断结束
赋值 (局部_销毁方式, 参数_销毁方式)
.如果真 (或者 (大于 (局部_销毁方式, 3), 小于 (局部_销毁方式, 0)))
    赋值 (局部_销毁方式, 0)
.如果真结束
.如果真 (小于 (局部_销毁方式, 2))
    赋值 (event, CreateEvent_int (0, 假, 假, 0))
    .如果真 (不等于 (event, 0))
        _写整数Ex (参数_线程池句柄, 24, event)
    .如果真结束
    
.如果真结束
.如果真 (或者 (等于 (局部_销毁方式, 0), 等于 (局部_销毁方式, 2)))
    _写整数Ex (参数_线程池句柄, 8, 0) ' 循环条件=假
.如果真结束

 ' 通知任务站不要堵塞了
.计次循环首 (_读整数Ex (参数_线程池句柄, 12), 局部_T) ' 任务站数量
    PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), -1, -1, -2)
    .如果真 (并且 (等于 (参数_是否在UI线程, 真), 等于 (求余数 (局部_T, 100), 0)))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()

.如果真 (小于 (局部_销毁方式, 2))
    .如果真 (大于 (参数_最长等待时间, 0))
        赋值 (局部_T, GetTickCount ())
    .如果真结束
    .判断循环首 (等于 (_读整数 (参数_线程池句柄), #线程池_正在销毁))
        .如果真 (大于 (参数_最长等待时间, 0))
            .如果真 (大于 (相减 (GetTickCount (), 局部_T), 参数_最长等待时间))
                返回 (假)
            .如果真结束
            
        .如果真结束
        .判断开始 (不等于 (event, 0))
            WaitForSingleObject (_读整数Ex (参数_线程池句柄, 24), 20)
        .默认
            Sleep (1)
        .判断结束
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
返回 (真)

.子程序 线程池_投递任务, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_执行函数, 子程序指针, , &子程序指针
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 局部_执行函数, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

赋值 (局部_执行函数, 到整数 (参数_执行函数))
.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作), 等于 (局部_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement_ptr (_加法 (参数_线程池句柄, 20)) ' 队列递增
赋值 (bool, PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), 参数_参数一, 参数_参数二, 局部_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement_ptr (_加法 (参数_线程池句柄, 20)) ' 队列递减
.如果真结束
返回 (bool)

.子程序 线程池_投递任务_int, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_执行函数, 整数型, , 整数型指针 或 到整数(&子程序指针)
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 bool, 逻辑型, , , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作), 等于 (参数_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement_ptr (_加法 (参数_线程池句柄, 20)) ' 队列递增
赋值 (bool, PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), 参数_参数一, 参数_参数二, 参数_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement_ptr (_加法 (参数_线程池句柄, 20)) ' 队列递减
.如果真结束
返回 (bool)

.子程序 线程池_取_空闲线程数, 整数型, 公开, 空闲的线程数量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)' 本源码来自易语言资源网(www.5A5X.com)
.如果真结束
返回 (_减法 (_读整数Ex (参数_线程池句柄, 12), _读整数Ex (参数_线程池句柄, 16)))

.子程序 线程池_取_执行线程数, 整数型, 公开, 正在执行的任务数量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 16))

.子程序 线程池_取_队列任务数, 整数型, , 等待处理的任务数量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 20))

.子程序 线程池_取_线程池容量, 整数型, , 创建时候的容量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 12))

.子程序 线程池_取_是否空闲, 逻辑型, , 线程池处于彻底空闲状态，没有任何任务在执行。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (真)
.如果真结束
返回 (并且 (等于 (_读整数Ex (参数_线程池句柄, 20), 0), 等于 (_读整数Ex (参数_线程池句柄, 16), 0)))

.子程序 线程池_取状态, 整数型, , 0=未启动，1=正在工作，2=正在创建，3=正在销毁。
.参数 参数_线程池句柄, 整数型, , 

.局部变量 ret, 整数型, , , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
赋值 (ret, _读整数 (参数_线程池句柄))
返回 (选择 (或者 (大于 (ret, 3), 小于 (ret, 0)), 0, ret))


.类模块 鱼刺类_线程池, , , 鱼刺线程池(面向对象)。功能多、效率快、超稳定、兼容各种环境下频繁调用。（需手动创建线程池。如果已创建，类销毁时会自动销毁线程池。）

.程序集变量 回调地址_任务函数, 整数型, , , 
.程序集变量 匿名程序集变量_5417, 空白型, , , 
.程序集变量 IOCP任务站, 整数型, , , 
.程序集变量 工作状态, 整数型, , , 0未启动 1运行中 2正在创建 3正在销毁
.程序集变量 循环条件, 逻辑型, , , 这个变量来控制线程池结束状态
.程序集变量 任务站数量, 整数型, , , 
.程序集变量 执行任务数量, 整数型, , , 
.程序集变量 队列任务数量, 整数型, , , 
.程序集变量 Event专用, 整数型, , , 销毁专用
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
赋值 (回调地址_任务函数, 类回调_生成类函数地址 (1))

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 (2)
类回调_释放类函数地址 (回调地址_任务函数)

.子程序 任务函数, 空白型, , 
.局部变量 局部_参数一, 整数型, , , 
.局部变量 局部_参数二, 整数型, , , 
.局部变量 局部_函数地址, 整数型, , , 
.局部变量 局部_任务结果, 逻辑型, , , 

InterlockedIncrement (任务站数量) ' 递增
.如果真 (不等于 (Event专用, 0))
    SetEvent (Event专用)
.如果真结束
赋值 (局部_任务结果, GetQueuedCompletionStatus (IOCP任务站, 局部_参数一, 局部_参数二, 局部_函数地址, -1))
.判断循环首 (并且 (等于 (循环条件, 真), 不等于 (局部_函数地址, -2), 等于 (局部_任务结果, 真)))
     ' 先加执行后减队列是为了能精确判断 是否空闲()
    InterlockedIncrement (执行任务数量) ' 递增
    InterlockedDecrement (队列任务数量) ' 递减
    
     ' 执行任务楼
    调用子程序_asm (局部_函数地址, 局部_参数一, 局部_参数二)
    
    InterlockedDecrement (执行任务数量) ' 递减
    
    赋值 (局部_任务结果, GetQueuedCompletionStatus (IOCP任务站, 局部_参数一, 局部_参数二, 局部_函数地址, -1))
.判断循环尾 ()
 ' API版的原子锁可得到递减后的结果 所以也可达到精确判断
赋值 (局部_参数一, InterlockedDecrement (任务站数量)) ' 递减
.如果真 (等于 (局部_参数一, 0))
     ' 全部销毁消息都接收到了 直接销毁IOCP
    赋值 (局部_函数地址, InterlockedExchange (IOCP任务站, 0)) ' 赋值
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    .如果真 (不等于 (Event专用, 0))
        赋值 (局部_函数地址, InterlockedExchange (Event专用, 0)) ' 赋值
        SetEvent (局部_函数地址)
        CloseHandle (局部_函数地址)
    .如果真结束
    
     ' 还原初始化状态
    赋值 (循环条件, 假)
    连续赋值 (0, 任务站数量, 执行任务数量, 队列任务数量)
    
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
.如果真结束
返回 ()

.子程序 创建, 逻辑型, , 创建并启动线程池，并开始等待任务投递。成功返回真，失败返回假。
.参数 参数_线程池容量, 整数型, 可空, 同时工作的线程数。留空为 5
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止创建时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_线程池容量, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 局_time, 整数型, , , 
.局部变量 局_int, 整数型, , , 
.局部变量 局_int2, 整数型, , , 

赋值 (局_int, InterlockedCompareExchange (工作状态, #线程池_正在创建, #线程池_未启动)) ' 三目运算
.如果真 (不等于 (局_int, #线程池_未启动))
    返回 (假)
.如果真结束

.判断开始 (等于 (是否为空 (参数_线程池容量), 真))
    赋值 (局_线程池容量, 5)
.判断 (小于 (参数_线程池容量, 1))
    赋值 (局_线程池容量, 1)
.默认
    赋值 (局_线程池容量, 参数_线程池容量)
.判断结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (IOCP任务站, CreateIoCompletionPort (-1, 0, 0, 0))
.如果真 (等于 (IOCP任务站, 0))
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (循环条件, 真) ' 触发循环
连续赋值 (0, 任务站数量, 执行任务数量, 队列任务数量, 局_int, 局_int2)

赋值 (Event专用, CreateEvent_int (0, 假, 假, 0))

.计次循环首 (局_线程池容量, ) ' 创建线程。
    赋值 (局_time, CreateThread_Int (0, 局_初始栈大小, 回调地址_任务函数, 0, 0, 0))
    .判断开始 (不等于 (局_time, 0))
        CloseHandle (局_time)
        赋值 (局_int, 相加 (局_int, 1)) ' 为了防止创建线超出系统程极限而导致时间等待过长。
        赋值 (局_int2, 0)
    .默认
        赋值 (局_int2, 相加 (局_int2, 1))
        .如果真 (大于或等于 (局_int2, 5)) ' 连续5次创建线程失败跳出。
            跳出循环 ()
        .如果真结束
        
    .判断结束
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()
.如果真 (大于 (局_int, 0))
     ' 下面是防止立即销毁时线程还没得到IOCP导致有部分线程未能被销毁。
    赋值 (局_time, GetTickCount ())
    赋值 (局_int2, 相加 (相乘 (局_int, 10), 1000))
    .判断循环首 (并且 (小于 (任务站数量, 局_int), 小于 (相减 (GetTickCount (), 局_time), 局_int2)))
        .判断开始 (不等于 (Event专用, 0))
            WaitForSingleObject (Event专用, 20)
        .默认
            Sleep (1)
        .判断结束
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
.如果真 (不等于 (Event专用, 0))
    CloseHandle (Event专用)
    赋值 (Event专用, 0)
.如果真结束
.如果真 (等于 (任务站数量, 0))
    赋值 (循环条件, 假)
    CloseHandle (IOCP任务站)
    赋值 (IOCP任务站, 0)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束


InterlockedExchange (工作状态, #线程池_正在工作) ' 赋值

返回 (真)

.子程序 销毁, 逻辑型, , 销毁线程池。成功或已经销毁返回真，失败返回假。（失败原因包括：线程池已经正销毁、线程池正在创建、到了超时时间） 
.参数 参数_销毁方式, 整数型, 可空, 0=正常销毁（等待当前任务执行后返回 真 ），1=温柔销毁（等待投递进去的任务全部执行完毕后返回 真 ），2=强制销毁（丢出销毁命令后立即返回 真  注意：此方式执行成功后不代表线程池已经销毁！依然是按照正常销毁那样 当前任务执行完毕后线程池才算真正销毁。），3=强制温柔销毁(丢出温柔销毁命令后立即返回 真 。注意：此方式执行成功后不代表线程池已经销毁！依然是按照温柔销毁那样 投递进去的任务全部执行完毕后线程池才算真正销毁。)。提示：执行强制销毁后可通过 取_状态() 方法来继续探测线程池当前的状态。
.参数 参数_最长等待时间, 整数型, 可空, 注意：此参数只对非强制销毁有效。单位：毫秒，留空或 0 一直等待。 否则到了超时时间会立即返回 假 。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止销毁时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 局部_销毁方式, 整数型, , , 
.局部变量 局部_T, 整数型, , , 


赋值 (局部_T, InterlockedCompareExchange (工作状态, #线程池_正在销毁, #线程池_正在工作)) ' 三目运算 设置正在销毁状态
.如果真 (等于 (局部_T, #线程池_未启动)) ' 0 = 已经结束
    返回 (真)
.如果真结束
.如果真 (或者 (等于 (局部_T, #线程池_正在创建), 等于 (局部_T, #线程池_正在销毁))) ' 2 = 正在创建  ' 3 = 正在销毁
    返回 (假)
.如果真结束

赋值 (局部_销毁方式, 参数_销毁方式)
.如果真 (或者 (大于 (局部_销毁方式, 3), 小于 (局部_销毁方式, 0)))
    赋值 (局部_销毁方式, 0)
.如果真结束
.如果真 (小于 (局部_销毁方式, 2))
    赋值 (Event专用, CreateEvent_int (0, 假, 假, 0))
.如果真结束
.如果真 (或者 (等于 (局部_销毁方式, 0), 等于 (局部_销毁方式, 2)))
    赋值 (循环条件, 假)
.如果真结束

 ' 通知任务站不要堵塞了
.计次循环首 (任务站数量, 局部_T)
    PostQueuedCompletionStatus (IOCP任务站, -1, -1, -2)
    .如果真 (并且 (等于 (参数_是否在UI线程, 真), 等于 (求余数 (局部_T, 100), 0)))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()

.如果真 (小于 (局部_销毁方式, 2))
    .如果真 (大于 (参数_最长等待时间, 0))
        赋值 (局部_T, GetTickCount ())
    .如果真结束
    .判断循环首 (等于 (工作状态, #线程池_正在销毁))
        .如果真 (大于 (参数_最长等待时间, 0))
            .如果真 (大于 (相减 (GetTickCount (), 局部_T), 参数_最长等待时间))
                返回 (假)
            .如果真结束
            
        .如果真结束
        .判断开始 (不等于 (Event专用, 0))
            WaitForSingleObject (Event专用, 20)
        .默认
            Sleep (1)
        .判断结束
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
返回 (真)

.子程序 投递任务, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_执行函数, 子程序指针, , &子程序指针
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 局部_执行函数, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

赋值 (局部_执行函数, 到整数 (参数_执行函数))
.如果真 (或者 (不等于 (工作状态, #线程池_正在工作), 等于 (局部_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement (队列任务数量) ' 递增
赋值 (bool, PostQueuedCompletionStatus (IOCP任务站, 参数_参数一, 参数_参数二, 局部_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement (队列任务数量) ' 递减
.如果真结束
返回 (bool)

.子程序 投递任务_int, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_执行函数, 整数型, , 整数型指针 或 到整数(&子程序指针)
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 bool, 逻辑型, , , 

.如果真 (或者 (不等于 (工作状态, #线程池_正在工作), 等于 (参数_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement (队列任务数量) ' 递增
赋值 (bool, PostQueuedCompletionStatus (IOCP任务站, 参数_参数一, 参数_参数二, 参数_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement (队列任务数量) ' 递减
.如果真结束
返回 (bool)

.子程序 取_空闲线程数, 整数型, , 空闲的线程数量。
返回 (_减法 (任务站数量, 执行任务数量))
 ' 返回 (任务站数量 － 执行任务数量)

.子程序 取_执行线程数, 整数型, , 正在执行的任务数量。
返回 (执行任务数量)

.子程序 取_队列任务数, 整数型, , 等待处理的任务数量。
返回 (队列任务数量)

.子程序 取_线程池容量, 整数型, , 创建时候的容量。
返回 (任务站数量)

.子程序 取_是否空闲, 逻辑型, , 线程池处于彻底空闲状态，没有任何任务在执行。
返回 (并且 (等于 (队列任务数量, 0), 等于 (执行任务数量, 0)))

.子程序 取_状态, 整数型, , 0=未启动，1=正在工作，2=正在创建，3=正在销毁。
返回 (工作状态)

.程序集 信号量, , , 信号量。面向过程

.子程序 信号量_创建, 整数型, , 创建一个信号量。成功返回信号量句柄，失败返回0 。
.参数 初始数值, 整数型, 可空, 
.参数 最大数值, 整数型, 可空, 如果留空 默认为1
.参数 标识, 文本型, 可空, 

返回 (CreateSemaphore (0, 初始数值, 选择 (等于 (是否为空 (最大数值), 真), 1, 最大数值), 标识))

.子程序 信号量_打开, 整数型, , 打开一个信号量。成功返回信号量句柄，失败返回0 。
.参数 标识, 文本型, 可空, 

返回 (OpenSemaphore (2031619, 真, 标识))

.子程序 信号量_销毁, 逻辑型, , 销毁指定信号量。
.参数 句柄, 整数型, , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
返回 (CloseHandle (句柄))

.子程序 信号量_增加, 逻辑型, , 成功返回真，失败返回假。
.参数 句柄, 整数型, , 
.参数 递增数值, 整数型, 可空, 留空为1 要增加的值，这个值必须大于0，如果信号量加上这个值会导致信号量的当前值大于信号量创建时指定的最大值，那么这个信号量的当前值不变，同时这个函数返回假。
.参数 返回递增前的值, 整数型, 参考 可空, 返回信号量上次的值（被增加前的值）。

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
.如果真 (等于 (是否为空 (递增数值), 真))
    赋值 (递增数值, 1)
.如果真结束
返回 (ReleaseSemaphore (句柄, 递增数值, 返回递增前的值))

.子程序 信号量_递减, 逻辑型, , 成功返回真，失败返回假。
.参数 句柄, 整数型, , 
.参数 超时值, 整数型, 可空, 

.局部变量 ret, 整数型, , , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (句柄, 选择 (等于 (是否为空 (超时值), 真), -1, 超时值)))
返回 (等于 (ret, 0))


.类模块 鱼刺类_信号量, , , 信号量(面向对象)。多用于控制线程数量。(注意：因能跨进程使用的特性 需手动创建 打开 销毁。)

.程序集变量 handle, 整数型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 创建, 逻辑型, , 创建成功返回真 失败返回假
.参数 初始数值, 整数型, 可空, 
.参数 最大数值, 整数型, 可空, 如果留空 默认为1
.参数 标识, 文本型, 可空, 

.局部变量 int, 整数型, , , 

赋值 (int, InterlockedCompareExchange (handle, 0, 0)) ' 三目运算
.如果真 (不等于 (int, 0))
    返回 (真)
.如果真结束
赋值 (handle, CreateSemaphore (0, 初始数值, 选择 (等于 (是否为空 (最大数值), 真), 1, 最大数值), 标识))
返回 (不等于 (handle, 0))

.子程序 打开, 逻辑型, 公开, 打开成功返回真 失败返回假
.参数 标识, 文本型, 可空, 

.局部变量 int, 整数型, , , 

赋值 (int, InterlockedCompareExchange (handle, 0, 0)) ' 三目运算
.如果真 (不等于 (int, 0))
    返回 (真)
.如果真结束
赋值 (handle, OpenSemaphore (2031619, 真, 标识))
返回 (不等于 (handle, 0))

.子程序 销毁, 逻辑型, , 销毁内部信号量句柄
.局部变量 int, 整数型, , , 

赋值 (int, InterlockedExchange (handle, 0)) ' 赋值
.如果真 (等于 (int, 0))
    返回 (真)
.如果真结束
返回 (CloseHandle (int))

.子程序 是否已创建, 逻辑型, , 用来判断 是否已经创建或打开。（真=已经创建或打开，假=对象为空。）
返回 (不等于 (handle, 0))

.子程序 取句柄, 整数型, , 返回类内部的信号量句柄
返回 (handle)

.子程序 置句柄, 空白型, , 设置类内部句柄
.参数 句柄, 整数型, , 

赋值 (handle, 句柄)

.子程序 增加, 逻辑型, , 成功返回真，失败返回假。
.参数 递增数值, 整数型, 可空, 留空为1 要增加的值，这个值必须大于0，如果信号量加上这个值会导致信号量的当前值大于信号量创建时指定的最大值，那么这个信号量的当前值不变，同时这个函数返回假。
.参数 返回递增前的值, 整数型, 参考 可空, 返回信号量上次的值（被增加前的值）。

.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
.如果真 (等于 (是否为空 (递增数值), 真))
    赋值 (递增数值, 1)
.如果真结束
返回 (ReleaseSemaphore (handle, 递增数值, 返回递增前的值))

.子程序 递减, 逻辑型, , 成功返回真，失败返回假。
.参数 超时值, 整数型, 可空, 

.局部变量 ret, 整数型, , , 

.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (handle, 选择 (等于 (是否为空 (超时值), 真), -1, 超时值)))
返回 (等于 (ret, 0))


.程序集 互斥锁, , , 互斥量 面向过程

.子程序 互斥_创建, 整数型, , 创建一个互斥量。成功返回互斥量对象句柄，失败返回0 。
.参数 参数_创建后立即进入, 逻辑型, 可空, 
.参数 参数_标识, 文本型, 可空, 

返回 (CreateMutex (0, 参数_创建后立即进入, 参数_标识))

.子程序 互斥_打开, 整数型, , 打开一个已创建的互斥量。成功返回互斥量对象句柄，失败返回0 。
.参数 参数_打开后立即进入, 逻辑型, 可空, 
.参数 参数_标识, 文本型, 可空, 

返回 (OpenMutex (2031617, 参数_打开后立即进入, 参数_标识))

.子程序 互斥_销毁, 逻辑型, , 销毁指定互斥量对象
.参数 参数_互斥量对象句柄, 整数型, , 创建 或 打开 得来的对象句柄

.如果真 (等于 (参数_互斥量对象句柄, 0))
    返回 (假)
.如果真结束
返回 (CloseHandle (参数_互斥量对象句柄))

.子程序 互斥_进入, 逻辑型, 公开, 等待并进入/拥有这个互斥量。成功返回真，失败/超时/句柄无效返回假。
.参数 参数_互斥量对象句柄, 整数型, , 创建 或 打开 得来的对象句柄
.参数 参数_超时值, 整数型, 可空, 单位:毫秒，留空为 -1 无限等待

.局部变量 ret, 整数型, , , 

.如果真 (等于 (参数_互斥量对象句柄, 0))
    返回 (假)' 本源码来自易语言资源网(www.5A5X.com)
.如果真结束
赋值 (ret, WaitForSingleObject (参数_互斥量对象句柄, 选择 (等于 (是否为空 (参数_超时值), 真), -1, 参数_超时值)))
返回 (等于 (ret, 0))

.子程序 互斥_退出, 逻辑型, , 退出/释放这个互斥量。成功返回真，失败返回假。
.参数 参数_互斥量对象句柄, 整数型, , 创建 或 打开 得来的对象句柄

.如果真 (等于 (参数_互斥量对象句柄, 0))
    返回 (假)
.如果真结束
返回 (ReleaseMutex (参数_互斥量对象句柄))


.类模块 鱼刺类_互斥锁, , , 互斥量/互斥体(面向对象)。 速度比临界资源要慢。但可以跨进程使用。( 需手动创建 打开 销毁。)

.程序集变量 handle, 整数型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 创建, 逻辑型, , 创建一个互斥量。成功返回真，失败返回假冒 。
.参数 参数_创建后立即进入, 逻辑型, 可空, 
.参数 参数_标识, 文本型, 可空, 

.局部变量 int, 整数型, , , 

赋值 (int, InterlockedCompareExchange (handle, 0, 0))
.如果真 (不等于 (int, 0))
    返回 (真)
.如果真结束
赋值 (handle, CreateMutex (0, 参数_创建后立即进入, 参数_标识))
返回 (不等于 (handle, 0))

.子程序 打开, 逻辑型, , 打开一个已创建的互斥量。成功返回真，失败返回假 。
.参数 参数_打开后立即进入, 逻辑型, 可空, 
.参数 参数_标识, 文本型, 可空, 

.局部变量 int, 整数型, , , 

赋值 (int, InterlockedCompareExchange (handle, 0, 0))
.如果真 (不等于 (int, 0))
    返回 (真)
.如果真结束
赋值 (handle, OpenMutex (2031617, 参数_打开后立即进入, 参数_标识))
返回 (不等于 (handle, 0))

.子程序 销毁, 逻辑型, , 销毁指定互斥量对象
.局部变量 int, 整数型, , , 

赋值 (int, InterlockedExchange (handle, 0))
.如果真 (等于 (int, 0))
    返回 (真)
.如果真结束
返回 (CloseHandle (int))

.子程序 是否已创建, 逻辑型, , 用来判断 是否已经创建或打开。（真=已经创建或打开，假=对象为空。）
返回 (不等于 (handle, 0))

.子程序 取句柄, 整数型, , 返回类内部的互斥量句柄
返回 (handle)

.子程序 置句柄, 空白型, , 设置类内部句柄
.参数 句柄, 整数型, , 

赋值 (handle, 句柄)

.子程序 进入, 逻辑型, , 等待并进入/拥有这个互斥量。成功返回真，失败/超时/句柄无效返回假。
.参数 参数_超时值, 整数型, 可空, 单位:毫秒，留空为 -1 无限等待

.局部变量 ret, 整数型, , , 

.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (handle, 选择 (等于 (是否为空 (参数_超时值), 真), -1, 参数_超时值)))
返回 (等于 (ret, 0))

.子程序 退出, 逻辑型, , 退出/释放这个互斥量。成功返回真，失败返回假。
.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
返回 (ReleaseMutex (handle))

.程序集 事件, , , Event对象 (面向过程)

.子程序 事件_创建, 整数型, , 创建一个 Event事件对象。创建成功返回对象句柄，失败返回0 。
.参数 手动重置, 逻辑型, 可空, 指定将事件对象创建成手动复原还是自动复原。如果是真，那么必须用 重置() 来手工将事件的状态复原到无信号状态(重置状态)。如果设置为假，当事件被一个等待线程释放以后，系统将会自动将事件状态复原为无信号状态(重置状态)。
.参数 初始化状态, 逻辑型, 可空, 指定事件对象的初始状态。如果为TRUE，初始状态为有信号状态(触发)；否则为无信号状态(重置)
.参数 标识, 文本型, 可空, 指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在255之内。名字是对大小写敏感的。

返回 (CreateEvent (0, 手动重置, 初始化状态, 标识))

.子程序 事件_打开, 整数型, , 打开一个已创建的 Event事件对象。创建成功返回对象句柄，失败返回0 。
.参数 立即触发, 逻辑型, 可空, 打开后立即触发拥有
.参数 标识, 文本型, 可空, 指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在255之内。名字是对大小写敏感的。

返回 (OpenEvent (2031619, 立即触发, 标识))

.子程序 事件_销毁, 逻辑型, , 销毁指定Event事件对象。成功返回真，失败返回假。
.参数 句柄, 整数型, , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
返回 (CloseHandle (句柄))

.子程序 事件_触发, 逻辑型, , 将Event事件对象设置为发信号状态，触发状态。
.参数 句柄, 整数型, , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
返回 (SetEvent (句柄))

.子程序 事件_重置, 逻辑型, , 将Event事件对象设置为无信号状态，重置/非触发状态。
.参数 句柄, 整数型, , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
返回 (ResetEvent (句柄))

.子程序 事件_触发并重置, 逻辑型, , 先触发然后马上重置。有很多妙用。
.参数 句柄, 整数型, , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
返回 (PulseEvent (句柄))

.子程序 事件_等待进入, 逻辑型, , 等待并进入/拥有这个Event事件对象。成功返回真，失败/超时/句柄无效返回假。
.参数 句柄, 整数型, , 
.参数 超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.局部变量 ret, 整数型, , , 

.如果真 (等于 (句柄, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (句柄, 选择 (等于 (是否为空 (超时值), 真), -1, 超时值)))
返回 (等于 (ret, 0))


.类模块 鱼刺类_事件, , , Event对象(面向对象)。(需手动创建 打开 销毁。)

.程序集变量 handle, 整数型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 创建, 逻辑型, , 创建一个 Event事件对象。创建成功返回真，失败或已创建返回假 。
.参数 手动重置, 逻辑型, 可空, 指定将事件对象创建成手动复原还是自动复原。如果是真，那么必须用 重置() 来手工将事件的状态复原到无信号状态(重置状态)。如果设置为假，当事件被一个等待线程释放以后，系统将会自动将事件状态复原为无信号状态(重置状态)。
.参数 初始化状态, 逻辑型, 可空, 指定事件对象的初始状态。如果为TRUE，初始状态为有信号状态(触发)；否则为无信号状态(重置)
.参数 标识, 文本型, 可空, 指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在255之内。名字是对大小写敏感的。

.局部变量 int, 整数型, , , 

赋值 (int, InterlockedCompareExchange (handle, 0, 0))
.如果真 (不等于 (int, 0))
    返回 (真)
.如果真结束
赋值 (handle, CreateEvent (0, 手动重置, 初始化状态, 标识))
返回 (不等于 (handle, 0))

.子程序 打开, 逻辑型, , 打开一个已创建的 Event事件对象。打开成功返回真，失败或已打开返回假 。
.参数 立即触发, 逻辑型, 可空, 打开后立即触发拥有
.参数 标识, 文本型, 可空, 指定事件的对象的名称，是一个以0结束的字符串指针。名称的字符格式限定在255之内。名字是对大小写敏感的。

.局部变量 int, 整数型, , , 

赋值 (int, InterlockedCompareExchange (handle, 0, 0))
.如果真 (不等于 (int, 0))
    返回 (假)
.如果真结束
赋值 (handle, OpenEvent (2031619, 立即触发, 标识))
返回 (不等于 (handle, 0))

.子程序 销毁, 逻辑型, , 销毁指定Event事件对象。成功返回真，失败或已销毁返回假。
.局部变量 int, 整数型, , , 

赋值 (int, InterlockedExchange (handle, 0))
.如果真 (等于 (int, 0))
    返回 (假)
.如果真结束
返回 (CloseHandle (int))

.子程序 是否已创建, 逻辑型, , 用来判断 是否已经创建或打开。（真=已经创建或打开，假=对象为空。）
返回 (不等于 (handle, 0))

.子程序 取句柄, 整数型, , 返回类内部的事件对象句柄
返回 (handle)

.子程序 置句柄, 空白型, , 设置类内部句柄
.参数 句柄, 整数型, , 

赋值 (handle, 句柄)

.子程序 触发, 逻辑型, , 将Event事件对象设置为发信号状态，触发状态。
.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
返回 (SetEvent (handle))

.子程序 重置, 逻辑型, 公开, 将Event事件对象设置为无信号状态，重置/非触发状态。
.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
返回 (ResetEvent (handle))

.子程序 触发并重置, 逻辑型, , 先触发然后马上重置。有很多妙用。
.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
返回 (PulseEvent (handle))

.子程序 等待进入, 逻辑型, , 等待并进入/拥有这个Event事件对象。成功返回真，失败/超时/句柄无效返回假。
.参数 超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.局部变量 ret, 整数型, , , 

.如果真 (等于 (是否为空 (超时值), 真))
    赋值 (超时值, -1)
.如果真结束
.如果真 (等于 (handle, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (handle, 超时值))
返回 (等于 (ret, 0))


.程序集 线程操作, , , 多线程操作。(面向过程)

.子程序 线程_创建, 逻辑型, , 创建并启动一条线程，成功返回真，失败返回假。
.参数 参数_欲执行的子程序指针, 子程序指针, , 线程子程序指针。
.参数 参数_附加参数数据, 整数型, 可空, 附加参数。
.参数 返回_线程句柄, 整数型, 参考 可空, 留空则会自动关闭句柄。返回线程句柄。
.参数 参数_创建后立即挂起, 逻辑型, 可空, 留空为假。如果为真，创建进程后会立即挂起线程。需要用 线程_恢复() 来恢复继续执行。
.参数 参数_等待执行完毕后返回, 逻辑型, 可空, 如果为 真 创建线程后会等待线程执行完毕后返回
.参数 参数_等待返回超时值, 整数型, 可空, 等待返回专用参数。等待超时。单位:毫秒。留空为 无限等待。(注：如果超时也返回真。您可以通过 返回_线程句柄 来判断是否已经返回或超时。如果已返回 线程句柄返回0。超时还是会返回句柄的。)
.参数 返回_等待返回数据, 整数型, 参考 可空, 等待返回专用参数。返回线程执行完毕后的结果。如果返回类型不为整数型则返回指针。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止等待时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假 
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）
.参数 返回_线程ID, 整数型, 参考 可空, 返回线程标识符ID。

.局部变量 局_是否挂起, 整数型, , , 
.局部变量 局_返回句柄, 整数型, , , 
.局部变量 局_返回值, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 timing, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 ret, 整数型, , , 

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (局_是否挂起, 选择 (等于 (参数_创建后立即挂起, 真), 4, 0))
赋值 (局_返回句柄, CreateThread (0, 局_初始栈大小, 参数_欲执行的子程序指针, 参数_附加参数数据, 局_是否挂起, 返回_线程ID))
.如果真 (等于 (局_返回句柄, 0))
    .如果真 (等于 (是否为空 (返回_线程句柄), 假))
        赋值 (返回_线程句柄, 0)
    .如果真结束
    返回 (假)
.如果真结束
.如果真 (并且 (等于 (参数_等待执行完毕后返回, 真), 等于 (参数_创建后立即挂起, 假)))
    .判断开始 (等于 (参数_是否在UI线程, 真))
        .判断开始 (或者 (等于 (是否为空 (参数_等待返回超时值), 真), 等于 (参数_等待返回超时值, -1)))
            赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环首 (等于 (ret, 258))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
            
        .默认
            
            赋值 (timing, 求余数 (参数_等待返回超时值, 15))
            赋值 (ret, WaitForSingleObject (局_返回句柄, timing))
            赋值 (timing, 整除 (局_返回句柄, 15))
            赋值 (i, 0)
            .判断循环首 (并且 (等于 (ret, 258), 小于 (i, timing)))
                赋值 (i, 相加 (i, 1))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
        .判断结束
        
    .默认
        .如果真 (等于 (是否为空 (参数_等待返回超时值), 真))
            赋值 (参数_等待返回超时值, -1)
        .如果真结束
        赋值 (ret, WaitForSingleObject (局_返回句柄, 参数_等待返回超时值))
    .判断结束
     ' ret:
     ' 0=正常结束
     ' 1=正在执行
     ' 258=超时
     ' -1=句柄无效
    .如果真 (等于 (ret, 0))
        .如果真 (等于 (是否为空 (返回_等待返回数据), 假))
            GetExitCodeThread (局_返回句柄, 局_返回值)
            赋值 (返回_等待返回数据, 局_返回值)
        .如果真结束
        CloseHandle (局_返回句柄)
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (真)
    .如果真结束
    .如果真 (等于 (ret, -1)) ' 句柄无效,可能中途被其他线程关闭
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (假)
    .如果真结束
    
.如果真结束
.判断开始 (等于 (是否为空 (返回_线程句柄), 真))
    CloseHandle (局_返回句柄)
.默认
    赋值 (返回_线程句柄, 局_返回句柄)
.判断结束
返回 (或者 (等于 (ret, 0), 等于 (ret, 258)))

.子程序 线程_创建_int, 逻辑型, , (整数型指针) 创建并启动一条线程，成功返回真，失败返回假。(注意:如果启用了 等待执行后返回 超时也是会返回假的。您可以判断返回线程句柄如果不为0表示超时。可自行接管后续处理。)
.参数 参数_欲执行的子程序指针, 整数型, , 线程子程序指针。例如：到整数(&子程序指针)
.参数 参数_附加参数数据, 整数型, 可空, 附加参数。
.参数 返回_线程句柄, 整数型, 参考 可空, 留空则会自动关闭句柄。返回线程句柄。
.参数 参数_创建后立即挂起, 逻辑型, 可空, 留空为假。如果为真，创建进程后会立即挂起线程。需要用 线程_恢复() 来恢复继续执行。
.参数 参数_等待执行完毕后返回, 逻辑型, 可空, 如果为 真 创建线程后会等待线程执行完毕后返回
.参数 参数_等待返回超时值, 整数型, 可空, 等待返回专用参数。等待超时。单位:毫秒。留空为 无限等待。(注：如果超时也返回真。您可以通过 返回_线程句柄 来判断是否已经返回或超时。如果已返回 线程句柄返回0。超时还是会返回句柄的。)
.参数 返回_等待返回数据, 整数型, 参考 可空, 等待返回专用参数。返回线程执行完毕后的结果。如果返回类型不为整数型则返回指针。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止等待时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假 
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）
.参数 返回_线程ID, 整数型, 参考 可空, 返回线程标识符ID。

.局部变量 局_是否挂起, 整数型, , , 
.局部变量 局_返回句柄, 整数型, , , 
.局部变量 局_返回值, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 timing, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 ret, 整数型, , , 

.如果真 (等于 (参数_欲执行的子程序指针, 0))
    返回 (假)
.如果真结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (局_是否挂起, 选择 (等于 (参数_创建后立即挂起, 真), 4, 0))
赋值 (局_返回句柄, CreateThread_Int (0, 局_初始栈大小, 参数_欲执行的子程序指针, 参数_附加参数数据, 局_是否挂起, 返回_线程ID))
.如果真 (等于 (局_返回句柄, 0))
    .如果真 (等于 (是否为空 (返回_线程句柄), 假))
        赋值 (返回_线程句柄, 0)
    .如果真结束
    返回 (假)
.如果真结束
.如果真 (并且 (等于 (参数_等待执行完毕后返回, 真), 等于 (参数_创建后立即挂起, 假)))
    .判断开始 (等于 (参数_是否在UI线程, 真))
        .判断开始 (或者 (等于 (是否为空 (参数_等待返回超时值), 真), 等于 (参数_等待返回超时值, -1)))
            赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环首 (等于 (ret, 258))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
            
        .默认
            
            赋值 (timing, 求余数 (参数_等待返回超时值, 15))
            赋值 (ret, WaitForSingleObject (局_返回句柄, timing))
            赋值 (timing, 整除 (局_返回句柄, 15))
            赋值 (i, 0)
            .判断循环首 (并且 (等于 (ret, 258), 小于 (i, timing)))
                赋值 (i, 相加 (i, 1))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
        .判断结束
        
    .默认
        .如果真 (等于 (是否为空 (参数_等待返回超时值), 真))
            赋值 (参数_等待返回超时值, -1)
        .如果真结束
        赋值 (ret, WaitForSingleObject (局_返回句柄, 参数_等待返回超时值))
    .判断结束
     ' ret:
     ' 0=正常结束
     ' 1=正在执行
     ' 258=超时
     ' -1=句柄无效
    .如果真 (等于 (ret, 0))
        .如果真 (等于 (是否为空 (返回_等待返回数据), 假))
            GetExitCodeThread (局_返回句柄, 局_返回值)
            赋值 (返回_等待返回数据, 局_返回值)
        .如果真结束
        CloseHandle (局_返回句柄)
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (真)
    .如果真结束
    .如果真 (等于 (ret, -1)) ' 句柄无效,可能中途被其他线程关闭
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (假)
    .如果真结束
    
.如果真结束
.判断开始 (等于 (是否为空 (返回_线程句柄), 真))
    CloseHandle (局_返回句柄)
.默认
    赋值 (返回_线程句柄, 局_返回句柄)
.判断结束
返回 (或者 (等于 (ret, 0), 等于 (ret, 258)))

.子程序 线程_等待, 逻辑型, , 等待线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 线程句柄, 整数型, , 指定为等待的线程句柄。
.参数 超时时间, 整数型, 可空, 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。

.局部变量 ret, 整数型, , , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (线程句柄, 选择 (等于 (是否为空 (超时时间), 真), -1, 超时时间)))
返回 (或者 (等于 (ret, 0), 等于 (ret, -1)))

.子程序 线程_等待2, 逻辑型, , （不影响消息循环/不假死） 等待线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 线程句柄, 整数型, , 指定为等待的线程句柄。
.参数 超时时间, 整数型, 可空, 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。

.局部变量 ret, 整数型, , , 
.局部变量 len, 整数型, , , 
.局部变量 i, 整数型, , , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
.判断开始 (或者 (等于 (是否为空 (超时时间), 真), 等于 (超时时间, -1)))
    赋值 (ret, WaitForSingleObject (线程句柄, 15))
    .判断循环首 (等于 (ret, 258))
        _处理事件 ()
        赋值 (ret, WaitForSingleObject (线程句柄, 15))
    .判断循环尾 ()
    
.默认
    
    赋值 (len, 相加 (整除 (超时时间, 15), 1))
    赋值 (i, 0)
    赋值 (ret, WaitForSingleObject (线程句柄, 15))
    .判断循环首 (并且 (等于 (ret, 258), 小于 (i, len)))
        赋值 (i, 相加 (i, 1))
        _处理事件 ()
        赋值 (ret, WaitForSingleObject (线程句柄, 15))
    .判断循环尾 ()
.判断结束
返回 (或者 (等于 (ret, 0), 等于 (ret, -1)))

.子程序 线程_等待数组, 逻辑型, , 等待一组线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 线程句柄数组, 整数型, 数组, 欲等待的线程对象数组 最多64个成员
.参数 超时时间, 整数型, 可空, 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。
.参数 等待方式, 逻辑型, 可空, 如果指定为'真'函数仅在所有线程的状态都变成 置位 时才返回。 如果指定'假',任意一个对象的状态变成 置位 时就返回。 留空为'真'。

.局部变量 len, 整数型, , , 
.局部变量 ret, 整数型, , , 

赋值 (len, 取数组成员数 (线程句柄数组))
.如果真 (小于 (len, 1))
    返回 (假)
.如果真结束
赋值 (ret, WaitForMultipleObject (len, 线程句柄数组, 选择 (等于 (是否为空 (等待方式), 真), 真, 等待方式), 选择 (等于 (是否为空 (超时时间), 真), -1, 超时时间)))
返回 (或者 (等于 (ret, 0), 等于 (ret, -1)))

.子程序 线程_等待_msg, 逻辑型, , MSG方式不假死。等待线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 线程句柄, 整数型, , 
.参数 等待时间, 整数型, 可空, 单位为毫秒，默认为无限等待。

.局部变量 ret, 整数型, , , 
.局部变量 局部_等待时间, 整数型, , , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
赋值 (局部_等待时间, 选择 (等于 (是否为空 (等待时间), 真), 4294967295, 等待时间))
赋值 (ret, MsgWaitForMultipleObjects (1, 线程句柄, 假, 局部_等待时间, 1215))
.判断循环首 (并且 (不等于 (ret, 0), 不等于 (ret, 258), 不等于 (ret, -1))) ' 0:所有的对象都发出信号，258：超时
    _处理事件 ()
    赋值 (ret, MsgWaitForMultipleObjects (1, 线程句柄, 假, 局部_等待时间, 1215))
.判断循环尾 ()
 ' 0=正常结束
 ' 1=正在执行
 ' 258=超时
 ' -1=句柄无效
返回 (或者 (等于 (ret, 0), 等于 (ret, -1)))

.子程序 线程_挂起, 逻辑型, , 挂起线程 暂停操作 可以用 “恢复” 来继续执行
.参数 线程句柄, 整数型, , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
返回 (不等于 (SuspendThread (线程句柄), -1))

.子程序 线程_恢复, 逻辑型, , 继续运行被挂起的线程
.参数 线程句柄, 整数型, , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
返回 (不等于 (ResumeThread (线程句柄), -1))

.子程序 线程_关闭句柄, 逻辑型, , 只是关闭/销毁线程对象句柄，如果线程正在运行中不会关闭线程。
.参数 线程句柄, 整数型, , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
返回 (CloseHandle (线程句柄))

.子程序 线程_强制结束, 逻辑型, , 强制退结束线程。不靠谱的玩具。
.参数 线程句柄, 整数型, , 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
返回 (TerminateThread (线程句柄, 0))

.子程序 线程_取状态, 整数型, , 0=线程已结束  1=线程正在运行  -1=线程句柄已失效或销毁
.参数 线程句柄, 整数型, , 

.局部变量 ret, 整数型, , , 

.如果真 (等于 (线程句柄, 0))
    返回 (-1)
.如果真结束
赋值 (ret, WaitForSingleObject (线程句柄, 0))
.判断开始 (等于 (ret, 258))
    返回 (1)
.判断 (等于 (ret, -1))
    返回 (-1)
.默认
    返回 (ret)
.判断结束
返回 (0)

.子程序 线程_取返回值, 整数型, , 使用前请保证线程已经运行完毕，如线程尚未中断将返回STILLACTIVE(值为259)。子程序返回值为其他数据类型将返回指针。
.参数 线程句柄, 整数型, , 

.局部变量 返回值, 整数型, , , 

.如果真 (等于 (线程句柄, 0))
    返回 (0)
.如果真结束
GetExitCodeThread (线程句柄, 返回值)
返回 (返回值)

.子程序 线程_取优先级, 整数型, , 取线程优先级
.参数 线程句柄, 整数型, , 

.如果真 (等于 (线程句柄, 0))
    返回 (0)
.如果真结束
返回 (GetThreadPriority (线程句柄))

.子程序 线程_置优先级, 逻辑型, , 设置线程优先级
.参数 线程句柄, 整数型, , 
.参数 优先级, 整数型, 可空, 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
返回 (不等于 (SetThreadPriority (线程句柄, 优先级), 0))

.子程序 线程_置CPU亲和性, 逻辑型, , 设置/绑定CPU执行。（某些情况下可以避免主线程卡死问题）
.参数 线程句柄, 整数型, , 
.参数 亲和性参数, 整数型, 可空, 

.如果真 (等于 (线程句柄, 0))
    返回 (假)
.如果真结束
返回 (不等于 (SetThreadAffinityMask (线程句柄, 亲和性参数), 0))

.子程序 线程_取当前句柄, 整数型, , 取当前所在线程句柄。只要当前线程需要使用一个线程句柄，就可以使用这个伪句柄（但在其他任务线程中都无效）。该句柄可以复制，但不可继承。不必调用CloseHandle函数来关闭这个句柄
返回 (GetCurrentThread ())

.子程序 线程_取当前ID, 整数型, , 获取当前所在线程的唯一线程标识符(线程ID)。成功返回当前所在线程的标识符ID。
返回 (GetCurrentThreadId ())

.子程序 线程_投递信息A, 逻辑型, , 将一个消息放入（寄送）到指定线程的消息队列里，不等待线程处理消息就返回。成功返回真，失败返回假。
.参数 线程ID, 整数型, , 要投递信息的线程标识符/线程ID
.参数 消息类型, 整数型, , 指定将被寄送的消息的类型。
.参数 参数一, 整数型, , 指定附加的消息特定信息。
.参数 参数二, 整数型, , 指定附加的消息特定信息。

返回 (PostThreadMesssgeA (线程ID, 消息类型, 参数一, 参数二))

.子程序 线程_投递信息W, 逻辑型, , 将一个消息放入（寄送）到指定线程的消息队列里，不等待线程处理消息就返回。成功返回真，失败返回假。
.参数 线程ID, 整数型, , 要投递信息的线程标识符/线程ID
.参数 消息类型, 整数型, , 指定将被寄送的消息的类型。
.参数 参数一, 整数型, , 指定附加的消息特定信息。
.参数 参数二, 整数型, , 指定附加的消息特定信息。

返回 (PostThreadMesssgeW (线程ID, 消息类型, 参数一, 参数二))


.类模块 鱼刺类_线程操作, , , 多线程操作 (完全面向对象) 注意： 因类概念方式 创建的线程如果未执行完毕不能再次创建线程。创建的线程在类销毁的时候不会强制结束只会销毁句柄。

.程序集变量 Handle, 整数型, , , 线程句柄
.程序集变量 Tid, 整数型, , , 线程ID
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
关闭句柄 ()

.子程序 _判断, 逻辑型, , 
.参数 kill, 逻辑型, 可空, 自动销毁已经结束的线程

.局部变量 ret, 整数型, , , 
.局部变量 hand, 整数型, , , 

赋值 (hand, InterlockedCompareExchange (Handle, 0, 0))
.如果真 (等于 (hand, 0))
    返回 (真)
.如果真结束
赋值 (ret, WaitForSingleObject (hand, 0))
.判断开始 (等于 (ret, 258)) ' 超时 表示线程正在运行
    返回 (假)
.判断 (等于 (ret, 0)) ' 线程已经结束 然而句柄还没销毁呢
    赋值 (hand, InterlockedExchange (Handle, 0))
    赋值 (Tid, 0)
    .如果真 (并且 (不等于 (hand, 0), 等于 (kill, 真)))
        CloseHandle (hand)
    .如果真结束
    返回 (真)
.判断 (等于 (ret, -1))
    InterlockedExchange (Handle, 0)
    返回 (真)
.默认
    返回 (假)
.判断结束
返回 (假)

.子程序 是否已创建, 逻辑型, , 取当前线程的运行状态。 真=线程正在运行，假=未启动/已结束/句柄已失效。
.局部变量 hand, 整数型, , , 
.局部变量 ret, 整数型, , , 

赋值 (hand, InterlockedCompareExchange (Handle, 0, 0))
.如果真 (等于 (hand, 0))
    返回 (假)
.如果真结束
赋值 (ret, WaitForSingleObject (hand, 0))
.判断开始 (等于 (ret, 258))
    返回 (真)
.判断 (等于 (ret, 0))
    返回 (假)
.判断 (等于 (ret, -1))
    InterlockedExchange (Handle, 0)
    赋值 (Tid, 0)
    返回 (假)
.默认
    返回 (真)
.判断结束
返回 (真)

.子程序 创建, 逻辑型, , 创建并启动一条线程，成功返回真，失败返回假。 如果线程已经被创建或运行中则创建失败。（类概念）
.参数 参数_欲执行的子程序指针, 子程序指针, , 线程子程序指针。
.参数 参数_附加参数数据, 整数型, 可空, 附加参数。
.参数 返回_线程句柄, 整数型, 参考 可空, 返回线程句柄。
.参数 参数_创建后立即挂起, 逻辑型, 可空, 留空为假。如果为真，创建进程后会立即挂起线程。需要用 线程_恢复() 来恢复继续执行。
.参数 参数_等待执行完毕后返回, 逻辑型, 可空, 如果为 真 创建线程后会等待线程执行完毕后返回
.参数 参数_等待返回超时值, 整数型, 可空, 等待返回专用参数。等待超时。单位:毫秒。留空为 无限等待。(注：如果超时也返回真。您可以通过 返回_线程句柄 来判断是否已经返回或超时。如果已返回 线程句柄返回0。超时还是会返回句柄的。)
.参数 返回_等待返回数据, 整数型, 参考 可空, 等待返回专用参数。返回线程执行完毕后的结果。如果返回类型不为整数型则返回指针。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止等待时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假 
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_是否挂起, 整数型, , , 
.局部变量 局_返回句柄, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 局_返回值, 整数型, , , 
.局部变量 timing, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 ret, 整数型, , , 

.如果真 (等于 (_判断 (真), 假))
    返回 (假)
.如果真结束
赋值 (局_返回值, InterlockedCompareExchange (Handle, 1, 0))
.如果真 (不等于 (局_返回值, 0))
    返回 (假)
.如果真结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (局_是否挂起, 选择 (等于 (参数_创建后立即挂起, 真), 4, 0))
赋值 (局_返回句柄, CreateThread (0, 局_初始栈大小, 参数_欲执行的子程序指针, 参数_附加参数数据, 局_是否挂起, Tid))
InterlockedExchange (Handle, 局_返回句柄)
.如果真 (等于 (局_返回句柄, 0))
    .如果真 (等于 (是否为空 (返回_线程句柄), 假))
        赋值 (返回_线程句柄, 0)
    .如果真结束
    返回 (假)
.如果真结束
.如果真 (并且 (等于 (参数_等待执行完毕后返回, 真), 等于 (参数_创建后立即挂起, 假)))
    .判断开始 (等于 (参数_是否在UI线程, 真))
        .判断开始 (或者 (等于 (是否为空 (参数_等待返回超时值), 真), 等于 (参数_等待返回超时值, -1)))
            赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环首 (等于 (ret, 258))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
            
        .默认
            
            赋值 (timing, 求余数 (参数_等待返回超时值, 15))
            赋值 (ret, WaitForSingleObject (局_返回句柄, timing))
            赋值 (timing, 整除 (局_返回句柄, 15))
            赋值 (i, 0)
            .判断循环首 (并且 (等于 (ret, 258), 小于 (i, timing)))
                赋值 (i, 相加 (i, 1))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
        .判断结束
        
    .默认
        .如果真 (等于 (是否为空 (参数_等待返回超时值), 真))
            赋值 (参数_等待返回超时值, -1)
        .如果真结束
        赋值 (ret, WaitForSingleObject (局_返回句柄, 参数_等待返回超时值))
    .判断结束
     ' ret:
     ' 0=正常结束
     ' 1=正在执行
     ' 258=超时
     ' -1=句柄无效
    .如果真 (等于 (ret, 0))
        .如果真 (等于 (是否为空 (返回_等待返回数据), 假))
            GetExitCodeThread (局_返回句柄, 局_返回值)
            赋值 (返回_等待返回数据, 局_返回值)
        .如果真结束
        CloseHandle (局_返回句柄)
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (真)
    .如果真结束
    .如果真 (等于 (ret, -1)) ' 句柄无效,可能中途被其他线程关闭
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (假)
    .如果真结束
    
.如果真结束
.如果真 (等于 (是否为空 (返回_线程句柄), 假))
    赋值 (返回_线程句柄, 局_返回句柄)
.如果真结束
返回 (或者 (等于 (ret, 0), 等于 (ret, 258)))

.子程序 创建_int, 逻辑型, , (整数型指针) 创建并启动一条线程，成功返回真，失败返回假。如果线程已经被创建或运行中则创建失败。（类概念）
.参数 参数_欲执行的子程序指针, 整数型, , 线程子程序指针。例如：到整数(&子程序指针)
.参数 参数_附加参数数据, 整数型, 可空, 附加参数。
.参数 返回_线程句柄, 整数型, 参考 可空, 返回线程句柄。
.参数 参数_创建后立即挂起, 逻辑型, 可空, 留空为假。如果为真，创建进程后会立即挂起线程。需要用 线程_恢复() 来恢复继续执行。
.参数 参数_等待执行完毕后返回, 逻辑型, 可空, 如果为 真 创建线程后会等待线程执行完毕后返回
.参数 参数_等待返回超时值, 整数型, 可空, 等待返回专用参数。等待超时。单位:毫秒。留空为 无限等待。(注：如果超时也返回真。您可以通过 返回_线程句柄 来判断是否已经返回或超时。如果已返回 线程句柄返回0。超时还是会返回句柄的。)
.参数 返回_等待返回数据, 整数型, 参考 可空, 等待返回专用参数。返回线程执行完毕后的结果。如果返回类型不为整数型则返回指针。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止等待时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假 
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_是否挂起, 整数型, , , 
.局部变量 局_返回句柄, 整数型, , , 
.局部变量 局_返回值, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 timing, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 ret, 整数型, , , 

.如果真 (等于 (参数_欲执行的子程序指针, 0))
    返回 (假)
.如果真结束
.如果真 (等于 (_判断 (真), 假))
    返回 (假)
.如果真结束
赋值 (局_返回值, InterlockedCompareExchange (Handle, 1, 0))
.如果真 (不等于 (局_返回值, 0))
    返回 (假)
.如果真结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (局_是否挂起, 选择 (等于 (参数_创建后立即挂起, 真), 4, 0))
赋值 (局_返回句柄, CreateThread_Int (0, 局_初始栈大小, 参数_欲执行的子程序指针, 参数_附加参数数据, 局_是否挂起, 0))
InterlockedExchange (Handle, 局_返回句柄)
.如果真 (等于 (局_返回句柄, 0))
    .如果真 (等于 (是否为空 (返回_线程句柄), 假))
        赋值 (返回_线程句柄, 0)
    .如果真结束
    返回 (假)
.如果真结束
.如果真 (并且 (等于 (参数_等待执行完毕后返回, 真), 等于 (参数_创建后立即挂起, 假)))
    .判断开始 (等于 (参数_是否在UI线程, 真))
        .判断开始 (或者 (等于 (是否为空 (参数_等待返回超时值), 真), 等于 (参数_等待返回超时值, -1)))
            赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环首 (等于 (ret, 258))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
            
        .默认
            
            赋值 (timing, 求余数 (参数_等待返回超时值, 15))
            赋值 (ret, WaitForSingleObject (局_返回句柄, timing))
            赋值 (timing, 整除 (局_返回句柄, 15))
            赋值 (i, 0)
            .判断循环首 (并且 (等于 (ret, 258), 小于 (i, timing)))
                赋值 (i, 相加 (i, 1))
                _处理事件 ()
                赋值 (ret, WaitForSingleObject (局_返回句柄, 15))
            .判断循环尾 ()
        .判断结束
        
    .默认
        .如果真 (等于 (是否为空 (参数_等待返回超时值), 真))
            赋值 (参数_等待返回超时值, -1)
        .如果真结束
        赋值 (ret, WaitForSingleObject (局_返回句柄, 参数_等待返回超时值))
    .判断结束
     ' ret:
     ' 0=正常结束
     ' 1=正在执行
     ' 258=超时
     ' -1=句柄无效
    .如果真 (等于 (ret, 0))
        .如果真 (等于 (是否为空 (返回_等待返回数据), 假))
            GetExitCodeThread (局_返回句柄, 局_返回值)
            赋值 (返回_等待返回数据, 局_返回值)
        .如果真结束
        CloseHandle (局_返回句柄)
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (真)
    .如果真结束
    .如果真 (等于 (ret, -1)) ' 句柄无效,可能中途被其他线程关闭
        .如果真 (等于 (是否为空 (返回_线程句柄), 假))
            赋值 (返回_线程句柄, 0)
        .如果真结束
        返回 (假)
    .如果真结束
    
.如果真结束
.如果真 (等于 (是否为空 (返回_线程句柄), 假))
    赋值 (返回_线程句柄, 局_返回句柄)
.如果真结束
返回 (或者 (等于 (ret, 0), 等于 (ret, 258)))

.子程序 等待, 逻辑型, , 等待线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 超时时间, 整数型, 可空, 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。

.局部变量 ret, 整数型, , , 
.局部变量 hand, 整数型, , , 

赋值 (hand, InterlockedCompareExchange (Handle, 0, 0))
.如果真 (等于 (hand, 0))
    返回 (真)
.如果真结束
赋值 (ret, WaitForSingleObject (hand, 选择 (等于 (是否为空 (超时时间), 真), -1, 超时时间)))
.判断开始 (等于 (ret, 258))
    返回 (假)
.判断 (等于 (ret, 0))
    返回 (真)
.判断 (等于 (ret, -1))
    InterlockedExchange (Handle, 0)
    赋值 (Tid, 0)
    返回 (真)
.默认
    返回 (假)
.判断结束


.子程序 等待2, 逻辑型, , （不影响消息循环/不假死UI） 等待线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 超时时间, 整数型, 可空, 指定以ms(毫秒)为单位的超时时间。0为立即返回，-1为无限等待。

.局部变量 hand, 整数型, , , 
.局部变量 匿名局部变量_6672, 空白型, , , 
.局部变量 timing, 整数型, , , 
.局部变量 ret, 整数型, , , 
.局部变量 i, 整数型, , , 


赋值 (hand, InterlockedCompareExchange (Handle, 0, 0))
.如果真 (等于 (hand, 0))
    返回 (真)
.如果真结束

.判断开始 (或者 (等于 (是否为空 (超时时间), 真), 等于 (超时时间, -1)))
    赋值 (ret, WaitForSingleObject (hand, 15))
    .判断循环首 (等于 (ret, 258))
        _处理事件 ()
        赋值 (ret, WaitForSingleObject (hand, 15))
    .判断循环尾 ()
    
.默认
    
    赋值 (timing, 求余数 (超时时间, 15))
    赋值 (ret, WaitForSingleObject (hand, timing))
    赋值 (timing, 整除 (超时时间, 15))
    赋值 (i, 0)
    .判断循环首 (并且 (等于 (ret, 258), 小于 (i, timing)))
        赋值 (i, 相加 (i, 1))
        _处理事件 ()
        赋值 (ret, WaitForSingleObject (hand, 15))
    .判断循环尾 ()
.判断结束

.判断开始 (等于 (ret, 258))
    返回 (假)
.判断 (等于 (ret, 0))
    返回 (真)
.判断 (等于 (ret, -1))
    InterlockedExchange (Handle, 0)
    赋值 (Tid, 0)
    返回 (真)
.默认
    返回 (假)
.判断结束


.子程序 等待_msg, 逻辑型, , MSG方式不假死。等待线程执行完毕。如果到达指定的时间内还未结束返回假。如果在等待时间内执行完毕返回真。
.参数 等待时间, 整数型, 可空, 单位为毫秒，默认为无限等待。

.局部变量 ret, 整数型, , , 
.局部变量 局部_等待时间, 整数型, , , 
.局部变量 hand, 整数型, , , 

赋值 (hand, InterlockedCompareExchange (Handle, 0, 0))
.如果真 (等于 (hand, 0))
    返回 (真)
.如果真结束

赋值 (局部_等待时间, 选择 (等于 (是否为空 (等待时间), 真), 4294967295, 等待时间))
赋值 (ret, MsgWaitForMultipleObjects (1, hand, 假, 局部_等待时间, 1215))
.判断循环首 (并且 (不等于 (ret, 0), 不等于 (ret, 258), 不等于 (ret, -1)))
    _处理事件 ()
    赋值 (ret, MsgWaitForMultipleObjects (1, hand, 假, 局部_等待时间, 1215))
.判断循环尾 ()
 ' 0=正常结束
 ' 1=正在执行
 ' 258=超时
 ' -1=句柄无效
.判断开始 (等于 (ret, 258))
    返回 (假)
.判断 (等于 (ret, 0))
    返回 (真)
.判断 (等于 (ret, -1))
    InterlockedExchange (Handle, 0)
    赋值 (Tid, 0)
    返回 (真)
.默认
    返回 (假)
.判断结束


.子程序 挂起, 逻辑型, , 挂起线程 暂停操作 可以用 “恢复” 来继续执行
.如果真 (等于 (_判断 (), 真))
    返回 (假)
.如果真结束
返回 (不等于 (SuspendThread (Handle), -1))

.子程序 恢复, 逻辑型, , 继续运行被挂起的线程
.如果真 (等于 (_判断 (), 真))
    返回 (假)
.如果真结束
返回 (不等于 (ResumeThread (Handle), -1))

.子程序 关闭句柄, 逻辑型, , 只是关闭/销毁线程对象句柄，如果线程正在运行中不会关闭线程。（等同于销毁类内部的Handle）
.局部变量 int, 整数型, , , 

赋值 (int, InterlockedExchange (Handle, 0))
.如果真 (等于 (int, 0))
    返回 (真)
.如果真结束
赋值 (Tid, 0)
返回 (CloseHandle (int))

.子程序 强制结束, 逻辑型, , 强制退结束线程。不靠谱的玩具。
.如果真 (等于 (_判断 (), 真))
    返回 (真)
.如果真结束
TerminateThread (Handle, 0)
返回 (_判断 ())

.子程序 取返回值, 整数型, , 使用前请保证线程已经运行完毕，如线程尚未中断将返回STILLACTIVE(值为259)。子程序返回值为其他数据类型将返回指针。
.局部变量 hand, 整数型, , , 
.局部变量 ret, 整数型, , , 

赋值 (hand, InterlockedCompareExchange (Handle, 0, 0))
.如果真 (等于 (hand, 0))
    返回 (0)
.如果真结束
GetExitCodeThread (hand, ret)
返回 (ret)

.子程序 取优先级, 整数型, , 取线程优先级
.如果真 (等于 (_判断 (), 真))
    返回 (0)
.如果真结束
返回 (GetThreadPriority (Handle))

.子程序 置优先级, 逻辑型, , 设置线程优先级
.参数 优先级, 整数型, 可空, 

.如果真 (等于 (_判断 (), 真))
    返回 (假)
.如果真结束
返回 (不等于 (SetThreadPriority (Handle, 优先级), 0))

.子程序 置CPU亲和性, 逻辑型, , 设置/绑定CPU执行。（某些情况下可以避免主线程卡死问题）
.参数 亲和性参数, 整数型, 可空, 

.如果真 (等于 (_判断 (), 真))
    返回 (假)
.如果真结束
返回 (不等于 (SetThreadAffinityMask (Handle, 亲和性参数), 0))

.子程序 取句柄, 整数型, , 取当前所在线程句柄。只要当前线程需要使用一个线程句柄，就可以使用这个伪句柄（但在其他任务线程中都无效）。该句柄可以复制，但不可继承。不必调用CloseHandle函数来关闭这个句柄
返回 (Handle)

.子程序 置句柄, 空白型, , 设置类内部句柄
.参数 句柄, 整数型, , 

关闭句柄 ()
赋值 (Handle, 句柄)

.子程序 取ID, 整数型, , 取线程ID
返回 (Tid)

.子程序 投递信息A, 逻辑型, , 将一个消息放入（寄送）到指定线程的消息队列里，不等待线程处理消息就返回。成功返回真，失败返回假。
.参数 消息类型, 整数型, , 指定将被寄送的消息的类型。
.参数 参数一, 整数型, , 指定附加的消息特定信息。
.参数 参数二, 整数型, , 指定附加的消息特定信息。

返回 (PostThreadMesssgeA (Tid, 消息类型, 参数一, 参数二))

.子程序 投递信息W, 逻辑型, , 将一个消息放入（寄送）到指定线程的消息队列里，不等待线程处理消息就返回。成功返回真，失败返回假。
.参数 消息类型, 整数型, , 指定将被寄送的消息的类型。
.参数 参数一, 整数型, , 指定附加的消息特定信息。
.参数 参数二, 整数型, , 指定附加的消息特定信息。

返回 (PostThreadMesssgeW (Tid, 消息类型, 参数一, 参数二))


.程序集 许可证, , , 临界资源(返回类型为整数指针)

.子程序 _创建进入许可证, 整数型, , 
.局部变量 许可证指针, 整数型, , , 

.如果真 (等于 (DefaultHeap, 0))
    赋值 (DefaultHeap, GetProcessHeap ())
.如果真结束
赋值 (许可证指针, HeapAlloc (DefaultHeap, 8, 24)) ' CriticalSection在初始化、进入、退出时使用的必须为同一个CRITICAL_SECTION结构（即地址必须相同）
InitializeCriticalSection_int (许可证指针)
返回 (许可证指针)

.子程序 _删除进入许可证, 空白型, , 
.参数 许可证指针, 整数型, , 

.如果真 (等于 (许可证指针, 0))
    返回 ()
.如果真结束
DeleteCriticalSection_int (许可证指针)
HeapFree (DefaultHeap, 0, 许可证指针)

.子程序 _进入许可区, 空白型, , 
.参数 许可证指针, 整数型, , 

.如果真 (等于 (许可证指针, 0))
    返回 ()
.如果真结束
EnterCriticalSection_int (许可证指针)

.子程序 _退出许可区, 空白型, , 
.参数 许可证指针, 整数型, , 

.如果真 (等于 (许可证指针, 0))
    返回 ()
.如果真结束
LeaveCriticalSection_int (许可证指针)

.子程序 _尝试进入许可区, 逻辑型, , 
.参数 许可证指针, 整数型, , 

.如果真 (等于 (许可证指针, 0))
    返回 (假)
.如果真结束
返回 (TryEnterCriticalSection_int (许可证指针))

.程序集 公开子程序, , , 

.子程序 __更新日志, 空白型, , ***
输出调试文本 (#更新日志)
信息框 (#更新日志, 相加 (65536, 64), “Bints”)

.子程序 _延迟, 空白型, , API方式 特点：不占用CPU和系统资源 比易自带的延迟更稳定！ 延迟一段时间，然后继续执行后面的程序代码。与易语言核心支持库中的“延时()”命令不同的是，本命令在等待期间允许用户进行其它操作(如点击按钮等)。
.参数 等待时间, 整数型, , 单位为毫秒。提示：1000毫秒等于1秒。

.局部变量 时间, 整数型, , , 取启动时间 () － 时间 ＜ 等待时间 放在循环判断首里也一样
.局部变量 len, 整数型, , , 
.局部变量 int, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

.如果真 (小于 (等待时间, 15))
    Sleep (等待时间)
    _处理事件 ()
    返回 ()
.如果真结束
赋值 (时间, GetTickCount ())
赋值 (len, 整除 (等待时间, 15))
赋值 (int, 求余数 (等待时间, 15))
.循环判断首 ()
    Sleep (15)
    _处理事件 ()
    赋值 (i, 相加 (i, 1))
    赋值 (bool, 小于 (相减 (GetTickCount (), 时间), 等待时间))
.循环判断尾 (并且 (小于 (i, len), 等于 (bool, 真)))
.如果真 (并且 (等于 (bool, 真), 大于 (int, 0)))
    Sleep (int)
    _处理事件 ()
.如果真结束
返回 ()

.子程序 _处理事件, 空白型, , 暂时转让控制权，以便让 Windows 操作系统有机会处理其它的如用户键盘或鼠标输入等事件。直到操作系统处理并发送完程序队列中的所有事件后，命令才会返回。本命令为中级命令。
处理事件 ()
 ' 下面的方法存在消息处理问题
 ' .如果真 (不等于 (GetInputState (), 0))
     ' 处理事件 ()
.如果真结束


.子程序 _整数到指针, 子程序指针, , 将整数型的指针地址转换到子程序指针方便使用。
.参数 整数型指针, 整数型, , 整数型子程序指针 例如：类回调生成的指针地址。

.局部变量 子程序指针, 子程序指针, , , 

置入代码 ({ 139, 69, 8, 137, 69, 252 })
 ' mov eax,[ebp+8]
 ' mov [ebp-4], eax
返回 (子程序指针)

.子程序 内存_整理, 逻辑型, , 整理进程内存，Empty.exe 的原型。
.参数 参数_进程ID, 整数型, 可空, 0或留空 清理本进程内存

.局部变量 Phnd, 整数型, , , 
.局部变量 int, 整数型, , , 

.如果真 (等于 (参数_进程ID, 0))
    赋值 (int, EmptyWorkingSet (-1))
    返回 (不等于 (int, 0))
.如果真结束
赋值 (Phnd, OpenProcess (位或 (256, 1024), 0, 参数_进程ID))
.如果真 (等于 (Phnd, 0))
    返回 (假)
.如果真结束
赋值 (int, EmptyWorkingSet (Phnd))
CloseHandle (Phnd)
返回 (不等于 (int, 0))

.类模块 鱼刺类_线程池Ex, , , 鱼刺线程池Ex(面向对象)。带动态线程，效率和功能同在。

.程序集变量 回调地址_任务函数, 整数型, , , 
.程序集变量 回调地址_扩展函数, 整数型, , , 
.程序集变量 匿名程序集变量_5379, 空白型, , , 
.程序集变量 工作状态, 整数型, , , 0未启动 1运行中 2正在创建 3正在销毁
.程序集变量 IOCP任务站, 整数型, , , 
.程序集变量 循环条件, 逻辑型, , , 这个变量来控制线程池结束状态
.程序集变量 Event扩展, 整数型, , , 触发扩展线程
.程序集变量 Event等待线程创建, 整数型, , , 等待新线程回应
.程序集变量 Event等待任务动态, 整数型, , , 等待任务动态
.程序集变量 Event开关, 整数型, , , 暂停继续
.程序集变量 任务站数量, 整数型, , , 任务线程数会根据 动态线程控制函数增加
.程序集变量 执行任务数量, 整数型, , , 
.程序集变量 队列任务数量, 整数型, , , 
.程序集变量 扩展线程句柄, 整数型, , , 
.程序集变量 参_扩展线程容量, 整数型, , , 最大线程数量
.程序集变量 参_扩展线程空闲收回时间, 整数型, , , IOCP等待超时
.程序集变量 参_初始栈大小, 整数型, , , 创建的线程初始堆栈大小
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
赋值 (回调地址_任务函数, 类回调_生成类函数地址 (1))
赋值 (回调地址_扩展函数, 类回调_生成类函数地址 (2))

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 (2)
类回调_释放类函数地址 (回调地址_任务函数)
类回调_释放类函数地址 (回调地址_扩展函数)

.子程序 任务函数, 空白型, , 
.参数 TimeBool, 逻辑型, , 

.局部变量 局部_参数一, 整数型, , , 
.局部变量 局部_参数二, 整数型, , , 
.局部变量 局部_函数地址, 整数型, , , 
.局部变量 局部_任务结果, 逻辑型, , , 

InterlockedIncrement (任务站数量) ' 递增
SetEvent (Event等待线程创建)
赋值 (局部_任务结果, GetQueuedCompletionStatus (IOCP任务站, 局部_参数一, 局部_参数二, 局部_函数地址, 选择 (等于 (TimeBool, 真), 参_扩展线程空闲收回时间, -1)))
WaitForSingleObject (Event开关, -1)
.判断循环首 (并且 (等于 (循环条件, 真), 等于 (局部_任务结果, 真), 不等于 (局部_函数地址, -2)))
     ' 先加执行后减队列是为了能精确判断 是否空闲()
    InterlockedIncrement (执行任务数量) ' 递增
    InterlockedDecrement (队列任务数量) ' 递减
    
     ' 执行任务楼
    调用子程序_asm (局部_函数地址, 局部_参数一, 局部_参数二)
    InterlockedDecrement (执行任务数量) ' 递减
    
     ' 通知等待任务动态放行一个
    SetEvent (Event等待任务动态)
    
    赋值 (局部_任务结果, GetQueuedCompletionStatus (IOCP任务站, 局部_参数一, 局部_参数二, 局部_函数地址, 选择 (等于 (TimeBool, 真), 参_扩展线程空闲收回时间, -1)))
    WaitForSingleObject (Event开关, -1)
.判断循环尾 ()
 ' API版的原子锁可得到递减后的结果 所以也可达到精确判断
赋值 (局部_函数地址, InterlockedDecrement (任务站数量)) ' 递减
.如果真 (等于 (局部_函数地址, 0))
     ' 全部销毁消息都接收到了 直接销毁IOCP
    赋值 (局部_函数地址, InterlockedExchange (IOCP任务站, 0)) ' 赋值
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, InterlockedExchange (Event等待任务动态, 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, InterlockedExchange (Event开关, 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    
    赋值 (局部_函数地址, InterlockedExchange (Event扩展, 0))
    .如果真 (不等于 (局部_函数地址, 0))
        SetEvent (局部_函数地址)
        CloseHandle (局部_函数地址)
    .如果真结束
    
    
     ' 还原初始化状态
    赋值 (循环条件, 假)
    
    赋值 (任务站数量, 0)
    赋值 (执行任务数量, 0)
    赋值 (队列任务数量, 0)
    
    
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    
.如果真结束
返回 ()

.子程序 扩展_控制函数, 空白型, , 
.局部变量 handle, 整数型, , , 
.局部变量 创建失败计次, 整数型, , , 

WaitForSingleObject (Event扩展, -1)
.判断循环首 (等于 (工作状态, #线程池_正在工作)) ' 一下是扩展控制线程
    .判断开始 (并且 (小于 (任务站数量, 参_扩展线程容量), 大于 (_加法 (执行任务数量, 队列任务数量), 任务站数量)))
        赋值 (handle, CreateThread_Int (0, 参_初始栈大小, 回调地址_任务函数, 1, 0, 0))
        .判断开始 (等于 (handle, 0))
            赋值 (创建失败计次, 相加 (创建失败计次, 1))
            .如果真 (大于或等于 (创建失败计次, 5))
                赋值 (参_扩展线程容量, 任务站数量)
                赋值 (创建失败计次, 0)
            .如果真结束
            
        .默认
            赋值 (创建失败计次, 0)
            CloseHandle (handle)
            赋值 (handle, 相加 (相乘 (任务站数量, 10), 1000))
            WaitForSingleObject (Event等待线程创建, handle)
        .判断结束
        
    .默认
        WaitForSingleObject (Event扩展, -1)
    .判断结束
    WaitForSingleObject (Event开关, -1)
.判断循环尾 ()
返回 ()

.子程序 创建, 逻辑型, , 创建并启动线程池，并开始等待任务投递。成功返回真，失败返回假。
.参数 参数_最小线程数, 整数型, 可空, 同时工作的最小线程数。留空为 5
.参数 参数_最大线程数, 整数型, 可空, 任务过多时自动扩展到的最大线程数。留空为 20
.参数 参数_动态线程空闲收回时间, 整数型, 可空, 如果任务过少持续一定时间后动态线程会被自动收回。单位：毫秒。 留空为 10000ms (10秒).。 （注意：空闲收回超时最低100ms 毫秒）
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止创建时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_线程池容量, 整数型, , , 
.局部变量 局_time, 整数型, , , 
.局部变量 局_int, 整数型, , , 
.局部变量 局_int2, 整数型, , , 


赋值 (局_int, InterlockedCompareExchange (工作状态, #线程池_正在创建, #线程池_未启动)) ' 三目运算
.如果真 (不等于 (局_int, #线程池_未启动))
    返回 (假)
.如果真结束

.判断开始 (等于 (是否为空 (参数_最小线程数), 真))
    赋值 (局_线程池容量, 5)
.判断 (小于 (参数_最小线程数, 1))
    赋值 (局_线程池容量, 1)
.默认
    赋值 (局_线程池容量, 参数_最小线程数)
.判断结束


.如果真 (等于 (是否为空 (参数_最大线程数), 真))
    赋值 (参_扩展线程容量, 20)
.如果真结束
.判断开始 (小于 (参数_最大线程数, 局_线程池容量))
    赋值 (参_扩展线程容量, 局_线程池容量)
.默认
    赋值 (参_扩展线程容量, 参数_最大线程数)
.判断结束

.判断开始 (等于 (是否为空 (参数_动态线程空闲收回时间), 真))
    赋值 (参_扩展线程空闲收回时间, 10000)
.判断 (小于 (参数_动态线程空闲收回时间, 100))
    赋值 (参_扩展线程空闲收回时间, 100)
.默认
    赋值 (参_扩展线程空闲收回时间, 参数_动态线程空闲收回时间)
.判断结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (参_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (参_初始栈大小, 8192)
.默认
    赋值 (参_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束


赋值 (IOCP任务站, CreateIoCompletionPort (-1, 0, 0, 0))
.如果真 (等于 (IOCP任务站, 0))
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (Event扩展, CreateEvent_int (0, 假, 假, 0))
.如果真 (等于 (Event扩展, 0))
    CloseHandle (IOCP任务站)
    赋值 (IOCP任务站, 0)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (Event等待线程创建, CreateEvent_int (0, 假, 假, 0))
.如果真 (等于 (Event等待线程创建, 0))
    CloseHandle (IOCP任务站)
    CloseHandle (Event扩展)
    连续赋值 (0, IOCP任务站, Event扩展)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (Event等待任务动态, CreateEvent_int (0, 假, 假, 0))
.如果真 (等于 (Event等待任务动态, 0))
    CloseHandle (IOCP任务站)
    CloseHandle (Event扩展)
    CloseHandle (Event等待线程创建)
    连续赋值 (0, IOCP任务站, Event扩展, Event等待线程创建)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (Event开关, CreateEvent_int (0, 真, 真, 0))
.如果真 (等于 (Event开关, 0))
    CloseHandle (IOCP任务站)
    CloseHandle (Event扩展)
    CloseHandle (Event等待线程创建)
    CloseHandle (Event等待任务动态)
    连续赋值 (0, IOCP任务站, Event扩展, Event等待线程创建, Event等待任务动态)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (局_int, CreateThread_Int (0, 8192, 回调地址_扩展函数, 0, 0, 0))
.判断开始 (等于 (局_int, 0))
    CloseHandle (IOCP任务站)
    CloseHandle (Event扩展)
    CloseHandle (Event等待线程创建)
    CloseHandle (Event等待任务动态)
    CloseHandle (Event开关)
    连续赋值 (0, IOCP任务站, Event扩展, Event等待线程创建, Event等待任务动态, Event开关)
    
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.默认
    赋值 (扩展线程句柄, 局_int)
.判断结束

赋值 (循环条件, 真)
连续赋值 (0, 任务站数量, 执行任务数量, 队列任务数量, 局_int, 局_int2)

.计次循环首 (局_线程池容量, ) ' 创建线程。
    赋值 (局_time, CreateThread_Int (0, 参_初始栈大小, 回调地址_任务函数, 0, 0, 0))
    .判断开始 (不等于 (局_time, 0))
        CloseHandle (局_time)
        赋值 (局_int, 相加 (局_int, 1)) ' 为了防止创建线超出系统程极限而导致时间等待过长。
        赋值 (局_int2, 0)
    .默认
        赋值 (局_int2, 相加 (局_int2, 1))
        .如果真 (大于或等于 (局_int2, 5)) ' 连续5次创建线程失败跳出。
            跳出循环 ()
        .如果真结束
        
    .判断结束
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()
.如果真 (大于 (局_int, 0))
     ' 下面是防止立即销毁时线程还没得到IOCP导致有部分线程未能被销毁。
    赋值 (局_time, GetTickCount ())
    赋值 (局_int2, 相加 (相乘 (局_int, 10), 1000))
    .判断循环首 (或者 (等于 (WaitForSingleObject (Event等待线程创建, 20), 258), 并且 (小于 (任务站数量, 局_int), 小于 (相减 (GetTickCount (), 局_time), 局_int2))))
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
.如果真 (等于 (任务站数量, 0))
    SetEvent (Event扩展)
    .循环判断首 ()
        赋值 (局_time, 相加 (局_time, 1))
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .循环判断尾 (并且 (等于 (WaitForSingleObject (Event扩展, 20), 258), 小于或等于 (局_time, 10)))
    赋值 (局_int, InterlockedExchange (Event扩展, 0))
    CloseHandle (局_int)
    CloseHandle (IOCP任务站)
    CloseHandle (Event等待线程创建)
    CloseHandle (Event等待任务动态)
    CloseHandle (Event开关)
    赋值 (循环条件, 假)
    连续赋值 (0, IOCP任务站, Event等待线程创建, Event等待任务动态, Event开关)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束


InterlockedExchange (工作状态, #线程池_正在工作) ' 赋值

返回 (真)

.子程序 销毁, 逻辑型, , 销毁线程池。成功或已经销毁返回真，失败返回假。（失败原因包括：线程池正在销毁、线程池正在创建、到了超时时间）
.参数 参数_销毁方式, 整数型, 可空, 0=正常销毁（等待当前任务执行后返回 真 ），1=温柔销毁（等待投递进去的任务全部执行完毕后返回 真 ），2=强制销毁（丢出销毁命令后立即返回 真  注意：此方式执行成功后不代表线程池已经销毁！依然是按照正常销毁那样 当前任务执行完毕后线程池才算真正销毁。），3=强制温柔销毁(丢出温柔销毁命令后立即返回 真 。注意：此方式执行成功后不代表线程池已经销毁！依然是按照温柔销毁那样 投递进去的任务全部执行完毕后线程池才算真正销毁。)。提示：执行强制销毁后可通过 取_状态() 方法来继续探测线程池当前的状态。
.参数 参数_最长等待时间, 整数型, 可空, 注意：此参数只对非强制销毁有效。单位：毫秒，留空或 0 一直等待。 否则到了超时时间会立即返回 假 。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止销毁时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 局部_销毁方式, 整数型, , , 
.局部变量 局部_T, 整数型, , , 

赋值 (局部_T, InterlockedCompareExchange (工作状态, #线程池_正在销毁, #线程池_正在工作)) ' 三目运算 设置正在销毁状态
.如果真 (等于 (局部_T, #线程池_未启动)) ' 0 = 已经结束
    返回 (真)
.如果真结束
.如果真 (或者 (等于 (局部_T, #线程池_正在创建), 等于 (局部_T, #线程池_正在销毁))) ' 2 = 正在创建  ' 3 = 正在销毁
    返回 (假)
.如果真结束

赋值 (局部_销毁方式, 参数_销毁方式)
.如果真 (或者 (大于 (局部_销毁方式, 3), 小于 (局部_销毁方式, 0)))
    赋值 (局部_销毁方式, 0)
.如果真结束

 ' 通知任务站立即罢工
.如果真 (或者 (等于 (局部_销毁方式, 0), 等于 (局部_销毁方式, 2)))
    赋值 (循环条件, 假)
.如果真结束

 ' 通知等待任务动态结束
SetEvent (Event等待任务动态)

 ' 通知扩展线程结束
SetEvent (Event等待线程创建)
SetEvent (Event扩展)

 ' 通知暂停的线程恢复
SetEvent (Event开关)

 ' 等待扩展控制线程结束
赋值 (局部_T, 1)
.判断循环首 (并且 (等于 (WaitForSingleObject (扩展线程句柄, 20), 258), 小于或等于 (局部_T, 20)))
    赋值 (局部_T, 相加 (局部_T, 1))
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.判断循环尾 ()
CloseHandle (扩展线程句柄) ' '销毁扩展控制线程句柄
赋值 (扩展线程句柄, 0)


 ' 通知任务站不要堵塞了
.如果真 (等于 (参数_是否在UI线程, 真))
    _处理事件 ()
.如果真结束
PostQueuedCompletionStatus (IOCP任务站, -1, -1, -2) ' 多丢一个
.计次循环首 (任务站数量, 局部_T)
    PostQueuedCompletionStatus (IOCP任务站, -1, -1, -2)
    .如果真 (并且 (等于 (参数_是否在UI线程, 真), 等于 (求余数 (局部_T, 100), 0))) ' 求余数100
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()

 ' 等待销毁
.如果真 (小于 (局部_销毁方式, 2))
    .如果真 (大于 (参数_最长等待时间, 0))
        赋值 (局部_T, GetTickCount ())
    .如果真结束
    .判断循环首 (等于 (工作状态, #线程池_正在销毁))
        .如果真 (大于 (参数_最长等待时间, 0))
            .如果真 (大于 (相减 (GetTickCount (), 局部_T), 参数_最长等待时间))
                返回 (假)
            .如果真结束
            
        .如果真结束
        WaitForSingleObject (Event扩展, 20)
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
返回 (真)

.子程序 暂停, 逻辑型, , 暂停线程池 （使用的是Event事件拦截。如果想立即暂停 可通过在'&线程子程序'里部署方法'事件_暂停()'拦截Event事件来达到立即暂停的目的）
.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 (假)
.如果真结束
返回 (ResetEvent (Event开关))

.子程序 继续, 逻辑型, , 恢复暂停中的线程池 
.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 (假)
.如果真结束
返回 (SetEvent (Event开关))

.子程序 事件_暂停, 逻辑型, , 此方法会等待进入暂停开关事件。如果是未暂停状态可立即进入并返回真。如果是暂停状态则会堵塞等待到事件被触发，然后返回真。超时或线程池非正在工作状态(线程池已销毁)返回假。（放在线程子程序里可以快速控制暂停）
.参数 参数_超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 (假)
.如果真结束
.如果真 (等于 (是否为空 (参数_超时值), 真))
    赋值 (参数_超时值, -1)
.如果真结束
返回 (等于 (WaitForSingleObject (Event开关, 参数_超时值), 0))

.子程序 投递任务, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_执行函数, 子程序指针, , &子程序指针
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 局部_执行函数, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

赋值 (局部_执行函数, 到整数 (参数_执行函数))
.如果真 (或者 (不等于 (工作状态, #线程池_正在工作), 等于 (局部_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement (队列任务数量) ' 递增
赋值 (bool, PostQueuedCompletionStatus (IOCP任务站, 参数_参数一, 参数_参数二, 局部_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement (队列任务数量) ' 递减
.如果真结束
.如果真 (并且 (小于 (任务站数量, 参_扩展线程容量), 大于 (_加法 (执行任务数量, 队列任务数量), 任务站数量)))
    SetEvent (Event扩展)
.如果真结束
返回 (bool)

.子程序 投递任务_int, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_执行函数, 整数型, , 整数型指针 或 到整数(&子程序指针)
.参数 参数_参数一, 整数型, 可空, 附加的参数1 
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 bool, 逻辑型, , , 

.如果真 (或者 (不等于 (工作状态, #线程池_正在工作), 等于 (参数_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement (队列任务数量) ' 递增
赋值 (bool, PostQueuedCompletionStatus (IOCP任务站, 参数_参数一, 参数_参数二, 参数_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement (队列任务数量) ' 递减
.如果真结束
.如果真 (并且 (小于 (任务站数量, 参_扩展线程容量), 大于 (_加法 (执行任务数量, 队列任务数量), 任务站数量)))
    SetEvent (Event扩展)
.如果真结束
返回 (bool)

.子程序 等待任务动态, 逻辑型, , 等待有线程任务执行完毕，返回真。超时或线程池被销毁返回假。（注意：因Event特性不支持多处一起等待！若多处等待请设置下超时值，否则会有一些线程无限堵塞。）
.参数 参数_等待超时, 整数型, 可空, 超时值。单位：毫秒。 留空或-1为无限等待。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止等待时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 ret, 整数型, , , 
.局部变量 t, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 (假)
.如果真结束
.判断开始 (等于 (参数_是否在UI线程, 真))
    .如果真 (并且 (等于 (是否为空 (参数_等待超时), 假), 不等于 (参数_等待超时, -1)))
        赋值 (t, GetTickCount ())
        赋值 (bool, 真)
    .如果真结束
    .循环判断首 ()
        _处理事件 ()
        赋值 (ret, WaitForSingleObject (Event等待任务动态, 20))
        .如果真 (等于 (bool, 真))
            .如果真 (大于 (相减 (GetTickCount (), t), 参数_等待超时))
                赋值 (ret, -1) ' 跳出循环吧 超时了
            .如果真结束
            
        .如果真结束
        
    .循环判断尾 (并且 (不等于 (ret, 0), 不等于 (ret, -1)))
.默认
    赋值 (ret, WaitForSingleObject (Event等待任务动态, 选择 (等于 (是否为空 (参数_等待超时), 真), -1, 参数_等待超时)))
.判断结束
返回 (等于 (ret, 0))

.子程序 取_空闲线程数, 整数型, , 空闲的线程数量。
返回 (_减法 (任务站数量, 执行任务数量))
 ' 返回 (任务站数量 － 执行任务数量)

.子程序 取_执行线程数, 整数型, , 正在执行的任务数量。
返回 (执行任务数量)

.子程序 取_队列任务数, 整数型, , 等待处理的任务数量。
返回 (队列任务数量)

.子程序 取_线程池容量, 整数型, , 创建时候的容量（最小线程数）。
返回 (任务站数量)

.子程序 取_最大线程容量, 整数型, , 可动态扩展的容量（最大线程数）。
返回 (参_扩展线程容量)

.子程序 取_是否空闲, 逻辑型, , 线程池处于彻底空闲状态，没有任何任务在执行。
返回 (并且 (等于 (队列任务数量, 0), 等于 (执行任务数量, 0)))

.子程序 取_状态, 整数型, , 0=未启动，1=正在工作，2=正在创建，3=正在销毁。
返回 (工作状态)

.子程序 置_最大线程数, 空白型, , （此命令适用于线程池已经创建的状态下） 设置最大/扩展/动态线程数量。（注意：数值低于最小线程数会被自动调整。）
.参数 参数_新的最扩展线程数量, 整数型, , 不会低于 最小线程数 不会大于系统峰值

.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 ()
.如果真结束
.判断开始 (小于 (参数_新的最扩展线程数量, 1))
    赋值 (参_扩展线程容量, 1)
.默认
    赋值 (参_扩展线程容量, 参数_新的最扩展线程数量)
.判断结束
.如果真 (并且 (小于 (任务站数量, 参_扩展线程容量), 大于 (_加法 (执行任务数量, 队列任务数量), 任务站数量)))
    SetEvent (Event扩展)
.如果真结束


.子程序 置_空闲回收时间, 空白型, , （此命令适用于线程池已经创建的状态下）设置最大/扩展/动态空闲收回时间。 （注意：低于100ms会被自动调整） 
.参数 参数_新的超时收回时间, 整数型, , 单位：毫秒 不能低于100ms

.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 ()
.如果真结束
.判断开始 (小于 (参数_新的超时收回时间, 100))
    赋值 (参_扩展线程空闲收回时间, 100)
.默认
    赋值 (参_扩展线程空闲收回时间, 参数_新的超时收回时间)
.判断结束


.子程序 置_初始栈大小, 空白型, , （此命令适用于线程池已经创建的状态下）设置初始栈大小。
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.如果真 (不等于 (工作状态, #线程池_正在工作))
    返回 ()
.如果真结束
.判断开始 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (参_初始栈大小, 8192)
.默认
    赋值 (参_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 8192)))
.判断结束


.程序集 线程池Ex, , , 鱼刺类_线程池Ex。(面向过程)

.子程序 线程池Ex_任务函数, 空白型, , 
.参数 ptr, 整数型, , 

.局部变量 局部_参数一, 整数型, , , 
.局部变量 局部_参数二, 整数型, , , 
.局部变量 局部_函数地址, 整数型, , , 
.局部变量 局部_任务结果, 逻辑型, , , 

InterlockedIncrement_ptr (_加法 (ptr, 28)) ' 任务站数量递增
SetEvent (_读整数Ex (ptr, 16))
赋值 (局部_任务结果, GetQueuedCompletionStatus (_读整数Ex (ptr, 4), 局部_参数一, 局部_参数二, 局部_函数地址, -1))
WaitForSingleObject (_读整数Ex (ptr, 24), -1)
.判断循环首 (并且 (等于 (_读整数Ex (ptr, 8), 1), 等于 (局部_任务结果, 真), 不等于 (局部_函数地址, -2)))
     ' 先加执行后减队列是为了能精确判断 是否空闲()
    InterlockedIncrement_ptr (_加法 (ptr, 32)) ' 执行任务数量递增
    InterlockedDecrement_ptr (_加法 (ptr, 36)) ' 队列任务数量递减
    
     ' 执行任务楼
    调用子程序_asm (局部_函数地址, 局部_参数一, 局部_参数二)
    InterlockedDecrement_ptr (_加法 (ptr, 32)) ' 执行任务数量递减
    
     ' 通知等待任务动态放行一个
    SetEvent (_读整数Ex (ptr, 20))
    
    赋值 (局部_任务结果, GetQueuedCompletionStatus (_读整数Ex (ptr, 4), 局部_参数一, 局部_参数二, 局部_函数地址, -1))
    WaitForSingleObject (_读整数Ex (ptr, 24), -1)
.判断循环尾 ()
 ' API版的原子锁可得到递减后的结果 所以也可达到精确判断
赋值 (局部_函数地址, InterlockedDecrement_ptr (_加法 (ptr, 28))) ' 任务站数量递减
.如果真 (等于 (局部_函数地址, 0))
     ' 全部销毁消息都接收到了 直接销毁IOCP
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 4), 0)) ' 赋值
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 16), 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 24), 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    SetEvent (_读整数Ex (ptr, 12))
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 12), 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    
     ' 还原初始化状态
    _写整数Ex (ptr, 8, 0)
    _写整数Ex (ptr, 28, 0)
    _写整数Ex (ptr, 32, 0)
    _写整数Ex (ptr, 36, 0)
    
    _写整数 (ptr, #线程池_未启动)
    Sleep (10)
    HeapFree (DefaultHeap, 0, ptr)
.如果真结束
返回 ()

.子程序 线程池Ex_扩展_任务函数, 空白型, , 
.参数 ptr, 整数型, , 

.局部变量 局部_参数一, 整数型, , , 
.局部变量 局部_参数二, 整数型, , , 
.局部变量 局部_函数地址, 整数型, , , 
.局部变量 局部_任务结果, 逻辑型, , , 

InterlockedIncrement_ptr (_加法 (ptr, 28)) ' 任务站数量递增
SetEvent (_读整数Ex (ptr, 16))
赋值 (局部_任务结果, GetQueuedCompletionStatus (_读整数Ex (ptr, 4), 局部_参数一, 局部_参数二, 局部_函数地址, _读整数Ex (ptr, 48)))
WaitForSingleObject (_读整数Ex (ptr, 24), -1)
.判断循环首 (并且 (等于 (_读整数Ex (ptr, 8), 1), 等于 (局部_任务结果, 真), 不等于 (局部_函数地址, -2)))
     ' 先加执行后减队列是为了能精确判断 是否空闲()
    InterlockedIncrement_ptr (_加法 (ptr, 32)) ' 执行任务数量递增
    InterlockedDecrement_ptr (_加法 (ptr, 36)) ' 队列任务数量递减
    
     ' 执行任务楼
    调用子程序_asm (局部_函数地址, 局部_参数一, 局部_参数二)
    InterlockedDecrement_ptr (_加法 (ptr, 32)) ' 执行任务数量递减
    
     ' 通知等待任务动态放行一个
    SetEvent (_读整数Ex (ptr, 20))
    
    赋值 (局部_任务结果, GetQueuedCompletionStatus (_读整数Ex (ptr, 4), 局部_参数一, 局部_参数二, 局部_函数地址, _读整数Ex (ptr, 48)))
    WaitForSingleObject (_读整数Ex (ptr, 24), -1)
.判断循环尾 ()
 ' API版的原子锁可得到递减后的结果 所以也可达到精确判断
赋值 (局部_函数地址, InterlockedDecrement_ptr (_加法 (ptr, 28))) ' 任务站数量递减
.如果真 (等于 (局部_函数地址, 0))
     ' 全部销毁消息都接收到了 直接销毁IOCP
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 4), 0)) ' 赋值
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 16), 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 24), 0))
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    
    赋值 (局部_函数地址, InterlockedExchange_ptr (_加法 (ptr, 12), 0))
    .如果真 (不等于 (局部_函数地址, 0))
        SetEvent (局部_函数地址)
        CloseHandle (局部_函数地址)
    .如果真结束
    
    
     ' 还原初始化状态
    _写整数Ex (ptr, 8, 0)
    _写整数Ex (ptr, 28, 0)
    _写整数Ex (ptr, 32, 0)
    _写整数Ex (ptr, 36, 0)
    
    _写整数 (ptr, #线程池_未启动)
    Sleep (10)
    HeapFree (DefaultHeap, 0, ptr)
.如果真结束
返回 ()

.子程序 线程池Ex_扩展_控制函数, 空白型, , 
.参数 ptr, 整数型, , 

.局部变量 handle, 整数型, , , 
.局部变量 当前任务站数量, 整数型, , , 
.局部变量 创建失败计次, 整数型, , , 

WaitForSingleObject (_读整数Ex (ptr, 12), -1)
.判断循环首 (等于 (_读整数 (ptr), #线程池_正在工作)) ' 一下是扩展控制线程
    赋值 (当前任务站数量, _读整数Ex (ptr, 28))
    .判断开始 (并且 (小于 (当前任务站数量, _读整数Ex (ptr, 44)), 大于 (_加法 (_读整数Ex (ptr, 32), _读整数Ex (ptr, 36)), 当前任务站数量)))
        赋值 (handle, CreateThread (0, _读整数Ex (ptr, 52), &线程池Ex_扩展_任务函数, ptr, 0, 0))
        .判断开始 (等于 (handle, 0))
            赋值 (创建失败计次, 相加 (创建失败计次, 1))
            .如果真 (大于或等于 (创建失败计次, 5))
                 ' 扩展线程容量44 ＝ 当前任务站数量
                _写整数Ex (ptr, 44, 当前任务站数量)
                赋值 (创建失败计次, 0)
            .如果真结束
            
        .默认
            赋值 (创建失败计次, 0)
            CloseHandle (handle)
            赋值 (handle, 相加 (相乘 (当前任务站数量, 10), 500))
            WaitForSingleObject (_读整数Ex (ptr, 16), handle)
        .判断结束
        
    .默认
        WaitForSingleObject (_读整数Ex (ptr, 12), -1)
    .判断结束
    WaitForSingleObject (_读整数Ex (ptr, 24), -1)
.判断循环尾 ()
返回 ()

.子程序 线程池Ex_创建, 整数型, , 创建并启动线程池，并开始等待任务投递。成功返回真，失败返回假。
.参数 参数_最小线程数, 整数型, 可空, 同时工作的最小线程数。留空为 5
.参数 参数_最大线程数, 整数型, 可空, 任务过多时自动扩展到的最大线程数。留空为 20
.参数 参数_动态线程空闲收回时间, 整数型, 可空, 如果任务过少持续一定时间后动态线程会被自动收回。单位：毫秒。 留空为 10000ms (10秒).。 （注意：空闲收回超时最低100ms 毫秒）
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止创建时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_线程池容量, 整数型, , , 
.局部变量 局_time, 整数型, , , 
.局部变量 局_int, 整数型, , , 
.局部变量 局_int2, 整数型, , , 
.局部变量 匿名局部变量_9265, 空白型, , , 
.局部变量 ptr, 整数型, , , 
.局部变量 int, 整数型, , , 

 ' 工作状态 IOCP任务站4 循环条件8 Event扩展12 Event等待线程创建16 Event等待任务动态20 Event开关24 任务站数量28 执行任务数量32 队列任务数量36 扩展线程句柄40 扩展线程容量44 扩展线程空闲收回时间48 初始堆栈大小52
赋值 (ptr, HeapAlloc (DefaultHeap, 8, 56))
.如果真 (等于 (ptr, 0))
    返回 (0)
.如果真结束

.判断开始 (等于 (是否为空 (参数_最小线程数), 真))
    赋值 (局_线程池容量, 5)
.判断 (小于 (参数_最小线程数, 1))
    赋值 (局_线程池容量, 1)
.默认
    赋值 (局_线程池容量, 参数_最小线程数)
.判断结束

.如果真 (等于 (是否为空 (参数_最大线程数), 真))
    赋值 (参数_最大线程数, 20)
.如果真结束
.判断开始 (小于 (参数_最大线程数, 局_线程池容量))
    _写整数Ex (ptr, 44, 局_线程池容量)
.默认
    _写整数Ex (ptr, 44, 参数_最大线程数)
.判断结束

.判断开始 (等于 (是否为空 (参数_动态线程空闲收回时间), 真))
    _写整数Ex (ptr, 48, 10000)
.判断 (小于 (参数_动态线程空闲收回时间, 100))
    _写整数Ex (ptr, 48, 100)
.默认
    _写整数Ex (ptr, 48, 参数_动态线程空闲收回时间)
.判断结束

.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    _写整数Ex (ptr, 52, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    _写整数Ex (ptr, 52, 8192)
.默认
    _写整数Ex (ptr, 52, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (int, CreateIoCompletionPort (-1, 0, 0, 0))
.如果真 (等于 (int, 0))
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
_写整数Ex (ptr, 4, int) ' IOCP

赋值 (int, CreateEvent_int (0, 假, 假, 0))
.如果真 (等于 (int, 0))
    CloseHandle (_读整数Ex (ptr, 4)) ' 销毁IOCP
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
_写整数Ex (ptr, 12, int) ' event扩展

赋值 (int, CreateEvent_int (0, 假, 假, 0))
.如果真 (等于 (int, 0))
    CloseHandle (_读整数Ex (ptr, 4)) ' 销毁IOCP
    CloseHandle (_读整数Ex (ptr, 12)) ' 销毁event扩展
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
_写整数Ex (ptr, 16, int) ' event创建线程等待

赋值 (int, CreateEvent_int (0, 假, 假, 0))
.如果真 (等于 (int, 0))
    CloseHandle (_读整数Ex (ptr, 4)) ' 销毁IOCP
    CloseHandle (_读整数Ex (ptr, 12)) ' 销毁event扩展
    CloseHandle (_读整数Ex (ptr, 16)) ' 销毁event等待线程创建
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
_写整数Ex (ptr, 20, int) ' event等待任务动态

赋值 (int, CreateEvent_int (0, 真, 真, 0))
.如果真 (等于 (int, 0))
    CloseHandle (_读整数Ex (ptr, 4)) ' 销毁IOCP
    CloseHandle (_读整数Ex (ptr, 12)) ' 销毁event扩展
    CloseHandle (_读整数Ex (ptr, 16)) ' 销毁event等待线程创建
    CloseHandle (_读整数Ex (ptr, 20)) ' 销毁event等待任务动态
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
_写整数Ex (ptr, 24, int) ' event开关

赋值 (局_int, CreateThread (0, 8192, &线程池Ex_扩展_控制函数, ptr, 0, 0))
.判断开始 (等于 (局_int, 0))
    CloseHandle (_读整数Ex (ptr, 4)) ' 销毁IOCP
    CloseHandle (_读整数Ex (ptr, 12)) ' 销毁event扩展
    CloseHandle (_读整数Ex (ptr, 16)) ' 销毁event等待线程创建
    CloseHandle (_读整数Ex (ptr, 20)) ' 销毁event等待任务动态
    CloseHandle (_读整数Ex (ptr, 24)) ' 销毁event开关
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.默认
    _写整数Ex (ptr, 40, 局_int) ' 扩展线程句柄
.判断结束


_写整数Ex (ptr, 8, 1) ' 触发循环

连续赋值 (0, 局_int, 局_int2)
赋值 (int, _读整数Ex (ptr, 52))
.计次循环首 (局_线程池容量, ) ' 一个个地创建线程。
    赋值 (局_time, CreateThread (0, int, &线程池Ex_任务函数, ptr, 0, 0))
    .判断开始 (不等于 (局_time, 0))
        CloseHandle (局_time)
        赋值 (局_int, 相加 (局_int, 1)) ' 为了防止创建线超出系统程极限而导致时间等待过长。
        赋值 (局_int2, 0)
    .默认
        赋值 (局_int2, 相加 (局_int2, 1))
        .如果真 (大于或等于 (局_int2, 5)) ' 连续5次创建线程失败跳出。
            跳出循环 ()
        .如果真结束
        
    .判断结束
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()
.如果真 (大于 (局_int, 0))
     ' 下面是防止立即销毁时线程还没得到IOCP导致有部分线程未能被销毁。
    赋值 (int, _读整数Ex (ptr, 16)) ' event等待线程创建
    赋值 (局_time, GetTickCount ())
    赋值 (局_int2, 相加 (相乘 (局_int, 10), 1000))
    .判断循环首 (或者 (等于 (WaitForSingleObject (int, 20), 258), 并且 (小于 (_读整数Ex (ptr, 28), 局_int), 小于 (相减 (GetTickCount (), 局_time), 局_int2)))) ' 任务站数量
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
.如果真 (等于 (_读整数Ex (ptr, 28), 0)) ' 任务站数量
    赋值 (int, _读整数Ex (ptr, 12)) ' event扩展
    SetEvent (int)
    .循环判断首 ()
        赋值 (局_time, 相加 (局_time, 1))
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .循环判断尾 (并且 (等于 (WaitForSingleObject (int, 20), 258), 小于或等于 (局_time, 10)))
    赋值 (局_int, InterlockedExchange_ptr (_加法 (ptr, 12), 0)) ' event扩展
    CloseHandle (局_int) ' 销毁event扩展
    CloseHandle (_读整数Ex (ptr, 4)) ' 销毁IOCP
    CloseHandle (_读整数Ex (ptr, 16)) ' 销毁event等待线程创建
    CloseHandle (_读整数Ex (ptr, 20)) ' 销毁event等待任务动态
    CloseHandle (_读整数Ex (ptr, 24)) ' 销毁event开关
    _写整数Ex (ptr, 8, 0)
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束

_写整数 (ptr, #线程池_正在工作)
返回 (ptr)

.子程序 线程池Ex_销毁, 逻辑型, , 销毁线程池。成功或已经销毁返回真，失败返回假。（失败原因包括：线程池正在销毁、线程池正在创建、到了超时时间）
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_销毁方式, 整数型, 可空, 0=正常销毁（等待当前任务执行后返回 真 ），1=温柔销毁（等待投递进去的任务全部执行完毕后返回 真 ），2=强制销毁（丢出销毁命令后立即返回 真  注意：此方式执行成功后不代表线程池已经销毁！依然是按照正常销毁那样 当前任务执行完毕后线程池才算真正销毁。），3=强制温柔销毁(丢出温柔销毁命令后立即返回 真 。注意：此方式执行成功后不代表线程池已经销毁！依然是按照温柔销毁那样 投递进去的任务全部执行完毕后线程池才算真正销毁。)。提示：执行强制销毁后可通过 取_状态() 方法来继续探测线程池当前的状态。
.参数 参数_最长等待时间, 整数型, 可空, 注意：此参数只对非强制销毁有效。单位：毫秒，留空或 0 一直等待。 否则到了超时时间会立即返回 假 。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止销毁时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 局部_销毁方式, 整数型, , , 
.局部变量 局部_T, 整数型, , , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (假)
.如果真结束
赋值 (局部_T, InterlockedCompareExchange_ptr (参数_线程池句柄, #线程池_正在销毁, #线程池_正在工作)) ' 三目运算 设置正在销毁状态
.判断开始 (等于 (局部_T, #线程池_未启动)) ' 0 = 已经结束
    返回 (真)
.判断 (不等于 (局部_T, #线程池_正在工作)) ' 2 = 正在创建  ' 3 = 正在销毁
    返回 (假)
.默认
    
.判断结束

赋值 (局部_销毁方式, 参数_销毁方式)
.如果真 (或者 (大于 (局部_销毁方式, 3), 小于 (局部_销毁方式, 0)))
    赋值 (局部_销毁方式, 0)
.如果真结束

 ' 通知任务站立即罢工
.如果真 (或者 (等于 (局部_销毁方式, 0), 等于 (局部_销毁方式, 2)))
    _写整数Ex (参数_线程池句柄, 8, 0)
.如果真结束

 ' 通知等待任务动态结束
SetEvent (_读整数Ex (参数_线程池句柄, 20)) ' event等待任务动态


 ' 通知扩展线程结束
SetEvent (_读整数Ex (参数_线程池句柄, 16)) ' event等待线程创建
SetEvent (_读整数Ex (参数_线程池句柄, 12)) ' event扩展

 ' 通知暂停的线程恢复
SetEvent (_读整数Ex (参数_线程池句柄, 24)) ' event开关

 ' 等待扩展控制线程结束
赋值 (局部_T, 1)
.判断循环首 (并且 (等于 (WaitForSingleObject (_读整数Ex (参数_线程池句柄, 40), 20), 258), 小于或等于 (局部_T, 20)))
    赋值 (局部_T, 相加 (局部_T, 1))
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.判断循环尾 ()
CloseHandle (_读整数Ex (参数_线程池句柄, 40)) ' 销毁扩展线程句柄

 ' 通知任务站不要堵塞了
.如果真 (等于 (参数_是否在UI线程, 真))
    _处理事件 ()
.如果真结束
PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), -1, -1, -2) ' 多丢一个
.计次循环首 (_读整数Ex (参数_线程池句柄, 28), 局部_T)
    PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), -1, -1, -2)
    .如果真 (并且 (等于 (参数_是否在UI线程, 真), 等于 (求余数 (局部_T, 100), 0)))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()

 ' 等待销毁
.如果真 (小于 (局部_销毁方式, 2))
    .如果真 (大于 (参数_最长等待时间, 0))
        赋值 (局部_T, GetTickCount ())
    .如果真结束
    .判断循环首 (等于 (_读整数 (参数_线程池句柄), #线程池_正在销毁))
        .如果真 (大于 (参数_最长等待时间, 0))
            .如果真 (大于 (相减 (GetTickCount (), 局部_T), 参数_最长等待时间))
                返回 (假)
            .如果真结束
            
        .如果真结束
        WaitForSingleObject (_读整数Ex (参数_线程池句柄, 12), 20)
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
返回 (真)

.子程序 线程池Ex_暂停, 逻辑型, , 暂停线程池 （使用的是Event事件拦截。如果想立即暂停 可通过在'&线程子程序'里部署方法'事件_暂停()'拦截Event事件来达到立即暂停的目的）
.参数 参数_线程池句柄, 整数型, , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 (假)
.如果真结束
返回 (ResetEvent (_读整数Ex (参数_线程池句柄, 24))) ' event开关

.子程序 线程池Ex_继续, 逻辑型, , 恢复暂停中的线程池
.参数 参数_线程池句柄, 整数型, , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 (假)
.如果真结束
返回 (SetEvent (_读整数Ex (参数_线程池句柄, 24))) ' event开关

.子程序 线程池Ex_事件_暂停, 逻辑型, , 此方法会等待进入暂停开关事件。如果是未暂停状态可立即进入并返回真。如果是暂停状态则会堵塞等待到事件被触发，然后返回真。超时或线程池非正在工作状态(线程池已销毁)返回假。（放在线程子程序里可以快速控制暂停）
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 (假)
.如果真结束
.如果真 (等于 (是否为空 (参数_超时值), 真))
    赋值 (参数_超时值, -1)
.如果真结束
返回 (等于 (WaitForSingleObject (_读整数Ex (参数_线程池句柄, 24), 参数_超时值), 0)) ' event开关

.子程序 线程池Ex_投递任务, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_执行函数, 子程序指针, , &子程序指针
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 局部_执行函数, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

赋值 (局部_执行函数, 到整数 (参数_执行函数))
.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作), 等于 (局部_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement_ptr (_加法 (参数_线程池句柄, 36)) ' 队列递增
赋值 (bool, PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), 参数_参数一, 参数_参数二, 局部_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement_ptr (_加法 (参数_线程池句柄, 36)) ' 队列递减
.如果真结束
赋值 (局部_执行函数, _读整数Ex (参数_线程池句柄, 28))
.如果真 (并且 (小于 (局部_执行函数, _读整数Ex (参数_线程池句柄, 44)), 大于 (_加法 (_读整数Ex (参数_线程池句柄, 32), _读整数Ex (参数_线程池句柄, 36)), 局部_执行函数)))
    SetEvent (_读整数Ex (参数_线程池句柄, 12))
.如果真结束
返回 (bool)

.子程序 线程池Ex_投递任务_int, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_执行函数, 整数型, , 整数型指针 或 到整数(&子程序指针)
.参数 参数_参数一, 整数型, 可空, 附加的参数1 
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 局部_执行函数, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作), 等于 (局部_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement_ptr (_加法 (参数_线程池句柄, 36)) ' 队列递增
赋值 (bool, PostQueuedCompletionStatus (_读整数Ex (参数_线程池句柄, 4), 参数_参数一, 参数_参数二, 局部_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement_ptr (_加法 (参数_线程池句柄, 36)) ' 队列递减
.如果真结束
赋值 (局部_执行函数, _读整数Ex (参数_线程池句柄, 28))
.如果真 (并且 (小于 (局部_执行函数, _读整数Ex (参数_线程池句柄, 44)), 大于 (_加法 (_读整数Ex (参数_线程池句柄, 32), _读整数Ex (参数_线程池句柄, 36)), 局部_执行函数)))
    SetEvent (_读整数Ex (参数_线程池句柄, 12))
.如果真结束
返回 (bool)

.子程序 线程池Ex_等待任务动态, 逻辑型, , 等待有线程任务执行完毕，返回真。超时或线程池被销毁返回假。（注意：因Event特性不支持多处一起等待！若多处等待请设置下超时值，否则会有一些线程无限堵塞。）
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_等待超时, 整数型, 可空, 超时值。单位：毫秒。 留空或-1为无限等待。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止等待时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 hwndle, 整数型, , , 
.局部变量 ret, 整数型, , , 
.局部变量 t, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 (假)
.如果真结束
赋值 (hwndle, _读整数Ex (参数_线程池句柄, 20))

.判断开始 (等于 (参数_是否在UI线程, 真))
    .如果真 (并且 (等于 (是否为空 (参数_等待超时), 假), 不等于 (参数_等待超时, -1)))
        赋值 (t, GetTickCount ())
        赋值 (bool, 真)
    .如果真结束
    .循环判断首 ()
        _处理事件 ()
        赋值 (ret, WaitForSingleObject (hwndle, 20))
        .如果真 (等于 (bool, 真))
            .如果真 (大于 (相减 (GetTickCount (), t), 参数_等待超时))
                赋值 (ret, -1) ' 跳出循环吧 超时了
            .如果真结束
            
        .如果真结束
        
    .循环判断尾 (并且 (不等于 (ret, 0), 不等于 (ret, -1)))
.默认
    赋值 (ret, WaitForSingleObject (hwndle, 选择 (等于 (是否为空 (参数_等待超时), 真), -1, 参数_等待超时)))
.判断结束
返回 (等于 (ret, 0))

.子程序 线程池Ex_取_空闲线程数, 整数型, , 空闲的线程数量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_减法 (_读整数Ex (参数_线程池句柄, 28), _读整数Ex (参数_线程池句柄, 32)))
 ' 返回 (任务站数量 － 执行任务数量)

.子程序 线程池Ex_取_执行线程数, 整数型, , 正在执行的任务数量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 32))

.子程序 线程池Ex_取_队列任务数, 整数型, , 等待处理的任务数量。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 36))

.子程序 线程池Ex_取_线程池容量, 整数型, , 创建时候的容量（最小线程数）。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 28))

.子程序 线程池Ex_取_最大线程容量, 整数型, , 可动态扩展的容量（最大线程数）。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
返回 (_读整数Ex (参数_线程池句柄, 44))

.子程序 线程池Ex_取_是否空闲, 逻辑型, , 线程池处于彻底空闲状态，没有任何任务在执行。
.参数 参数_线程池句柄, 整数型, , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (真)
.如果真结束
返回 (并且 (等于 (_读整数Ex (参数_线程池句柄, 36), 0), 等于 (_读整数Ex (参数_线程池句柄, 32), 0)))

.子程序 线程池Ex_取状态, 整数型, , 0=未启动，1=正在工作，2=正在创建，3=正在销毁。
.参数 参数_线程池句柄, 整数型, , 

.局部变量 ret, 整数型, , , 

.如果真 (等于 (参数_线程池句柄, 0))
    返回 (0)
.如果真结束
赋值 (ret, _读整数 (参数_线程池句柄))
返回 (选择 (或者 (大于 (ret, 3), 小于 (ret, 0)), 0, ret))

.子程序 线程池Ex_置_最大线程数, 空白型, , （此命令适用于线程池已经创建的状态下） 设置最大/扩展/动态线程数量。（注意：数值低于最小线程数会被自动调整。）
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_新的最扩展线程数量, 整数型, , 不会低于 最小线程数 不会大于系统峰值

.局部变量 当前任务站数量, 整数型, , , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 ()
.如果真结束
.判断开始 (小于 (参数_新的最扩展线程数量, 1))
    _写整数Ex (参数_线程池句柄, 44, 1)
.默认
    _写整数Ex (参数_线程池句柄, 44, 参数_新的最扩展线程数量)
.判断结束
赋值 (当前任务站数量, _读整数Ex (参数_线程池句柄, 28))
.如果真 (并且 (小于 (当前任务站数量, _读整数Ex (参数_线程池句柄, 44)), 大于 (_加法 (_读整数Ex (参数_线程池句柄, 32), _读整数Ex (参数_线程池句柄, 36)), 当前任务站数量)))
    SetEvent (_读整数Ex (参数_线程池句柄, 12))
.如果真结束


.子程序 线程池Ex_置_空闲回收时间, 空白型, , （此命令适用于线程池已经创建的状态下）设置最大/扩展/动态空闲收回时间。 （注意：低于100ms会被自动调整） 
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_新的超时收回时间, 整数型, , 单位：毫秒 不能低于100ms

.局部变量 int, 整数型, , , 

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 ()
.如果真结束
.判断开始 (小于 (参数_新的超时收回时间, 100))
    _写整数Ex (参数_线程池句柄, 48, 100)
.默认
    _写整数Ex (参数_线程池句柄, 48, 参数_新的超时收回时间)
.判断结束


.子程序 线程池Ex_置_线程初始栈大小, 空白型, , （此命令适用于线程池已经创建的状态下）设置最大/扩展/动态空闲收回时间。 （注意：低于100ms会被自动调整） 
.参数 参数_线程池句柄, 整数型, , 
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.如果真 (或者 (等于 (参数_线程池句柄, 0), 不等于 (_读整数 (参数_线程池句柄), #线程池_正在工作)))
    返回 ()
.如果真结束
.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    _写整数Ex (参数_线程池句柄, 52, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    _写整数Ex (参数_线程池句柄, 52, 8192)
.默认
    _写整数Ex (参数_线程池句柄, 52, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束


.类模块 鱼刺类_定时器, , , 定时器/时钟(面向对象)。（类销毁时会自动销毁创建的定时器。）

.程序集变量 handle, 整数型, , , 
.程序集变量 Ptr, 整数型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 ()

.子程序 创建, 逻辑型, , 创建定时器
.参数 参数_周期事件子程序, 子程序指针, 可空, 
.参数 参数_时钟周期, 整数型, 可空, 默认 1000ms （1秒）

.局部变量 Time, 整数型, , , 
.局部变量 hand, 整数型, , , 

.判断开始 (等于 (是否为空 (参数_时钟周期), 真))
    赋值 (Time, 1000)
.默认
    赋值 (Time, 参数_时钟周期)
.判断结束
赋值 (Ptr, 到整数 (参数_周期事件子程序))
赋值 (handle, SetTimer (0, handle, Time, Ptr))
返回 (不等于 (handle, 0))

.子程序 创建_int, 逻辑型, , 创建定时器 整数型子程序指针
.参数 参数_周期事件子程序, 整数型, 可空, 
.参数 参数_时钟周期, 整数型, 可空, 默认 1000ms （1秒）

.局部变量 Time, 整数型, , , 

.判断开始 (等于 (是否为空 (参数_时钟周期), 真))
    赋值 (Time, 1000)
.默认
    赋值 (Time, 参数_时钟周期)
.判断结束
赋值 (Ptr, 参数_周期事件子程序)
赋值 (handle, SetTimer (0, handle, Time, Ptr))
返回 (不等于 (handle, 0))

.子程序 销毁, 逻辑型, , 销毁已经创建的定时器
.局部变量 int, 整数型, , , 

.如果真 (等于 (handle, 0))
    返回 (真)
.如果真结束
赋值 (int, handle)
赋值 (handle, 0)
赋值 (int, KillTimer (0, int))
返回 (不等于 (int, 0))

.子程序 时钟周期, 逻辑型, , 设置新周期时间
.参数 参数_时钟周期, 整数型, 可空, 默认 1000ms （1秒）

.局部变量 Time, 整数型, , , 

.判断开始 (等于 (是否为空 (参数_时钟周期), 真))
    赋值 (Time, 1000)
.默认
    赋值 (Time, 参数_时钟周期)
.判断结束
赋值 (handle, SetTimer (0, handle, Time, Ptr))
返回 (不等于 (handle, 0))


.子程序 __演示_事件函数, 空白型, , _ProcTimer 创建定时器时传入的周期事件函数高级演示 （注意：一下参数不加入也可以 不影响使用 ）
.参数 _hWnd, 整数型, 可空, SetTimer函数中的hWnd参数（窗口句柄）
.参数 _uMsg, 整数型, 可空, 永远是 WM_TIMER 消息 
.参数 _idEvent, 整数型, 可空, SetTimer函数中的nIDEvent参数,如果为空则是SetTimer函数返回的定时器标实 （定时器标识ID）
.参数 _dwTime, 整数型, 可空, 系统启动以来到当前时间的毫秒数 （和 取启动时间() 得到的数值一样）



.程序集 定时器, , , 

.类模块 鱼刺类_队列, , , (v1.9) 内存缓冲区法

.程序集变量 临界资源, 临界许可, , , 临界许可
.程序集变量 Heap, 整数型, , , 堆句柄
.程序集变量 Ptr, 整数型, , , 内存块指针
.程序集变量 Ptrlen, 整数型, , , 内存块长度
.程序集变量 Tmplen, 整数型, , , 缓冲区大小
.程序集变量 Pushi, 整数型, , , 压入位置
.程序集变量 Popi, 整数型, , , 弹出位置
.程序集变量 Count, 整数型, , , 队列长度
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
InitializeCriticalSection_临界许可 (临界资源)
赋值 (Tmplen, 1048576) ' 初始 1mb的缓冲区大小
赋值 (Heap, HeapCreate (1, Tmplen, 0))
赋值 (Ptr, HeapAlloc (Heap, 8, Tmplen))
赋值 (Ptrlen, Tmplen)
赋值 (Pushi, 0)
赋值 (Popi, 0)
赋值 (Count, 0)

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
EnterCriticalSection_临界许可 (临界资源) ' 进入临界
HeapFree (Heap, 1, Ptr) ' 释放内存块
HeapDestroy (Heap) ' 释放堆
赋值 (Count, 0)
赋值 (Ptr, 0)
赋值 (Heap, 0)
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
DeleteCriticalSection_临界许可 (临界资源) ' 删除临界

.子程序 _增量缓冲区, 逻辑型, , 增量缓冲区
.参数 len, 整数型, , 本次需求

.局部变量 tmp_len, 整数型, , , 剩余长度
.局部变量 tmp_ptr, 整数型, , , 

.如果真 (大于 (Popi, 0)) ' 如果之前有弹出 就先重叠移动内存块对齐
    赋值 (Pushi, _减法 (Pushi, Popi)) ' 算出有效数据长度并且交给压入位置
    RtlMoveMemory (Ptr, _加法 (Ptr, Popi), Pushi) ' 搬运内存到首位置
    赋值 (Popi, 0) ' 数据移动到了首部 弹出位置当然是0
    .如果真 (大于或等于 (_减法 (Ptrlen, Pushi), len)) ' 算出剩余内存块长度 如果够本次数据长度 就直接返回 真
        返回 (真)
    .如果真结束
    
.如果真结束
赋值 (tmp_len, _加法Ex (Ptrlen, Tmplen, len)) ' 算出要增量的长度
赋值 (tmp_ptr, HeapReAlloc (Heap, 9, Ptr, tmp_len)) ' 调整内存块大小 增量
.如果真 (等于 (tmp_ptr, 0)) ' 上面的调整内存块失败是不会影响之前的内存快的
    返回 (假) ' 万一调整失败 就返回 假
.如果真结束
赋值 (Ptr, tmp_ptr) ' 成功后要把新的地址赋值
赋值 (Ptrlen, tmp_len) ' 赋值新的长度
返回 (真)

.子程序 _收缩缓冲区, 空白型, , 收缩缓冲区
赋值 (Pushi, _减法 (Pushi, Popi)) ' 算出有效数据长度并且交给压入位置
RtlMoveMemory (Ptr, _加法 (Ptr, Popi), Pushi) ' 搬运内存到首位置
赋值 (Popi, 0) ' 既然都首位置了弹出位置当然是0
赋值 (Ptrlen, _加法 (Pushi, Tmplen)) ' 算出回收后的大小
赋值 (Ptr, HeapReAlloc (Heap, 17, Ptr, Ptrlen)) ' 调整的内存大小 回收内存
返回 ()

.子程序 置缓冲区大小, 空白型, 公开, 置缓冲区大小 缓冲区大小建议是压入数据长度的倍数。（缓冲区大小不影响队列的容量）
.参数 缓冲区大小, 整数型, 可空, 缓冲区大小 默认1M  不能低于1024字节

EnterCriticalSection_临界许可 (临界资源) ' 进入临界
 ' 本源码来自易语言资源网(www.5A5X.com)
.判断开始 (等于 (是否为空 (缓冲区大小), 真))
    赋值 (Tmplen, 1048576) ' 1MB
.判断 (小于 (缓冲区大小, 1024))
    赋值 (Tmplen, 1024)
.默认
    赋值 (Tmplen, 缓冲区大小)
.判断结束
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界

.子程序 取队列长度, 整数型, , 返回当前队列数量。
返回 (Count)

.子程序 清空, 空白型, , 清空队列数据
EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (大于 (Count, 0))
    赋值 (Ptr, HeapReAlloc (Heap, 17, Ptr, Tmplen)) ' 调整的内存大小 回收内存
    赋值 (Ptrlen, Tmplen)
    赋值 (Pushi, 0)
    赋值 (Popi, 0)
    赋值 (Count, 0)
.如果真结束
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界

.子程序 压入字节集, 逻辑型, , 压入字节集 。成功返回真，失败返回假。
.参数 bin, 字节集, , 要压入的数据
.参数 过滤重复, 逻辑型, 可空, 压入时会检测是否已有本数据存在 如果存在则不会压入 并且返回假

.局部变量 len, 整数型, , , 
.局部变量 _i, 整数型, , , 
.局部变量 _len, 整数型, , , 
.局部变量 _bin, 字节集, , , 

赋值 (len, 取字节集长度 (bin))
EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (等于 (过滤重复, 真))
    赋值 (_i, Popi)
    .判断循环首 (小于 (_i, Pushi))
        赋值 (_len, _读整数Ex (Ptr, _i))
        赋值 (_i, _加法 (_i, 4))
        .如果真 (等于 (_len, len)) ' 如果和要检查的数据长度一样 那就读取对比下
            赋值 (_bin, 取空白字节集 (_len))
            RtlMoveMemory_int_Ebin (_bin, _加法 (Ptr, _i), _len)
            .如果真 (等于 (bin, _bin))
                LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
                返回 (假)
            .如果真结束
            
        .如果真结束
        赋值 (_i, _加法 (_i, _len))
    .判断循环尾 ()
.如果真结束

.如果真 (大于 (_加法Ex (Pushi, 4, len), Ptrlen))
    .如果真 (等于 (_增量缓冲区 (_加法 (len, 4)), 假))
        LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
        返回 (假)
    .如果真结束
    
.如果真结束
_写整数Ex (Ptr, Pushi, len)
赋值 (Pushi, _加法 (Pushi, 4))
.如果真 (大于 (len, 0))
    RtlMoveMemory_Ebin_int (_加法 (Ptr, Pushi), bin, len)
    赋值 (Pushi, _加法 (Pushi, len))
.如果真结束
赋值 (Count, 相加 (Count, 1))
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
返回 (真)

.子程序 弹出字节集, 逻辑型, , 弹出字节集 。成功返回真，失败返回假。
.参数 bin, 字节集, 参考, 用来接收弹出数据的变量

.局部变量 len, 整数型, , , 

EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (小于 (Count, 1))
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    赋值 (bin, {  })
    返回 (假)
.如果真结束
赋值 (len, _读整数Ex (Ptr, Popi))
赋值 (Popi, _加法 (Popi, 4))
.如果真 (大于 (len, 0))
    赋值 (bin, 取空白字节集 (len))
    RtlMoveMemory_int_Ebin (bin, _加法 (Ptr, Popi), len)
    赋值 (Popi, _加法 (Popi, len))
.如果真结束
赋值 (Count, 相减 (Count, 1))
.如果真 (大于 (Popi, Tmplen))
    _收缩缓冲区 ()
.如果真结束
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
返回 (真)

.子程序 压入文本, 逻辑型, , 压入文本 。成功返回真，失败返回假。
.参数 str, 文本型, , 要压入的数据
.参数 过滤重复, 逻辑型, 可空, 压入时会检测是否已有本数据存在 如果存在则不会压入 并且返回假

.局部变量 len, 整数型, , , 
.局部变量 _i, 整数型, , , 
.局部变量 _len, 整数型, , , 
.局部变量 _str, 文本型, , , 

赋值 (len, lstrlen (str))
EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (等于 (过滤重复, 真))
    赋值 (_i, Popi)
    .判断循环首 (小于 (_i, Pushi))
        赋值 (_len, _读整数Ex (Ptr, _i))
        赋值 (_i, _加法 (_i, 4))
        .如果真 (等于 (_len, len)) ' 如果和要检查的数据长度一样 那就读取对比下
            赋值 (_str, 取空白文本 (_len))
            RtlMoveMemory_int_Estr (_str, _加法 (Ptr, _i), _len)
            .如果真 (等于 (str, _str))
                LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
                返回 (假)
            .如果真结束
            
        .如果真结束
        赋值 (_i, _加法 (_i, _len))
    .判断循环尾 ()
.如果真结束

.如果真 (大于 (_加法Ex (Pushi, 4, len), Ptrlen))
    .如果真 (等于 (_增量缓冲区 (_加法 (len, 4)), 假))
        LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
        返回 (假)
    .如果真结束
    
.如果真结束
_写整数Ex (Ptr, Pushi, len)
赋值 (Pushi, _加法 (Pushi, 4))
.如果真 (大于 (len, 0))
    RtlMoveMemory_Estr_int (_加法 (Ptr, Pushi), str, len)
    赋值 (Pushi, _加法 (Pushi, len))
.如果真结束
赋值 (Count, 相加 (Count, 1))
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
返回 (真)

.子程序 弹出文本, 逻辑型, , 弹出文本 。成功返回真，失败返回假。
.参数 str, 文本型, 参考, 用来接收弹出数据的变量

.局部变量 len, 整数型, , , 

EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (小于 (Count, 1))
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    赋值 (str, “”)
    返回 (假)
.如果真结束
赋值 (len, _读整数Ex (Ptr, Popi))
赋值 (Popi, _加法 (Popi, 4))
.如果真 (大于 (len, 0))
    赋值 (str, 取空白文本 (len))
    RtlMoveMemory_int_Estr (str, _加法 (Ptr, Popi), len)
    赋值 (Popi, _加法 (Popi, len))
.如果真结束
赋值 (Count, 相减 (Count, 1))
.如果真 (大于 (Popi, Tmplen))
    _收缩缓冲区 ()
.如果真结束
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
返回 (真)

.子程序 压入整数, 逻辑型, , 压入整数 。成功返回真，失败返回假。
.参数 int, 整数型, , 要压入的数据
.参数 过滤重复, 逻辑型, 可空, 压入时会检测是否已有本数据存在 如果存在则不会压入 并且返回假

.局部变量 _i, 整数型, , , 

EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (等于 (过滤重复, 真))
    赋值 (_i, Popi)
    .判断循环首 (小于 (_i, Pushi))
        赋值 (_i, _加法 (_i, 4))
        .如果真 (等于 (int, _读整数Ex (Ptr, _i))) ' 比较是否一样
            LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
            返回 (假)
        .如果真结束
        赋值 (_i, _加法 (_i, 4))
    .判断循环尾 ()
.如果真结束
.如果真 (大于 (_加法 (Pushi, 8), Ptrlen))
    .如果真 (等于 (_增量缓冲区 (8), 假))
        LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
        返回 (假)
    .如果真结束
    
.如果真结束
_写整数Ex (Ptr, Pushi, 4)
赋值 (Pushi, _加法 (Pushi, 4))
_写整数Ex (Ptr, Pushi, int)
赋值 (Pushi, _加法 (Pushi, 4))
赋值 (Count, 相加 (Count, 1))
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
返回 (真)

.子程序 弹出整数, 逻辑型, , 弹出整数 。成功返回真，失败返回假。
.参数 int, 整数型, 参考, 用来接收弹出数据的变量

.局部变量 len, 整数型, , , 

EnterCriticalSection_临界许可 (临界资源) ' 进入临界
.如果真 (小于 (Count, 1))
    LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
    赋值 (int, 0)
    返回 (假)
.如果真结束
赋值 (len, _读整数Ex (Ptr, Popi))
赋值 (Popi, _加法 (Popi, 4))
.如果真 (大于 (len, 0))
    赋值 (int, _读整数Ex (Ptr, Popi))
    赋值 (Popi, _加法 (Popi, len))
.如果真结束
赋值 (Count, 相减 (Count, 1))
.如果真 (大于 (Popi, Tmplen))
    _收缩缓冲区 ()
.如果真结束
LeaveCriticalSection_临界许可 (临界资源) ' 退出临界
返回 (真)

.程序集 _内存读写_asm, , , 

.子程序 _读整数, 整数型, , 读内存整数型
.参数 指针, 整数型, , 

置入代码 ({ 139, 69, 8, 139, 0, 201, 194, 4, 0 })
返回 (0)
 ' mov eax,[ebp+8]
 ' mov eax,[eax]
 ' leave
 ' retn 4

.子程序 _写整数, 整数型, , 写内存整数型 返回写入后的值
.参数 指针, 整数型, , 
.参数 值, 整数型, , 

置入代码 ({ 139, 69, 8, 139, 77, 12, 137, 8, 201, 194, 8, 0 })
返回 (0)
 ' mov eax,[ebp+8]
 ' mov ecx,[ebp+12]
 ' mov [eax],ecx
 ' leave
 ' retn 8

.子程序 _读整数Ex, 整数型, , 读内存整数型带偏移
.参数 ptr, 整数型, , 
.参数 i, 整数型, , 

置入代码 ({ 139, 69, 8, 3, 69, 12, 139, 0, 201, 194, 8, 0 })
返回 (0)
 ' mov eax, dword ptr [ebp+8]
 ' add eax, dword ptr [ebp+12]
 ' mov eax, dword ptr [eax]
 ' leave
 ' retn 8

.子程序 _写整数Ex, 空白型, , 写内存整数型带偏移 无返回值
.参数 ptr, 整数型, , 
.参数 i, 整数型, , 
.参数 data, 整数型, , 

置入代码 ({ 139, 93, 8, 3, 93, 12, 139, 77, 16, 137, 11 })
 ' mov ebx, dword ptr [ebp+8]
 ' add ebx, dword ptr [ebp+12]
 ' mov ecx, dword ptr [ebp+16]
 ' mov dword ptr [ebx], ecx

.程序集 _数值运算_asm, , , 

.子程序 _加法, 整数型, , 汇编加法
.参数 被加数, 整数型, , 
.参数 加数, 整数型, , 

置入代码 ({ 139, 69, 8, 3, 69, 12, 201, 194, 8, 0 })
返回 (0)
 ' mov eax, dword ptr [ebp+08h]
 ' add eax, dword ptr [ebp+0Ch]
 ' leave
 ' retn 008h


.子程序 _加法Ex, 整数型, , 汇编加法 Ex
.参数 被加数, 整数型, , 
.参数 加数1, 整数型, , 
.参数 加数2, 整数型, , 

置入代码 ({ 139, 69, 8, 3, 69, 12, 3, 69, 16, 201, 194, 12, 0 })
返回 (0)
 ' mov eax, dword ptr [ebp+08h]
 ' add eax, dword ptr [ebp+0Ch]
 ' add eax, dword ptr [ebp+10h]
 ' leave
 ' retn 00ch

.子程序 _减法, 整数型, , 汇编减法
.参数 被减数, 整数型, , 
.参数 减数, 整数型, , 

置入代码 ({ 139, 69, 8, 43, 69, 12, 201, 194, 8, 0 })
返回 (0)
 ' mov eax, dword ptr [ebp+08h]
 ' sub eax, dword ptr [ebp+0Ch]
 ' leave
 ' retn 008h

.子程序 _减法Ex, 整数型, , 汇编减法 Ex
.参数 被减数, 整数型, , 
.参数 减数1, 整数型, , 
.参数 减数2, 整数型, , 

置入代码 ({ 139, 69, 8, 43, 69, 12, 43, 69, 16, 201, 194, 12, 0 })
返回 (0)
 ' mov eax, dword ptr [ebp+08h]
 ' sub eax, dword ptr [ebp+0Ch]
 ' sub eax, dword ptr [ebp+10h]
 ' leave
 ' retn 00ch

.类模块 鱼刺类_完成端口, , , I/O完成端口 (IOCP)

.程序集变量 hwndle, 整数型, , , I/O句柄
.程序集变量 Count, 整数型, , , 队列长度
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
赋值 (hwndle, CreateIoCompletionPort (-1, 0, 0, 0))

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
CloseHandle (hwndle)

.子程序 投递, 逻辑型, , 向I/O完成端口里投递消息。成功返回真，失败返回假。
.参数 参数_信息一, 整数型, 可空, 
.参数 参数_信息二, 整数型, 可空, 
.参数 参数_信息三, 整数型, 可空, 

.局部变量 bool, 逻辑型, , , 

赋值 (bool, PostQueuedCompletionStatus (hwndle, 参数_信息一, 参数_信息二, 参数_信息三))
.如果真 (等于 (bool, 真))
    InterlockedIncrement (Count)
.如果真结束
返回 (bool)

.子程序 获取, 逻辑型, , 从I/O完成端口里获取消息。成功返回真，失败或超时返回假。
.参数 返回_信息一, 整数型, 参考 可空, 
.参数 返回_信息二, 整数型, 参考 可空, 
.参数 返回_信息三, 整数型, 参考 可空, 
.参数 参数_超时值, 整数型, 可空, 等待超时值 留空 -1（无限等待) 

.局部变量 bool, 逻辑型, , , 

.如果真 (等于 (是否为空 (参数_超时值), 真))
    赋值 (参数_超时值, -1)
.如果真结束
赋值 (bool, GetQueuedCompletionStatus (hwndle, 返回_信息一, 返回_信息二, 返回_信息三, 参数_超时值))
.如果真 (等于 (bool, 真))
    InterlockedDecrement (Count)
.如果真结束
返回 (bool)

.子程序 取队列数, 整数型, , 取I/O完成端口里剩余的消息数量。
返回 (Count)

.子程序 清空, 空白型, , 清空I/O完成端口里的消息。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止清空时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 ret1, 整数型, , , 
.局部变量 ret2, 整数型, , , 
.局部变量 ret3, 整数型, , , 
.局部变量 int, 整数型, , , 

.判断循环首 (等于 (GetQueuedCompletionStatus (hwndle, ret1, ret2, ret3, 0), 真))
    InterlockedDecrement (Count)
    .如果真 (等于 (参数_是否在UI线程, 真))
        赋值 (int, 相加 (int, 1))
        .如果真 (等于 (求余数 (int, 1000), 0))
            赋值 (int, 0)
            _处理事件 ()
        .如果真结束
        
    .如果真结束
    
.判断循环尾 ()

.程序集 内存存取, , , 简单内存读写 用于传参

.子程序 _写内存文本, 整数型, , 成功返回内存指针地址，失败返回0。
.参数 str, 文本型, , 要存放到内存的文本数据

.局部变量 len, 整数型, , , 
.局部变量 ptr, 整数型, , , 

赋值 (len, 取文本长度 (str))
.如果真 (小于 (len, 1))
    返回 (0)
.如果真结束
赋值 (ptr, HeapAlloc (DefaultHeap, 8, _加法 (4, len)))
.如果真 (等于 (ptr, 0))
    返回 (0)
.如果真结束
_写整数 (ptr, len)
RtlMoveMemory_Estr_int (_加法 (ptr, 4), str, len)
返回 (ptr)

.子程序 _读内存文本, 文本型, , 成功返回预先保存的文本数据，失败返回空文本。
.参数 ptr, 整数型, , _写内存文本() 返回的内存指针地址
.参数 IsFree, 逻辑型, 可空, 留空/默认=真，读取后是否自动销毁/释放内存。

.局部变量 len, 整数型, , , 
.局部变量 str, 文本型, , , 

.如果真 (等于 (ptr, 0))
    返回 (“”)
.如果真结束
赋值 (len, _读整数 (ptr))
.如果真 (小于 (len, 1))
    返回 (“”)
.如果真结束
赋值 (str, 取空白文本 (len))
RtlMoveMemory_int_Estr (str, _加法 (ptr, 4), len)
.如果真 (或者 (等于 (是否为空 (IsFree), 真), 等于 (IsFree, 真)))
    HeapFree (DefaultHeap, 0, ptr)
.如果真结束
返回 (str)


.子程序 _写内存字节集, 整数型, , 成功返回内存指针地址，失败返回0。
.参数 bin, 字节集, , 要存放到内存的字节集数据

.局部变量 len, 整数型, , , 
.局部变量 ptr, 整数型, , , 

赋值 (len, 取字节集长度 (bin))
.如果真 (小于 (len, 1))
    返回 (0)
.如果真结束
赋值 (ptr, HeapAlloc (DefaultHeap, 8, _加法 (4, len)))
.如果真 (等于 (ptr, 0))
    返回 (0)
.如果真结束
_写整数 (ptr, len)
RtlMoveMemory_Ebin_int (_加法 (ptr, 4), bin, len)
返回 (ptr)

.子程序 _读内存字节集, 字节集, , 成功返回预先保存的字节集数据，失败返回空字节集。
.参数 ptr, 整数型, , _写内存字节集() 返回的内存指针地址
.参数 IsFree, 逻辑型, 可空, 留空/默认=真，读取后是否自动销毁/释放内存。

.局部变量 len, 整数型, , , 
.局部变量 bin, 字节集, , , 

.如果真 (等于 (ptr, 0))
    返回 ({  })
.如果真结束
赋值 (len, _读整数 (ptr))
.如果真 (小于 (len, 1))
    返回 ({  })
.如果真结束
赋值 (bin, 取空白字节集 (len))
RtlMoveMemory_int_Ebin (bin, _加法 (ptr, 4), len)
.如果真 (或者 (等于 (是否为空 (IsFree), 真), 等于 (IsFree, 真)))
    HeapFree (DefaultHeap, 0, ptr)
.如果真结束
返回 (bin)


.类模块 鱼刺类_读写锁, , , (v1.3) 读写锁（面向对象）同时读 单一写

.程序集变量 hEvent, 整数型, , , Event事件对象
.程序集变量 hMutex, 整数型, , , Mutex互斥量
.程序集变量 hCount, 整数型, , , 读锁计次
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
赋值 (hEvent, CreateEvent_int (0, 真, 真, 0))
赋值 (hMutex, CreateMutex_int (0, 假, 0))

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
CloseHandle (hEvent)
CloseHandle (hMutex)

.子程序 读锁定, 逻辑型, , 进入读锁。成功返回真，超时返回假。
.参数 超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.局部变量 code, 整数型, , , 

.如果真 (等于 (是否为空 (超时值), 真))
    赋值 (超时值, -1)
.如果真结束
赋值 (code, WaitForSingleObject (hMutex, 超时值))
.如果真 (等于 (code, 258))
    返回 (假)
.如果真结束
.如果真 (等于 (InterlockedIncrement (hCount), 1))
    ResetEvent (hEvent)
.如果真结束
ReleaseMutex (hMutex)
返回 (真)

.子程序 写锁定, 逻辑型, , 进入写锁。成功返回真。超时返回假。
.参数 超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.局部变量 code, 整数型, , , 
.局部变量 t, 整数型, , , 

.如果真 (等于 (是否为空 (超时值), 真))
    赋值 (超时值, -1)
.如果真结束
赋值 (code, WaitForSingleObject (hMutex, 超时值))
.如果真 (等于 (code, 258))
    返回 (假)
.如果真结束
赋值 (code, WaitForSingleObject (hEvent, 超时值))
.如果真 (等于 (code, 258))
    ReleaseMutex (hMutex)
    返回 (假)
.如果真结束
返回 (真)

.子程序 解锁, 空白型, , 退出读/写锁。
 ' 如果其他线程刚好调用了 读锁定 并且刚获取到互斥对象还没释放 这时候调用这个安全吗？
 ' 答案是安全的 因为非同一线程无效的
.如果真 (等于 (ReleaseMutex (hMutex), 假))
    .如果真 (等于 (InterlockedDecrement (hCount), 0))
        SetEvent (hEvent)
    .如果真结束
    
.如果真结束



.程序集 读写锁, , , 读写锁

.子程序 读写锁_创建, 整数型, , 创建读写锁。成功返回读写锁指针。失败返回0。
.局部变量 ptr, 整数型, , , 
.局部变量 hEvent, 整数型, , , 
.局部变量 hMutex, 整数型, , , 

赋值 (ptr, HeapAlloc (DefaultHeap, 8, 12))
.如果真 (等于 (ptr, 0))
    返回 (0)
.如果真结束
赋值 (hMutex, CreateMutex_int (0, 假, 0))
.如果真 (等于 (hMutex, 0))
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
赋值 (hEvent, CreateEvent_int (0, 真, 真, 0))
.如果真 (等于 (hEvent, 0))
    CloseHandle (hMutex)
    HeapFree (DefaultHeap, 0, ptr)
    返回 (0)
.如果真结束
_写整数 (ptr, hMutex)
_写整数Ex (ptr, 4, hEvent)
返回 (ptr)

.子程序 读写锁_销毁, 空白型, , 销毁读写锁。
.参数 读写锁, 整数型, , 

.局部变量 ptr, 整数型, , , 

.如果真 (等于 (读写锁, 0))
    返回 ()
.如果真结束
赋值 (ptr, _读整数 (读写锁))
.如果真 (不等于 (ptr, 0))
    CloseHandle (ptr)
.如果真结束
赋值 (ptr, _读整数Ex (读写锁, 4))
.如果真 (不等于 (ptr, 0))
    CloseHandle (ptr)
.如果真结束
HeapFree (DefaultHeap, 0, 读写锁)

.子程序 读写锁_读锁定, 逻辑型, , 进入读锁。成功返回真，超时返回假。
.参数 读写锁, 整数型, , 读写锁指针
.参数 超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.局部变量 hMutex, 整数型, , , 
.局部变量 hEvent, 整数型, , , 
.局部变量 code, 整数型, , , 

.如果真 (等于 (读写锁, 0))
    返回 (假)
.如果真结束
.如果真 (等于 (是否为空 (超时值), 真))
    赋值 (超时值, -1)
.如果真结束
赋值 (hMutex, _读整数 (读写锁))
.如果真 (等于 (hMutex, 0))
    返回 (假)
.如果真结束
赋值 (code, WaitForSingleObject (hMutex, 超时值))
.如果真 (或者 (等于 (code, 258), 等于 (code, -1)))
    返回 (假)
.如果真结束
.如果真 (等于 (InterlockedIncrement_ptr (_加法 (读写锁, 8)), 1))
    赋值 (hEvent, _读整数Ex (读写锁, 4))
    .如果真 (或者 (等于 (hEvent, 0), 等于 (ResetEvent (hEvent), 假)))
        ReleaseMutex (hMutex)
        返回 (假)
    .如果真结束
    
.如果真结束
.如果真 (等于 (ReleaseMutex (hMutex), 假))
    返回 (假)
.如果真结束
返回 (真)

.子程序 读写锁_写锁定, 逻辑型, , 进入写锁。成功返回真。超时返回假。
.参数 读写锁, 整数型, , 读写锁指针
.参数 超时值, 整数型, 可空, 单位:毫秒， 默认为 -1 无限等待。

.局部变量 hMutex, 整数型, , , 
.局部变量 hEvent, 整数型, , , 
.局部变量 code, 整数型, , , 

.如果真 (等于 (读写锁, 0))
    返回 (假)
.如果真结束
.如果真 (等于 (是否为空 (超时值), 真))
    赋值 (超时值, -1)
.如果真结束
赋值 (hMutex, _读整数 (读写锁))
.如果真 (等于 (hMutex, 0))
    返回 (假)
.如果真结束
赋值 (code, WaitForSingleObject (hMutex, 超时值))
.如果真 (或者 (等于 (code, 258), 等于 (code, -1)))
    返回 (假)
.如果真结束
赋值 (hEvent, _读整数Ex (读写锁, 4))
.如果真 (等于 (hEvent, 0))
    ReleaseMutex (hMutex)
    返回 (假)
.如果真结束
赋值 (code, WaitForSingleObject (hEvent, 超时值))
.如果真 (或者 (等于 (code, 258), 等于 (code, -1)))
    ReleaseMutex (hMutex)
    返回 (假)
.如果真结束
返回 (真)

.子程序 读写锁_解锁, 逻辑型, , 退出读/写锁。成功返回真。失败返回假。
.参数 读写锁, 整数型, , 读写锁指针

.局部变量 hMutex, 整数型, , , 
.局部变量 hEvent, 整数型, , , 

.如果真 (等于 (读写锁, 0))
    返回 (假)
.如果真结束
赋值 (hMutex, _读整数 (读写锁))
.如果真 (等于 (hMutex, 0))
    返回 (假)
.如果真结束
.如果真 (等于 (ReleaseMutex (hMutex), 假))
    .如果真 (不等于 (GetLastError (), 288))
        返回 (假)
    .如果真结束
    赋值 (hEvent, _读整数Ex (读写锁, 4))
    .如果真 (等于 (hEvent, 0))
        返回 (假)
    .如果真结束
    .如果真 (等于 (InterlockedDecrement_ptr (_加法 (读写锁, 8)), 0))
        .如果真 (等于 (SetEvent (hEvent), 假))
            返回 (假)
        .如果真结束
        
    .如果真结束
    
.如果真结束
返回 (真)




.程序集 完成端口, , , IOCP

.子程序 完成端口_创建, 整数型, , 创建I/O完成端口。成功返回句柄，失败返回0。
.参数 a, 整数型, 可空, 
.参数 b, 整数型, 可空, 
.参数 c, 整数型, 可空, 
.参数 d, 整数型, 可空, 

.如果真 (等于 (是否为空 (a), 真))
    赋值 (a, -1)
.如果真结束
返回 (CreateIoCompletionPort (a, b, c, d))

.子程序 完成端口_销毁, 逻辑型, , 销毁I/O完成端口。
.参数 参数_完成端口句柄, 整数型, , 

返回 (CloseHandle (参数_完成端口句柄))

.子程序 完成端口_投递, 逻辑型, , 向I/O完成端口里投递消息。成功返回真，失败返回假。
.参数 参数_完成端口句柄, 整数型, , 
.参数 参数_信息一, 整数型, 可空, 
.参数 参数_信息二, 整数型, 可空, 
.参数 参数_信息三, 整数型, 可空, 

返回 (PostQueuedCompletionStatus (参数_完成端口句柄, 参数_信息一, 参数_信息二, 参数_信息三))

.子程序 完成端口_获取, 逻辑型, , 从I/O完成端口里获取消息。成功返回真，失败或超时返回假。
.参数 参数_完成端口句柄, 整数型, , 
.参数 返回_信息一, 整数型, 参考 可空, 
.参数 返回_信息二, 整数型, 参考 可空, 
.参数 返回_信息三, 整数型, 参考 可空, 
.参数 参数_超时值, 整数型, 可空, 等待超时值 留空 -1（无限等待) 

返回 (GetQueuedCompletionStatus (参数_完成端口句柄, 返回_信息一, 返回_信息二, 返回_信息三, 参数_超时值))


.类模块 鱼刺类_线程池_自销毁, , , 此方案特点：无需销毁。(空闲超时自动销毁)

.程序集变量 回调地址_任务函数, 整数型, , , 
.程序集变量 匿名程序集变量_9283, 空白型, , , 
.程序集变量 IOCP任务站, 整数型, , , 
.程序集变量 工作状态, 整数型, , , 0未启动 1运行中 2正在创建 3正在销毁
.程序集变量 循环条件, 逻辑型, , , 这个变量来控制线程池结束状态
.程序集变量 任务站数量, 整数型, , , 
.程序集变量 执行任务数量, 整数型, , , 
.程序集变量 队列任务数量, 整数型, , , 
.程序集变量 Event专用, 整数型, , , 销毁专用
.程序集变量 自销毁超时值, 整数型, , , 一定时间内未接收到任务会自动销毁任务站
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
赋值 (回调地址_任务函数, 类回调_生成类函数地址 (1))

.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用
销毁 (2)
类回调_释放类函数地址 (回调地址_任务函数)

.子程序 任务函数, 空白型, , 
.局部变量 局部_参数一, 整数型, , , 
.局部变量 局部_参数二, 整数型, , , 
.局部变量 局部_函数地址, 整数型, , , 
.局部变量 局部_任务结果, 逻辑型, , , 

InterlockedIncrement (任务站数量) ' 递增
.如果真 (不等于 (Event专用, 0))
    SetEvent (Event专用)
.如果真结束
赋值 (局部_任务结果, GetQueuedCompletionStatus (IOCP任务站, 局部_参数一, 局部_参数二, 局部_函数地址, 自销毁超时值))
.判断循环首 (并且 (等于 (循环条件, 真), 不等于 (局部_函数地址, -2), 等于 (局部_任务结果, 真)))
     ' 先加执行后减队列是为了能精确判断 是否空闲()
    InterlockedIncrement (执行任务数量) ' 递增
    InterlockedDecrement (队列任务数量) ' 递减
    
     ' 执行任务楼
    调用子程序_asm (局部_函数地址, 局部_参数一, 局部_参数二)
    
    InterlockedDecrement (执行任务数量) ' 递减
    
    赋值 (局部_任务结果, GetQueuedCompletionStatus (IOCP任务站, 局部_参数一, 局部_参数二, 局部_函数地址, 自销毁超时值))
.判断循环尾 ()
 ' API版的原子锁可得到递减后的结果 所以也可达到精确判断
赋值 (局部_参数一, InterlockedDecrement (任务站数量)) ' 递减
.如果真 (等于 (局部_参数一, 0))
     ' 全部销毁消息都接收到了 直接销毁IOCP
    赋值 (局部_函数地址, InterlockedExchange (IOCP任务站, 0)) ' 赋值
    .如果真 (不等于 (局部_函数地址, 0))
        CloseHandle (局部_函数地址)
    .如果真结束
    
    .如果真 (不等于 (Event专用, 0))
        赋值 (局部_函数地址, InterlockedExchange (Event专用, 0)) ' 赋值
        SetEvent (局部_函数地址)
        CloseHandle (局部_函数地址)
    .如果真结束
    
     ' 还原初始化状态
    赋值 (循环条件, 假)
    连续赋值 (0, 任务站数量, 执行任务数量, 队列任务数量)
    
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
.如果真结束
返回 ()

.子程序 创建, 逻辑型, , 创建并启动线程池，并开始等待任务投递。成功返回真，失败返回假。
.参数 参数_线程池容量, 整数型, 可空, 同时工作的线程数。留空为 5
.参数 参数_线程空闲自销毁超时值, 整数型, 可空, 如果任务过少持续一定时间后线程会被自动收回（销毁）。单位：毫秒。 留空为 5000ms (5秒).。 （注意：空闲收回超时最低100ms 毫秒）
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止创建时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假
.参数 参数_初始栈大小, 整数型, 可空, 创建的线程的初始栈大小。以字节为单位，必须是4KB的倍数且最小8KB(8192字节)。如果为空或0，那么默认将使用与调用该函数的线程相同的栈空间大小。（一般为1M (1048576字节)，不用担心太少，任何情况下Windows会根据需要动态延长堆栈的大小。）

.局部变量 局_线程池容量, 整数型, , , 
.局部变量 局_初始栈大小, 整数型, , , 
.局部变量 局_time, 整数型, , , 
.局部变量 局_int, 整数型, , , 
.局部变量 局_int2, 整数型, , , 

赋值 (局_int, InterlockedCompareExchange (工作状态, #线程池_正在创建, #线程池_未启动)) ' 三目运算
.如果真 (不等于 (局_int, #线程池_未启动))
    返回 (假)
.如果真结束

.判断开始 (等于 (是否为空 (参数_线程池容量), 真))
    赋值 (局_线程池容量, 5)
.判断 (小于 (参数_线程池容量, 1))
    赋值 (局_线程池容量, 1)
.默认
    赋值 (局_线程池容量, 参数_线程池容量)
.判断结束


.判断开始 (等于 (是否为空 (参数_线程空闲自销毁超时值), 真))
    赋值 (参数_线程空闲自销毁超时值, 5000)
.判断 (小于 (参数_线程空闲自销毁超时值, 100))
    赋值 (自销毁超时值, 100)
.默认
    赋值 (自销毁超时值, 参数_线程空闲自销毁超时值)
.判断结束


.判断开始 (等于 (是否为空 (参数_初始栈大小), 真))
    赋值 (局_初始栈大小, 0)
.判断 (并且 (不等于 (参数_初始栈大小, 0), 小于 (参数_初始栈大小, 8192)))
    赋值 (局_初始栈大小, 8192)
.默认
    赋值 (局_初始栈大小, 相减 (参数_初始栈大小, 求余数 (参数_初始栈大小, 4096)))
.判断结束

赋值 (IOCP任务站, CreateIoCompletionPort (-1, 0, 0, 0))
.如果真 (等于 (IOCP任务站, 0))
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束

赋值 (循环条件, 真) ' 触发循环
连续赋值 (0, 任务站数量, 执行任务数量, 队列任务数量, 局_int, 局_int2)

赋值 (Event专用, CreateEvent_int (0, 假, 假, 0))

.计次循环首 (局_线程池容量, ) ' 创建线程。
    赋值 (局_time, CreateThread_Int (0, 局_初始栈大小, 回调地址_任务函数, 0, 0, 0))
    .判断开始 (不等于 (局_time, 0))
        CloseHandle (局_time)
        赋值 (局_int, 相加 (局_int, 1)) ' 为了防止创建线超出系统程极限而导致时间等待过长。
        赋值 (局_int2, 0)
    .默认
        赋值 (局_int2, 相加 (局_int2, 1))
        .如果真 (大于或等于 (局_int2, 5)) ' 连续5次创建线程失败跳出。
            跳出循环 ()
        .如果真结束
        
    .判断结束
    .如果真 (等于 (参数_是否在UI线程, 真))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()
.如果真 (大于 (局_int, 0))
     ' 下面是防止立即销毁时线程还没得到IOCP导致有部分线程未能被销毁。
    赋值 (局_time, GetTickCount ())
    赋值 (局_int2, 相加 (相乘 (局_int, 10), 1000))
    .判断循环首 (并且 (小于 (任务站数量, 局_int), 小于 (相减 (GetTickCount (), 局_time), 局_int2)))
        .判断开始 (不等于 (Event专用, 0))
            WaitForSingleObject (Event专用, 20)
        .默认
            Sleep (1)
        .判断结束
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
.如果真 (不等于 (Event专用, 0))
    CloseHandle (Event专用)
    赋值 (Event专用, 0)
.如果真结束
.如果真 (等于 (任务站数量, 0))
    赋值 (循环条件, 假)
    CloseHandle (IOCP任务站)
    赋值 (IOCP任务站, 0)
    InterlockedExchange (工作状态, #线程池_未启动) ' 赋值
    返回 (假)
.如果真结束


InterlockedExchange (工作状态, #线程池_正在工作) ' 赋值

返回 (真)

.子程序 销毁, 逻辑型, , 销毁线程池。成功或已经销毁返回真，失败返回假。（失败原因包括：线程池已经正销毁、线程池正在创建、到了超时时间） 
.参数 参数_销毁方式, 整数型, 可空, 0=正常销毁（等待当前任务执行后返回 真 ），1=温柔销毁（等待投递进去的任务全部执行完毕后返回 真 ），2=强制销毁（丢出销毁命令后立即返回 真  注意：此方式执行成功后不代表线程池已经销毁！依然是按照正常销毁那样 当前任务执行完毕后线程池才算真正销毁。），3=强制温柔销毁(丢出温柔销毁命令后立即返回 真 。注意：此方式执行成功后不代表线程池已经销毁！依然是按照温柔销毁那样 投递进去的任务全部执行完毕后线程池才算真正销毁。)。提示：执行强制销毁后可通过 取_状态() 方法来继续探测线程池当前的状态。
.参数 参数_最长等待时间, 整数型, 可空, 注意：此参数只对非强制销毁有效。单位：毫秒，留空或 0 一直等待。 否则到了超时时间会立即返回 假 。
.参数 参数_是否在UI线程, 逻辑型, 可空, 如果在UI线程中，会自动执行‘处理事件’来防止销毁时UI假死（窗口假死）。非UI线程请忽略或填假。留空为 假

.局部变量 局部_销毁方式, 整数型, , , 
.局部变量 局部_T, 整数型, , , 


赋值 (局部_T, InterlockedCompareExchange (工作状态, #线程池_正在销毁, #线程池_正在工作)) ' 三目运算 设置正在销毁状态
.如果真 (等于 (局部_T, #线程池_未启动)) ' 0 = 已经结束
    返回 (真)
.如果真结束
.如果真 (或者 (等于 (局部_T, #线程池_正在创建), 等于 (局部_T, #线程池_正在销毁))) ' 2 = 正在创建  ' 3 = 正在销毁
    返回 (假)
.如果真结束

赋值 (局部_销毁方式, 参数_销毁方式)
.如果真 (或者 (大于 (局部_销毁方式, 3), 小于 (局部_销毁方式, 0)))
    赋值 (局部_销毁方式, 0)
.如果真结束
.如果真 (小于 (局部_销毁方式, 2))
    赋值 (Event专用, CreateEvent_int (0, 假, 假, 0))
.如果真结束
.如果真 (或者 (等于 (局部_销毁方式, 0), 等于 (局部_销毁方式, 2)))
    赋值 (循环条件, 假)
.如果真结束

 ' 通知任务站不要堵塞了
.计次循环首 (任务站数量, 局部_T)
    PostQueuedCompletionStatus (IOCP任务站, -1, -1, -2)
    .如果真 (并且 (等于 (参数_是否在UI线程, 真), 等于 (求余数 (局部_T, 100), 0)))
        _处理事件 ()
    .如果真结束
    
.计次循环尾 ()

.如果真 (小于 (局部_销毁方式, 2))
    .如果真 (大于 (参数_最长等待时间, 0))
        赋值 (局部_T, GetTickCount ())
    .如果真结束
    .判断循环首 (等于 (工作状态, #线程池_正在销毁))
        .如果真 (大于 (参数_最长等待时间, 0))
            .如果真 (大于 (相减 (GetTickCount (), 局部_T), 参数_最长等待时间))
                返回 (假)
            .如果真结束
            
        .如果真结束
        .判断开始 (不等于 (Event专用, 0))
            WaitForSingleObject (Event专用, 20)
        .默认
            Sleep (1)
        .判断结束
        .如果真 (等于 (参数_是否在UI线程, 真))
            _处理事件 ()
        .如果真结束
        
    .判断循环尾 ()
.如果真结束
返回 (真)

.子程序 投递任务, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_执行函数, 子程序指针, , &子程序指针
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 局部_执行函数, 整数型, , , 
.局部变量 bool, 逻辑型, , , 

赋值 (局部_执行函数, 到整数 (参数_执行函数))
.如果真 (或者 (不等于 (工作状态, #线程池_正在工作), 等于 (局部_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement (队列任务数量) ' 递增
赋值 (bool, PostQueuedCompletionStatus (IOCP任务站, 参数_参数一, 参数_参数二, 局部_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement (队列任务数量) ' 递减
.如果真结束
返回 (bool)

.子程序 投递任务_int, 逻辑型, , 向线程池里投递任务。成功返回真，失败返回假。
.参数 参数_执行函数, 整数型, , 整数型指针 或 到整数(&子程序指针)
.参数 参数_参数一, 整数型, 可空, 附加的参数1
.参数 参数_参数二, 整数型, 可空, 附加的参数2

.局部变量 bool, 逻辑型, , , 

.如果真 (或者 (不等于 (工作状态, #线程池_正在工作), 等于 (参数_执行函数, 0)))
    返回 (假)
.如果真结束
InterlockedIncrement (队列任务数量) ' 递增
赋值 (bool, PostQueuedCompletionStatus (IOCP任务站, 参数_参数一, 参数_参数二, 参数_执行函数))
.如果真 (等于 (bool, 假))
     ' 这样写是防止无法精确判断空闲状态
    InterlockedDecrement (队列任务数量) ' 递减
.如果真结束
返回 (bool)

.子程序 取_空闲线程数, 整数型, , 空闲的线程数量。
返回 (_减法 (任务站数量, 执行任务数量))
 ' 返回 (任务站数量 － 执行任务数量)

.子程序 取_执行线程数, 整数型, , 正在执行的任务数量。
返回 (执行任务数量)

.子程序 取_队列任务数, 整数型, , 等待处理的任务数量。
返回 (队列任务数量)

.子程序 取_线程池容量, 整数型, , 创建时候的容量。
返回 (任务站数量)

.子程序 取_是否空闲, 逻辑型, , 线程池处于彻底空闲状态，没有任何任务在执行。
返回 (并且 (等于 (队列任务数量, 0), 等于 (执行任务数量, 0)))

.子程序 取_状态, 整数型, , 0=未启动，1=正在工作，2=正在创建，3=正在销毁。
返回 (工作状态)

.子程序 置_线程空闲自销毁超时值, 空白型, , （此命令适用于线程池已经创建的状态下）设置线程空闲收回（销毁）时间。 （注意：低于100ms会被自动调整） 
.参数 参数_线程空闲自销毁超时值, 整数型, , 如果任务过少持续一定时间后线程会被自动收回（销毁）。单位：毫秒。 留空为 5000ms (5秒).。 （注意：空闲收回超时最低100ms 毫秒）

.判断开始 (小于 (参数_线程空闲自销毁超时值, 100))
    赋值 (自销毁超时值, 100)
.默认
    赋值 (自销毁超时值, 参数_线程空闲自销毁超时值)
.判断结束




 ' 不属于任何一个程序集、类模块的函数：
