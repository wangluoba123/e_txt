 ' 文件类型：Windows模块源码

 ' 程序名称：中文汇编模块
 ' 程序描述：
 ' 程序作者：徐李
 ' 邮政编码：210005
 ' 联系地址：南京市
 ' 联系电话：025
 ' 传真号码：
 ' 电子信箱：x12143@sohu.com
 ' 主页地址：
 ' 版权声明：
 ' 版本号：1.1
 ' 创建号：0.0

窗口 窗口1
    左边 = 50
    顶边 = 50
    宽度 = 941
    高度 = 620
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 真
    禁止 = 假
    边框 = 2
    底图方式 = 1
    底色 = -16777216 '  0xFF000000
    最大化按钮 = 假
    最小化按钮 = 假
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “测试窗口”
    帮助文件名 = “”



.常量 reg8文本, "“al,cl,dl,bl,ah,ch,dh,bh”", , 
.常量 reg16文本, "“ax,cx,dx,bx,sp,bp,si,di”", , 
.常量 reg32文本, "“eax,ecx,edx,ebx,esp,ebp,esi,edi”", , 
.常量 sreg文本, "“cs代码段,ds数据段,ss堆栈段,es段,fs段,gs段,,”", , 
.常量 s文本, "“,×2,×4,×8”", , 
.常量 , , , 
.常量 modrm文本_00_16, "“[bx+si],[bx+di],[bp+si],[bp+di],[si],[di],[d16],[bx]”", , 
.常量 m00段前缀_16, "“ds数据段,ds数据段,ss堆栈段,ss堆栈段,ds数据段,ds数据段,ds数据段,ds数据段”", , 
.常量 modrm文本_01_16, "“[bx+si+d8],[bx+di+d8],[bp+si+d8],[bp+di+d8],[si+d8],[di+d8],[bp+d8],[bx+d8]”", , 
.常量 modrm文本_10_16, "“[bx+si+d16],[bx+di+d16],[bp+si+d16],[bp+di+d16],[si+d16],[di+d16],[bp+d16],[bx+d16]”", , 
.常量 m01段前缀_16, "“ds数据段,ds数据段,ss堆栈段,ss堆栈段,ds数据段,ds数据段,ss堆栈段,ds数据段”", , 
.常量 , , , 
.常量 modrm文本_00_32, "“[eax],[ecx],[edx],[ebx],sib,d32,[esi],[edi]”", , 
.常量 m00段前缀_32, "“ds数据段,ds数据段,ds数据段,ds数据段,ds数据段,ds数据段,ds数据段,ds数据段”", , 
.常量 modrm文本_01_32, "“[eax+d8],[ecx+d8],[edx+d8],[ebx+d8],sib,[ebp+d8],[esi+d8],[edi+d8]”", , 
.常量 modrm文本_10_32, "“[eax+d32],[ecx+d32],[edx+d32],[ebx+d32],sib,[ebp+d32],[esi+d32],[edi+d32]”", , 
.常量 m01段前缀_32, "“ds数据段,ds数据段,ds数据段,ds数据段,ss堆栈段,ss堆栈段,ds数据段,ds数据段”", , 
.常量 , , , 
.常量 byte, "“<字节>”", , 
.常量 word, "“<单字>”", , 
.常量 dword, "“<双字>”", , 
.常量 段前缀文本, "“cs代码段,ds数据段,ss堆栈段,es段,fs段,gs段”", , 
.常量 操作数尺寸文本, "“<字节>,<单字>,<双字>”", , 
.常量 , , , 
.常量 __cs, "“cs代码段”", , 
.常量 __ds, "“ds数据段”", , 
.常量 __ss, "“ss堆栈段”", , 
.常量 __es, "“es段”", , 
.常量 __fs, "“fs段”", , 
.常量 __gs, "“gs段”", , 
.常量 _段分隔符, "“:”", , 
.常量 , , , 
.常量 指令分隔符, "“, ”", , 
.常量 指令最大长度, "10", , 
.常量 _aaa, "“aaa       ”", , 
.常量 _aad, "“aad       ”", , 
.常量 _aam, "“aam       ”", , 
.常量 _aas, "“aas       ”", , 
.常量 _adc, "“adc       ”", , 
.常量 _add, "“add       ”", , 
.常量 _adrsiz, "“adrsiz:   ”", , 
.常量 _and, "“and       ”", , 
.常量 _arpl, "“arpl      ”", , 
.常量 _bound, "“bound     ”", , 
.常量 _bsf, "“bsf       ”", , 
.常量 _bsr, "“bsr       ”", , 
.常量 _bswap, "“bswap     ”", , 
.常量 _bt, "“bt        ”", , 
.常量 _btc, "“btc       ”", , 
.常量 _btr, "“btr       ”", , 
.常量 _bts, "“bts       ”", , 
.常量 _call, "“call      ”", , 
.常量 _cbw, "“cbw       ”", , 
.常量 _clc, "“clc       ”", , 
.常量 _cld, "“cld       ”", , 
.常量 _cli, "“cli       ”", , 
.常量 _clts, "“clts      ”", , 
.常量 _cmc, "“cmc       ”", , 
.常量 _cmp, "“cmp       ”", , 
.常量 _cmpsb, "“cmpsb     ”", , 
.常量 _cmpsw, "“cmpsw     ”", , 
.常量 _cmpxchg, "“cmpxchg   ”", , 
.常量 _cwd, "“cwd       ”", , 
.常量 _cwde, "“cwde      ”", , 
.常量 _daa, "“daa       ”", , 
.常量 _das, "“das       ”", , 
.常量 _dec, "“dec       ”", , 
.常量 _div, "“div       ”", , 
.常量 _enter, "“enter     ”", , 
.常量 _f2xm1, "“f2xm1     ”", , 
.常量 _fabs, "“fabs      ”", , 
.常量 _fadd, "“fadd      ”", , 
.常量 _faddp, "“faddp     ”", , 
.常量 _fbld, "“fbld      ”", , 
.常量 _fbstp, "“fbstp     ”", , 
.常量 _fchs, "“fchs      ”", , 
.常量 _fclex, "“fclex     ”", , 
.常量 _fcmovb, "“fcmovb    ”", , 
.常量 _fcmove, "“fcmove    ”", , 
.常量 _fcmovbe, "“fcmovbe   ”", , 
.常量 _fcmovu, "“fcmovu    ”", , 
.常量 _fcmovnb, "“fcmovnb   ”", , 
.常量 _fcmovne, "“fcmovne   ”", , 
.常量 _fcmovnbe, "“fcmovnbe  ”", , 
.常量 _fcmovnu, "“fcmovnu   ”", , 
.常量 _fcom, "“fcom      ”", , 
.常量 _fcomi, "“fcomi     ”", , 
.常量 _fcomip, "“fcomip    ”", , 
.常量 _fcomp, "“fcomp     ”", , 
.常量 _fcompp, "“fcompp    ”", , 
.常量 _fcos, "“fcos      ”", , 
.常量 _fdecstp, "“fdecstp   ”", , 
.常量 _fdiv, "“fdiv      ”", , 
.常量 _fdivp, "“fdivp     ”", , 
.常量 _fdivr, "“fdivr     ”", , 
.常量 _fdivrp, "“fdivrp    ”", , 
.常量 _ffree, "“ffree     ”", , 
.常量 _fiadd, "“fiadd     ”", , 
.常量 _ficom, "“ficom     ”", , 
.常量 _ficomp, "“ficomp    ”", , 
.常量 _fidiv, "“fidiv     ”", , 
.常量 _fidivr, "“fidivr    ”", , 
.常量 _fild, "“fild      ”", , 
.常量 _fimul, "“fimul     ”", , 
.常量 _fincstp, "“fincstp   ”", , 
.常量 _finit, "“finit     ”", , 
.常量 _fist, "“fist      ”", , 
.常量 _fistp, "“fistp     ”", , 
.常量 _fisttp, "“fisttp    ”", , 
.常量 _fisub, "“fisub     ”", , 
.常量 _fisubr, "“fisubr    ”", , 
.常量 _fld, "“fld       ”", , 
.常量 _fld1, "“fld1      ”", , 
.常量 _fldcw, "“fldcw     ”", , 
.常量 _fldenv, "“fldenv    ”", , 
.常量 _fldl2e, "“fldl2e    ”", , 
.常量 _fldl2t, "“fldl2t    ”", , 
.常量 _fldlg2, "“fldlg2    ”", , 
.常量 _fldln2, "“fldln2    ”", , 
.常量 _fldpi, "“fldpi     ”", , 
.常量 _fldz, "“fldz      ”", , 
.常量 _fmul, "“fmul      ”", , 
.常量 _fmulp, "“fmulp     ”", , 
.常量 _fnop, "“fnop      ”", , 
.常量 _fnclex, "“fnclex    ”", , 
.常量 _fninit, "“fninit    ”", , 
.常量 _fnsave, "“fnsave    ”", , 
.常量 _fnstcw, "“fnstcw    ”", , 
.常量 _fpatan, "“fpatan    ”", , 
.常量 _fprem, "“fprem     ”", , 
.常量 _fprem1, "“fprem1    ”", , 
.常量 _fptan, "“fptan     ”", , 
.常量 _frndint, "“frndint   ”", , 
.常量 _frstor, "“frstor    ”", , 
.常量 _fsave, "“fsave     ”", , 
.常量 _fscale, "“fscale    ”", , 
.常量 _fsin, "“fsin      ”", , 
.常量 _fsincos, "“fsincos   ”", , 
.常量 _fsqrt, "“fsqrt     ”", , 
.常量 _fst, "“fst       ”", , 
.常量 _fstenv, "“fstenv    ”", , 
.常量 _fstp, "“fstp      ”", , 
.常量 _fstcw, "“fstcw     ”", , 
.常量 _fsub, "“fsub      ”", , 
.常量 _fsubp, "“fsubp     ”", , 
.常量 _fsubr, "“fsubr     ”", , 
.常量 _fsubrp, "“fsubrp    ”", , 
.常量 _ftst, "“ftst      ”", , 
.常量 _fucom, "“fucom     ”", , 
.常量 _fucomi, "“fucomi    ”", , 
.常量 _fucomip, "“fucomip   ”", , 
.常量 _fucomp, "“fucomp    ”", , 
.常量 _fucompp, "“fcompp    ”", , 
.常量 _fxam, "“fxam      ”", , 
.常量 _fxch, "“fxch      ”", , 
.常量 _fxtract, "“fxtract   ”", , 
.常量 _fyl2x, "“fyl2x     ”", , 
.常量 _fyl2xp1, "“fyl2xp1   ”", , 
.常量 _hlt, "“hlt       ”", , 
.常量 _idiv, "“idiv      ”", , 
.常量 _imul, "“imul      ”", , 
.常量 _in, "“in        ”", , 
.常量 _inc, "“inc       ”", , 
.常量 _insb, "“insb      ”", , 
.常量 _insw, "“insw      ”", , 
.常量 _int, "“int       ”", , 
.常量 _int3, "“int3      ”", , 
.常量 _into, "“into      ”", , 
.常量 _invd, "“invd      ”", , 
.常量 _invlpg, "“invlpg    ”", , 
.常量 _iret, "“iret      ”", , 
.常量 _ja, "“ja        ”", , 
.常量 _jae, "“jae       ”", , 
.常量 _jb, "“jb        ”", , 
.常量 _jbe, "“jbe       ”", , 
.常量 _jcxz, "“jcxz      ”", , 
.常量 _je, "“je        ”", , 
.常量 _jg, "“jg        ”", , 
.常量 _jge, "“jge       ”", , 
.常量 _jl, "“jl        ”", , 
.常量 _jle, "“jle       ”", , 
.常量 _jmp, "“jmp       ”", , 
.常量 _jna, "“jna       ”", , 
.常量 _jnae, "“jnae      ”", , 
.常量 _jnb, "“jnb       ”", , 
.常量 _jnbe, "“jnbe      ”", , 
.常量 _jne, "“jne       ”", , 
.常量 _jng, "“jng       ”", , 
.常量 _jnge, "“jnge      ”", , 
.常量 _jnl, "“jnl       ”", , 
.常量 _jnle, "“jnle      ”", , 
.常量 _jno, "“jno       ”", , 
.常量 _jnp, "“jnp       ”", , 
.常量 _jns, "“jns       ”", , 
.常量 _jnz, "“jnz       ”", , 
.常量 _jo, "“jo        ”", , 
.常量 _jp, "“jp        ”", , 
.常量 _jpe, "“jpe       ”", , 
.常量 _js, "“js        ”", , 
.常量 _jz, "“jz        ”", , 
.常量 _lahf, "“lahf      ”", , 
.常量 _lar, "“lar       ”", , 
.常量 _lds, "“lds       ”", , 
.常量 _lea, "“lea       ”", , 
.常量 _leave, "“leave     ”", , 
.常量 _les, "“les       ”", , 
.常量 _lfs, "“lfs       ”", , 
.常量 _lgdt, "“lgdt      ”", , 
.常量 _lgs, "“lgs       ”", , 
.常量 _lidt, "“lidt      ”", , 
.常量 _lldt, "“lldt      ”", , 
.常量 _lmsw, "“lmsw      ”", , 
.常量 _lock, "“lock      ”", , 
.常量 _lodsb, "“lodsb     ”", , 
.常量 _lodsw, "“lodsw     ”", , 
.常量 _loop, "“loop      ”", , 
.常量 _loope, "“loope     ”", , 
.常量 _loopne, "“loopne    ”", , 
.常量 _loopnz, "“loopnz    ”", , 
.常量 _loopz, "“loopz     ”", , 
.常量 _lsl, "“lsl       ”", , 
.常量 _lss, "“lss       ”", , 
.常量 _ltr, "“ltr       ”", , 
.常量 _mov, "“mov       ”", , 
.常量 _movsb, "“movsb     ”", , 
.常量 _movsw, "“movsw     ”", , 
.常量 _movsx, "“movsx     ”", , 
.常量 _movzx, "“movzx     ”", , 
.常量 _mul, "“mul       ”", , 
.常量 _neg, "“neg       ”", , 
.常量 _nop, "“nop       ;--无操作--”", , 
.常量 _not, "“not       ”", , 
.常量 _opsiz, "“opsiz:    ”", , 
.常量 _or, "“or        ”", , 
.常量 _out, "“out       ”", , 
.常量 _outsb, "“outsb     ”", , 
.常量 _outsw, "“outsw     ”", , 
.常量 _pop, "“pop       ”", , 
.常量 _popad, "“popad     ”", , 
.常量 _popfw, "“popfw     ”", , 
.常量 _push, "“push      ”", , 
.常量 _pushad, "“pushad    ”", , 
.常量 _pushfw, "“pushfw    ”", , 
.常量 _rcl, "“rcl       ”", , 
.常量 _rcr, "“rcr       ”", , 
.常量 _rep, "“rep       ”", , 
.常量 _repe, "“repe      ”", , 
.常量 _repne, "“repne     ”", , 
.常量 _repnz, "“repnz     ”", , 
.常量 _repz, "“repz      ”", , 
.常量 _ret, "“ret       ”", , 
.常量 _retf, "“retf      ”", , 
.常量 _rol, "“rol       ”", , 
.常量 _ror, "“ror       ”", , 
.常量 _sahf, "“sahf      ”", , 
.常量 _sal, "“sal       ”", , 
.常量 _sar, "“sar       ”", , 
.常量 _sbb, "“sbb       ”", , 
.常量 _scasb, "“scasb     ”", , 
.常量 _scasw, "“scasw     ”", , 
.常量 _seta, "“seta      ”", , 
.常量 _setae, "“setae     ”", , 
.常量 _setb, "“setb      ”", , 
.常量 _setbe, "“setbe     ”", , 
.常量 _setc, "“setc      ”", , 
.常量 _sete, "“sete      ”", , 
.常量 _setg, "“setg      ”", , 
.常量 _setge, "“setge     ”", , 
.常量 _setl, "“setl      ”", , 
.常量 _setle, "“setle     ”", , 
.常量 _setna, "“setna     ”", , 
.常量 _setnae, "“setnae    ”", , 
.常量 _setnb, "“setnb     ”", , 
.常量 _setnbe, "“setnbe    ”", , 
.常量 _setnc, "“setnc     ”", , 
.常量 _setne, "“setne     ”", , 
.常量 _setng, "“setng     ”", , 
.常量 _setnge, "“setnge    ”", , 
.常量 _setnl, "“setnl     ”", , 
.常量 _setnle, "“setnle    ”", , 
.常量 _setno, "“setno     ”", , 
.常量 _setnp, "“setnp     ”", , 
.常量 _setns, "“setns     ”", , 
.常量 _setnz, "“setnz     ”", , 
.常量 _seto, "“seto      ”", , 
.常量 _setp, "“setp      ”", , 
.常量 _setpe, "“setpe     ”", , 
.常量 _setpo, "“setpo     ”", , 
.常量 _sets, "“sets      ”", , 
.常量 _setz, "“setz      ”", , 
.常量 _sgdt, "“sgdt      ”", , 
.常量 _shl, "“shl       ”", , 
.常量 _shld, "“shld      ”", , 
.常量 _shr, "“shr       ”", , 
.常量 _shrd, "“shrd      ”", , 
.常量 _sidt, "“sidt      ”", , 
.常量 _sldt, "“sldt      ”", , 
.常量 _smsw, "“smsw      ”", , 
.常量 _stc, "“stc       ”", , 
.常量 _std, "“std       ”", , 
.常量 _sti, "“sti       ”", , 
.常量 _stosb, "“stosb     ”", , 
.常量 _stosw, "“setosw    ”", , 
.常量 _str, "“str       ”", , 
.常量 _sub, "“sub       ”", , 
.常量 _test, "“test      ”", , 
.常量 _verr, "“verr      ”", , 
.常量 _verw, "“verw      ”", , 
.常量 _wait, "“wait      ”", , 
.常量 _wbinvd, "“wbinvd    ”", , 
.常量 _xadd, "“xadd      ”", , 
.常量 _xchg, "“xchg      ”", , 
.常量 _xlat, "“xlat      ”", , 
.常量 _xor, "“xor       ”", , 
.常量 , , , 
.常量 _参数分隔符, "“, ”", , 
.常量 _十六进制数据后缀, "“H”", , 
.常量 , , , 


 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 4 4 系统核心支持库
 ' spec A512548E76954B6E92C21055517615B0 2 1 特殊功能支持库




数据类型 程序指令代码数据类型1, 公开, 
    .成员 指令文本, 文本型, , , 不含注释的全指令文本
    .成员 注释文本, 文本型, , , 
    .成员 指令代码集, 字节集, , , 全指令代码字节集
    .成员 行属性, 整数型, , , 
    .成员 本行代码长度, 整数型, , , 
    .成员 累计代码长度, 整数型, , , 

数据类型 指令数据类型1, 公开, 
    .成员 指令名, 文本型, , , 
    .成员 参数组, 文本型, , "1", 
    .成员 是否全尺寸参数, 字节型, , , 0为否1为是255为无定义
    .成员 符合指令的代码序号, 整数型, , , 

数据类型 资源数据类型1, 公开, 
    .成员 注释, 注释位置数据类型1, , "1", 
    .成员 标号, 标号位置数据类型1, , "1", 
    .成员 变量, 变量位置数据类型1, , "1", 

数据类型 注释位置数据类型1, 公开, 
    .成员 位置行号, 整数型, , , 
    .成员 文本内容, 文本型, , , 

数据类型 标号位置数据类型1, 公开, 
    .成员 定义位置行号, 整数型, , , 
    .成员 名称, 文本型, , , 

数据类型 变量位置数据类型1, 公开, 
    .成员 定义位置从头偏移量, 整数型, , , 
    .成员 名称, 文本型, , , 
    .成员 类型, 字节型, , , 1字节,2字,4双字,最高为1时为文本长度
    .成员 内容, 字节集, , , 

.全局变量 代码转指令, 代码转指令类16, 公开, , 
.全局变量 寻址判断, 寻址判断类, 公开, , 

.程序集 程序集1, , , 

.子程序 _启动子程序, 整数型, , 请在本子程序中放置易模块初始化代码

_临时子程序 () ' 在初始化代码执行完毕后调用测试代码
返回 (0) ' 可以根据您的需要返回任意数值

.子程序 _临时子程序, 空白型, , 
 ' 本名称子程序用作测试程序用，仅在开发及调试环境中有效，编译发布程序前将被系统自动清空，请将所有用作测试的临时代码放在本子程序中。 ***注意不要修改本子程序的名称、参数及返回值类型。
测试 ()


.子程序 测试, 空白型, 公开, 
载入 (窗口1, , 真)


.程序集 工具类程序集, , , 

.程序集变量 十六进制字节文本组, 文本型, , "256", 
.子程序 十六进制字节文本组初使, 空白型, , 
.局部变量 i, 整数型, , , 

.计次循环首 (256, i)
    赋值 (十六进制字节文本组 [i], 取十六进制文本 (相减 (i, 1)))
    .如果真 (等于 (取文本长度 (十六进制字节文本组 [i]), 1))
        赋值 (十六进制字节文本组 [i], 相加 (“0”, 十六进制字节文本组 [i]))
    .如果真结束
    赋值 (十六进制字节文本组 [i], 取文本右边 (十六进制字节文本组 [i], 2))
.计次循环尾 ()


.子程序 字节集到十六进制文本, 文本型, , 以空格分隔
.参数 输入字节集, 字节集, , 
.参数 每行长度, 整数型, 可空, 

.局部变量 循环计次, 整数型, , , 
.局部变量 x, 字节型, , , 
.局部变量 i, 整数型, , , 
.局部变量 j, 整数型, , , 
.局部变量 返回文本, 文本型, , , 
.局部变量 y, 文本型, , , 

.如果真 (是否为空 (每行长度))
    赋值 (每行长度, 0)
.如果真结束
赋值 (i, 1)
赋值 (j, 0)
.计次循环首 (取字节集长度 (输入字节集), 循环计次)
    赋值 (x, 取字节集数据 (输入字节集, 1, i))
    赋值 (y, 到小写 (取十六进制文本 (x)))
    .如果真 (等于 (取文本长度 (y), 1))
        赋值 (y, 相加 (“0”, y))
    .如果真结束
    赋值 (返回文本, 相加 (返回文本, y, “ ”))
    .如果真 (不等于 (每行长度, 0))
        赋值 (j, 相加 (j, 1))
        .如果真 (大于或等于 (j, 每行长度))
            赋值 (返回文本, 相加 (返回文本, #换行符))
            赋值 (j, 0)
        .如果真结束
        
    .如果真结束
    
.计次循环尾 ()
返回 (返回文本)


.子程序 字节到十六进制文本, 文本型, , 
.参数 输入字节集, 字节集, , 
.参数 长度, 字节型, 可空, 

.局部变量 返回文本, 文本型, , , 
.局部变量 i, 整数型, , , 

赋值 (i, 1)
.如果真 (或者 (是否为空 (长度), 小于 (长度, 1)))
    赋值 (长度, 1)
.如果真结束
.计次循环首 (长度, )
    赋值 (返回文本, 相加 (返回文本, 十六进制字节文本组 [相加 (取字节集数据 (输入字节集, 1, i), 1)], “ ”))
.计次循环尾 ()
返回 (相加 (返回文本, #换行符))


.子程序 十六进制文本到字节集, 字节集, , 以空格分隔
.参数 输入文本, 文本型, , 

.局部变量 返回字节集, 字节集, , , 
.局部变量 文本组, 文本型, , "0", 
.局部变量 i, 整数型, , , 
.局部变量 x, 文本型, , , 
.局部变量 a, 字节型, , , 

.如果真 (等于 (输入文本, “”))
    返回 (返回字节集)
.如果真结束
赋值 (文本组, 分割文本 (输入文本, “ ”, ))
.计次循环首 (取数组成员数 (文本组), i)
    .如果真 (不等于 (取文本长度 (文本组 [i]), 2))
        返回 (返回字节集)
    .如果真结束
    赋值 (x, 到小写 (取文本左边 (文本组 [i], 1)))
    .判断开始 (并且 (大于或等于 (x, “0”), 小于或等于 (x, “9”)))
        赋值 (a, 相减 (取代码 (x, ), 取代码 (“0”, )))
    .判断 (并且 (大于或等于 (x, “a”), 小于或等于 (x, “f”)))
        赋值 (a, 相加 (相减 (取代码 (x, ), 取代码 (“a”, )), 10))
    .默认
        返回 (到字节集 (0))
    .判断结束
    赋值 (x, 到小写 (取文本右边 (文本组 [i], 1)))
    赋值 (a, 相乘 (a, 16))
    .判断开始 (并且 (大于或等于 (x, “0”), 小于或等于 (x, “9”)))
        赋值 (a, 相加 (a, 相减 (取代码 (x, ), 取代码 (“0”, ))))
    .判断 (并且 (大于或等于 (x, “a”), 小于或等于 (x, “f”)))
        赋值 (a, 相加 (a, 相加 (相减 (取代码 (x, ), 取代码 (“a”, )), 10)))
    .默认
        返回 (到字节集 (0))
    .判断结束
    赋值 (返回字节集, 相加 (返回字节集, 到字节集 (a)))
.计次循环尾 ()
返回 (返回字节集)


.子程序 数值文本到字节集, 字节集, , 含16进制文本,16进制文本以"h"结尾,如果错误则返回空字节集,八进制后缀为"x",二进制后缀为"a"
.参数 输入文本, 文本型, , 

.局部变量 空字节集, 字节集, , , 
.局部变量 返回字节集, 字节集, , , 
.局部变量 后缀文本, 文本型, , , 
.局部变量 文本长度, 整数型, , , 
.局部变量 a1, 字节型, , , 0
.局部变量 a2, 字节型, , , 9
.局部变量 a3, 字节型, , , a
.局部变量 a4, 字节型, , , f
.局部变量 b1, 字节型, , , 8
.局部变量 b2, 字节型, , , 1
.局部变量 i, 整数型, , , 
.局部变量 x, 字节型, , , 
.局部变量 返回数, 整数型, , , 最大为四个字节
.局部变量 负数, 逻辑型, , , 

赋值 (文本长度, 取文本长度 (输入文本))
.如果真 (等于 (文本长度, 0))
    返回 (空字节集)
.如果真结束
赋值 (负数, 假)
.如果真 (等于 (取文本左边 (输入文本, 1), “-”))
    赋值 (负数, 真)
    赋值 (文本长度, 相减 (文本长度, 1))
    赋值 (输入文本, 取文本右边 (输入文本, 文本长度))
.如果真结束
赋值 (后缀文本, 取文本右边 (输入文本, 1))
赋值 (返回数, 0)
.判断开始 (等于 (后缀文本, “h”)) ' 是否16进制
    赋值 (a1, 取代码 (“0”, ))
    赋值 (a2, 取代码 (“9”, ))
    赋值 (a3, 取代码 (“a”, ))
    赋值 (a4, 取代码 (“f”, ))
    赋值 (文本长度, 相减 (文本长度, 1))
    赋值 (输入文本, 取文本左边 (输入文本, 文本长度))
    .如果真 (等于 (文本长度, 0))
        返回 (空字节集)
    .如果真结束
    .计次循环首 (文本长度, i)
        赋值 (返回数, 相乘 (返回数, 16))
        赋值 (x, 取代码 (输入文本, i))
        .判断开始 (并且 (大于或等于 (x, a1), 小于或等于 (x, a2))) ' 0~9之间
            赋值 (返回数, 相减 (相加 (返回数, x), a1))
        .判断 (并且 (大于或等于 (x, a3), 小于或等于 (x, a4))) ' a~f之间
            赋值 (返回数, 相减 (相加 (返回数, 10, x), a3))
        .默认
            返回 (空字节集)
        .判断结束
        
    .计次循环尾 ()
    .判断开始 (小于或等于 (返回数, 255))
        .如果 (负数)
            赋值 (返回字节集, 到字节集 (到字节 (相减 (0, 返回数))))
        .否则
            赋值 (返回字节集, 到字节集 (到字节 (返回数)))
        .如果结束
        
    .判断 (小于或等于 (返回数, 65535))
        .如果 (负数)
            赋值 (返回字节集, 到字节集 (到短整数 (相减 (0, 返回数))))
        .否则
            赋值 (返回字节集, 到字节集 (到短整数 (返回数)))
        .如果结束
        
    .默认
        .如果 (负数)
            赋值 (返回字节集, 到字节集 (相减 (0, 返回数)))
        .否则
            赋值 (返回字节集, 到字节集 (返回数))
        .如果结束
        
    .判断结束
    返回 (返回字节集)
.判断 (等于 (后缀文本, “x”)) ' 是否8进制
    
.判断 (等于 (后缀文本, “a”)) ' 是否2进制
    
.默认
     ' 为十进制
    赋值 (a1, 取代码 (“0”, ))
    赋值 (a2, 取代码 (“9”, ))
    .计次循环首 (文本长度, i)
        赋值 (x, 取代码 (输入文本, i))
        .如果真 (或者 (小于 (x, a1), 大于 (x, a2)))
            返回 (空字节集)
        .如果真结束
        
    .计次循环尾 ()
    赋值 (返回数, 到整数 (输入文本))
    .判断开始 (小于或等于 (返回数, 255))
        .如果 (负数)
            赋值 (返回字节集, 到字节集 (到字节 (相减 (0, 返回数))))
        .否则
            赋值 (返回字节集, 到字节集 (到字节 (返回数)))
        .如果结束
        
    .判断 (小于或等于 (返回数, 65535))
        .如果 (负数)
            赋值 (返回字节集, 到字节集 (到短整数 (相减 (0, 返回数))))
        .否则
            赋值 (返回字节集, 到字节集 (到短整数 (返回数)))
        .如果结束
        
    .默认
        .如果 (负数)
            赋值 (返回字节集, 到字节集 (相减 (0, 返回数)))
        .否则
            赋值 (返回字节集, 到字节集 (返回数))
        .如果结束
        
    .判断结束
    返回 (返回字节集)
.判断结束
返回 (空字节集)


.子程序 调整字节集长度, 字节集, , 如果超过则返回空字节集
.参数 输入字节集, 字节集, , 
.参数 长度, 整数型, , 

.局部变量 l, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 z, 字节集, , , 
.局部变量 空字节集, 字节集, , , 

赋值 (z, 到字节集 (到字节 (0)))
赋值 (l, 取字节集长度 (输入字节集))
.判断开始 (小于 (l, 长度))
    赋值 (l, 相减 (长度, l))
    .计次循环首 (l, i)
        赋值 (输入字节集, 相加 (输入字节集, z))
    .计次循环尾 ()
.判断 (大于 (l, 长度))
    返回 (空字节集)
.默认
    
.判断结束
返回 (输入字节集)

.子程序 调整文本长度_增加, 文本型, , 输入文本超过指令长度,返回原文本
.参数 输入文本, 文本型, , 
.参数 调整长度, 整数型, , 
.参数 插入文本, 文本型, 可空, 
.参数 是否前面, 逻辑型, 可空, 

.局部变量 l, 整数型, , , 
.局部变量 返回文本, 文本型, , , 

赋值 (l, 取文本长度 (输入文本))
.如果真 (小于或等于 (调整长度, l))
    返回 (输入文本)
.如果真结束
.如果真 (是否为空 (是否前面))
    赋值 (是否前面, 假)
.如果真结束
.如果真 (是否为空 (插入文本))
    赋值 (插入文本, “ ”)
.如果真结束
赋值 (返回文本, 输入文本)
.计次循环首 (相减 (调整长度, l), )
    .如果 (是否前面)
        赋值 (返回文本, 相加 (插入文本, 返回文本))
    .否则
        赋值 (返回文本, 相加 (返回文本, 插入文本))
    .如果结束
    
.计次循环尾 ()
返回 (返回文本)

.子程序 整理文本_16进制, 文本型, , 将文本中多余的空格、回车、TAB去换，每个字节之间用空格分隔，但无法识别
.参数 输入文本, 文本型, , 

.局部变量 文本信息, 文本型, , , 
.局部变量 返回文本, 文本型, , , 
.局部变量 i, 整数型, , , 
.局部变量 空格重复, 逻辑型, , , 
.局部变量 取出文本, 文本型, , , 

赋值 (文本信息, 子文本替换 (输入文本, 字符 (9), “ ”, 1, , 真))
赋值 (文本信息, 子文本替换 (文本信息, 相加 (字符 (13), 字符 (10)), “ ”, 1, , 真))
赋值 (空格重复, 假)
.计次循环首 (取文本长度 (文本信息), i)
    赋值 (取出文本, 取文本中间 (文本信息, i, 1))
    .如果真 (等于 (取出文本, “ ”))
        .如果 (空格重复)
            到循环尾 ()
        .否则
            赋值 (空格重复, 真)
            赋值 (返回文本, 相加 (返回文本, 取出文本))
            到循环尾 ()
        .如果结束
        
    .如果真结束
    赋值 (空格重复, 假)
    赋值 (返回文本, 相加 (返回文本, 取出文本))
.计次循环尾 ()
返回 (返回文本)


.子程序 插入文本, 文本型, , 
.参数 原文本, 文本型, , 
.参数 插入位置, 整数型, , 
.参数 插入的文本, 文本型, , 
.参数 输入次数, 整数型, , 

.局部变量 前面文本, 文本型, , , 
.局部变量 后面文本, 文本型, , , 

赋值 (前面文本, 取文本左边 (原文本, 相减 (插入位置, 1)))
赋值 (后面文本, 取文本右边 (原文本, 相加 (相减 (取文本长度 (原文本), 插入位置), 1)))
.计次循环首 (输入次数, )
    赋值 (前面文本, 相加 (前面文本, 插入的文本))
.计次循环尾 ()
返回 (相加 (前面文本, 后面文本))


.类模块 指令维护类, , , 

.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.类模块 指令转代码类, , , 

.程序集变量 _指令文本组, 文本型, , "573", 
.程序集变量 匿名程序集变量_3161, 空白型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
初使化数据_指令文本组 ()


.子程序 初使化数据_指令文本组, 空白型, , 
 ' 数据结构
 ' 第一指令代码,第二指令代码,第一代码参数,第二代码参数,全尺寸标志,指令,第一指令参数,第二指令参数,第三指令参数,
赋值 (_指令文本组 [1], “0,,ea0,,,add,eb,reg8,,”)
赋值 (_指令文本组 [2], “1,,ea0,,*,add,ew,reg16,,”)
赋值 (_指令文本组 [3], “2,,ea0,,,add,reg8,eb,,”)
赋值 (_指令文本组 [4], “3,,ea0,,*,add,reg16,ed,,”)
赋值 (_指令文本组 [5], “4,,data8,,,add,al,data8,,”)
赋值 (_指令文本组 [6], “5,,data16,,*,add,ax,data16,,”)
赋值 (_指令文本组 [7], “6,,,,*,push,es,,,”)
赋值 (_指令文本组 [8], “7,,,,*,pop,es,,,”)
赋值 (_指令文本组 [9], “8,,ea0,,,or,eb,reg8,,”)
赋值 (_指令文本组 [10], “9,,ea0,,*,or,ew,reg16,,”)
赋值 (_指令文本组 [11], “10,,ea0,,,adc,eb,reg8,,”)
赋值 (_指令文本组 [12], “11,,ea0,,*,adc,ew,reg16,,”)
赋值 (_指令文本组 [13], “12,,ea0,,,adc,reg8,eb,,”)
赋值 (_指令文本组 [14], “13,,ea0,,*,adc,reg16,ed,,”)
赋值 (_指令文本组 [15], “14,,data8,,,adc,al,data8,,”)
赋值 (_指令文本组 [16], “15,,data16,,*,adc,ax,data16”)
赋值 (_指令文本组 [17], “16,,,,*,push,ss,”)
赋值 (_指令文本组 [18], “16,,ea0,,,xor,reg8,eb”)
赋值 (_指令文本组 [19], “17,,,,*,pop,ss,”)
赋值 (_指令文本组 [20], “18,,ea0,,,sbb,eb,reg8”)
赋值 (_指令文本组 [21], “19,,ea0,,*,sbb,ew,reg16”)
赋值 (_指令文本组 [22], “20,,ea0,,,and,eb,reg8”)
赋值 (_指令文本组 [23], “21,,ea0,,*,and,ew,reg16”)
赋值 (_指令文本组 [24], “22,,ea0,,,and,reg8,eb”)
赋值 (_指令文本组 [25], “23,,ea0,,*,and,reg16,ed”)
赋值 (_指令文本组 [26], “24,,data8,,,and,al,data8”)
赋值 (_指令文本组 [27], “25,,data16,,*,and,ax,data16”)
赋值 (_指令文本组 [28], “26,,,,,es:,,”)
赋值 (_指令文本组 [29], “27,,,,,daa,,”)
赋值 (_指令文本组 [30], “28,,ea0,,,sub,eb,reg8”)
赋值 (_指令文本组 [31], “29,,ea0,,*,sub,ew,reg16”)
赋值 (_指令文本组 [32], “30,,ea0,,,xor,eb,reg8”)
赋值 (_指令文本组 [33], “31,,ea0,,*,xor,ew,reg16”)
赋值 (_指令文本组 [34], “33,,ea0,,*,xor,reg16,ed”)
赋值 (_指令文本组 [35], “34,,data8,,,xor,al,data8”)
赋值 (_指令文本组 [36], “35,,data16,,,xor,ax,data16”)
赋值 (_指令文本组 [37], “36,,,,,ss:,,”)
赋值 (_指令文本组 [38], “37,,,,,aaa,,”)
赋值 (_指令文本组 [39], “38,,ea0,,,cmp,ew,reg8”)
赋值 (_指令文本组 [40], “39,,ea0,,*,cmp,ew,reg16”)
赋值 (_指令文本组 [41], “40,,,,*,inc,ax,”)
赋值 (_指令文本组 [42], “41,,,,*,inc,cx,”)
赋值 (_指令文本组 [43], “42,,,,*,inc,dx,”)
赋值 (_指令文本组 [44], “43,,,,*,inc,bx,”)
赋值 (_指令文本组 [45], “44,,,,*,inc,sp,”)
赋值 (_指令文本组 [46], “45,,,,*,inc,bp,”)
赋值 (_指令文本组 [47], “46,,,,*,inc,si,”)
赋值 (_指令文本组 [48], “47,,,,*,inc,di,”)
赋值 (_指令文本组 [49], “48,,,,*,dec,ax,”)
赋值 (_指令文本组 [50], “49,,,,*,dec,cx,”)
赋值 (_指令文本组 [51], “50,,,,*,push,ax,”)
赋值 (_指令文本组 [52], “51,,,,*,push,cx,”)
赋值 (_指令文本组 [53], “52,,,,*,push,dx,”)
赋值 (_指令文本组 [54], “53,,,,*,push,bx,”)
赋值 (_指令文本组 [55], “54,,,,*,push,sp,”)
赋值 (_指令文本组 [56], “55,,,,*,push,bp,”)
赋值 (_指令文本组 [57], “56,,,,*,push,si,”)
赋值 (_指令文本组 [58], “57,,,,*,push,di,”)
赋值 (_指令文本组 [59], “58,,,,*,pop,ax,”)
赋值 (_指令文本组 [60], “59,,,,*,pop,cx,”)
赋值 (_指令文本组 [61], “60,,,,*,pushad,,”)
赋值 (_指令文本组 [62], “61,,,,*,popad,,”)
赋值 (_指令文本组 [63], “62,,ea0,,*,bound,reg16,ea”)
赋值 (_指令文本组 [64], “63,,ea0,,,arpl,ew,reg16”)
赋值 (_指令文本组 [65], “64,,,,,fs:,,”)
赋值 (_指令文本组 [66], “65,,,,,gs:,,”)
赋值 (_指令文本组 [67], “66,,,,,opsiz:,,”)
赋值 (_指令文本组 [68], “67,,,,,adrsiz:,,”)
赋值 (_指令文本组 [69], “68,,data16,,*,push,data16,”)
赋值 (_指令文本组 [70], “69,,ea0,data16,*,imulreg16,ew,data16”)
赋值 (_指令文本组 [71], “70,,disp8,,,jo,disp8,”)
赋值 (_指令文本组 [72], “71,,disp8,,,jno,disp8,”)
赋值 (_指令文本组 [73], “72,,disp8,,,jnae,disp8,”)
赋值 (_指令文本组 [74], “73,,disp8,,,jae,disp8,”)
赋值 (_指令文本组 [75], “73,,disp8,,,jnb,disp8,”)
赋值 (_指令文本组 [76], “74,,disp8,,,je,disp8,”)
赋值 (_指令文本组 [77], “74,,disp8,,,jz,disp8,”)
赋值 (_指令文本组 [78], “75,,disp8,,,jne,disp8,”)
赋值 (_指令文本组 [79], “75,,disp8,,,jnz,disp8,”)
赋值 (_指令文本组 [80], “76,,disp8,,,jbe,disp8,”)
赋值 (_指令文本组 [81], “76,,disp8,,,jna,disp8,”)
赋值 (_指令文本组 [82], “77,,disp8,,,ja,disp8,”)
赋值 (_指令文本组 [83], “77,,disp8,,,jnbe,disp8,”)
赋值 (_指令文本组 [84], “78,,disp8,,,js,disp8,”)
赋值 (_指令文本组 [85], “79,,disp8,,,jns,disp8,”)
赋值 (_指令文本组 [86], “80,,ea/0,data8,,add,eb,data8”)
赋值 (_指令文本组 [87], “80,,ea/1,data8,,or,eb,data8”)
赋值 (_指令文本组 [88], “80,,ea/2,data8,,adc,eb,data8”)
赋值 (_指令文本组 [89], “80,,ea/3,data8,,sbb,eb,data8”)
赋值 (_指令文本组 [90], “80,,ea/4,data8,,and,eb,data8”)
赋值 (_指令文本组 [91], “80,,ea/5,data8,,sub,eb,data8”)
赋值 (_指令文本组 [92], “80,,ea/6,data8,,xor,eb,data8”)
赋值 (_指令文本组 [93], “80,,ea/7,data8,,cmp,eb,data8”)
赋值 (_指令文本组 [94], “81,,ea/0,data16,*,add,ew,data16”)
赋值 (_指令文本组 [95], “81,,ea/1,data16,*,or,ew,data16”)
赋值 (_指令文本组 [96], “81,,ea/2,data16,*,adc,ew,data16”)
赋值 (_指令文本组 [97], “81,,ea/3,data16,*,sbb,ew,data16”)
赋值 (_指令文本组 [98], “81,,ea/4,data16,*,and,ew,data16”)
赋值 (_指令文本组 [99], “81,,ea/5,data16,*,sub,ew,data16”)
赋值 (_指令文本组 [100], “81,,ea/6,data16,*,xor,ew,data16”)
赋值 (_指令文本组 [101], “81,,ea/7,data16,*,cmp,ew,data16”)
赋值 (_指令文本组 [102], “83,,ea/0,data8,*,add,ew,data8”)
赋值 (_指令文本组 [103], “83,,ea/1,data8,*,or,ew,data8”)
赋值 (_指令文本组 [104], “83,,ea/2,data8,*,adc,ew,data8”)
赋值 (_指令文本组 [105], “83,,ea/2,data8,*,adc,ew,data8”)
赋值 (_指令文本组 [106], “83,,ea/3,data8,*,sbb,ew,data8”)
赋值 (_指令文本组 [107], “83,,ea/4,data8,*,and,ew,data8”)
赋值 (_指令文本组 [108], “83,,ea/5,data8,*,sub,ew,data8”)
赋值 (_指令文本组 [109], “83,,ea/6,data8,*,xor,ew,data8”)
赋值 (_指令文本组 [110], “83,,ea/7,data8,*,cmp,ew,data8”)
赋值 (_指令文本组 [111], “84,,ea0,,,test,eb,reg8”)
赋值 (_指令文本组 [112], “85,,ea0,,*,test,ew,reg16”)
赋值 (_指令文本组 [113], “86,,ea0,,,xchg,eb,reg8”)
赋值 (_指令文本组 [114], “87,,ea0,,*,xchg,ew,reg16”)
赋值 (_指令文本组 [115], “88,,ea0,,,mov,eb,reg8”)
赋值 (_指令文本组 [116], “89,,ea0,,*,mov,ew,reg16”)
赋值 (_指令文本组 [117], “90,,,,,nop,,”)
赋值 (_指令文本组 [118], “91,,,,*,xchg,ax,cx”)
赋值 (_指令文本组 [119], “92,,,,*,xchg,ax,dx”)
赋值 (_指令文本组 [120], “93,,,,*,xchg,ax,bx”)
赋值 (_指令文本组 [121], “94,,,,*,xchg,ax,sp”)
赋值 (_指令文本组 [122], “95,,,,*,xchg,ax,bp”)
赋值 (_指令文本组 [123], “96,,,,*,xchg,ax,si”)
赋值 (_指令文本组 [124], “97,,,,*,xchg,ax,di”)
赋值 (_指令文本组 [125], “98,,,,*,cbw,,”)
赋值 (_指令文本组 [126], “98,,,,*,cwde,,”)
赋值 (_指令文本组 [127], “99,,,,,cwd,,”)
赋值 (_指令文本组 [128], “0a,,ea0,,,or,reg8,eb”)
赋值 (_指令文本组 [129], “0b,,ea0,,*,or,reg16,ed”)
赋值 (_指令文本组 [130], “0c,,data8,,,or,al,data8”)
赋值 (_指令文本组 [131], “0d,,data16,,,or,ax,data16”)
赋值 (_指令文本组 [132], “0e,,,,*,push,cs,”)
赋值 (_指令文本组 [133], “0f,0,ea/0,,,sldt,ew,”)
赋值 (_指令文本组 [134], “0f,0,ea/1,,,str,ew,”)
赋值 (_指令文本组 [135], “0f,0,ea/2,,,lldt,ew,”)
赋值 (_指令文本组 [136], “0f,0,ea/3,,,ltr,ew,”)
赋值 (_指令文本组 [137], “0f,0,ea/4,,,verr,ew,”)
赋值 (_指令文本组 [138], “0f,0,ea/5,,,verw,ew,”)
赋值 (_指令文本组 [139], “0f,1,ea/0,,,sgdt,ea,”)
赋值 (_指令文本组 [140], “0f,1,ea/1,,,sidt,ea,”)
赋值 (_指令文本组 [141], “0f,1,ea/2,,,lgdt,ea,”)
赋值 (_指令文本组 [142], “0f,1,ea/3,,,lidt,ea,”)
赋值 (_指令文本组 [143], “0f,1,ea/4,,,smsw,ew,”)
赋值 (_指令文本组 [144], “0f,1,ea/6,,,lmsw,ew,”)
赋值 (_指令文本组 [145], “0f,2,ea0,,*,lar,reg16,ev”)
赋值 (_指令文本组 [146], “0f,3,ea0,,*,lsl,reg16,ev”)
赋值 (_指令文本组 [147], “0f,6,,,,clts,,”)
赋值 (_指令文本组 [148], “0f,8,,,,invd,,”)
赋值 (_指令文本组 [149], “0f,9,,,,wbinvd,,”)
赋值 (_指令文本组 [150], “0f,10,ea0,,,invlpg,ea,eb”)
赋值 (_指令文本组 [151], “0f,20,-/n/reg,,,mov,crn,reg16”)
赋值 (_指令文本组 [152], “0f,21,-/n/reg,,,mov,drn,reg16”)
赋值 (_指令文本组 [153], “0f,22,-/n/reg,,,mov,reg16,crn”)
赋值 (_指令文本组 [154], “0f,23,-/n/reg,,,mov,reg16,drn”)
赋值 (_指令文本组 [155], “0f,24,-/n/reg,,,mov,trn,reg16”)
赋值 (_指令文本组 [156], “0f,26,-/n/reg,,,mov,reg16,trn”)
赋值 (_指令文本组 [157], “0f,80,disp16,,*,jo,disp16,”)
赋值 (_指令文本组 [158], “0f,81,disp16,,*,jno,disp16,”)
赋值 (_指令文本组 [159], “0f,82,disp16,,*,jb,disp16,”)
赋值 (_指令文本组 [160], “0f,82,disp16,,*,jnae,disp16”)
赋值 (_指令文本组 [161], “0f,83,disp16,,*,jae,disp16”)
赋值 (_指令文本组 [162], “0f,83,disp16,,*,jnb,disp16”)
赋值 (_指令文本组 [163], “0f,84,disp16,,*,je,disp16”)
赋值 (_指令文本组 [164], “0f,84,disp16,,*,jz,disp16”)
赋值 (_指令文本组 [165], “0f,85,disp16,,*,jnz,disp16”)
赋值 (_指令文本组 [166], “0f,86,disp16,,*,jbe,disp16”)
赋值 (_指令文本组 [167], “0f,86,disp16,,*,jna,disp16”)
赋值 (_指令文本组 [168], “0f,87,disp16,,*,ja,disp16”)
赋值 (_指令文本组 [169], “0f,87,disp16,,*,jnbe,disp16”)
赋值 (_指令文本组 [170], “0f,88,disp16,,*,js,disp16”)
赋值 (_指令文本组 [171], “0f,89,disp16,,*,jns,disp16”)
赋值 (_指令文本组 [172], “0f,90,ea0,,*,seto,eb”)
赋值 (_指令文本组 [173], “0f,91,ea0,,,setno,eb”)
赋值 (_指令文本组 [174], “0f,92,ea0,,,setb,eb”)
赋值 (_指令文本组 [175], “0f,92,ea0,,,setc,eb”)
赋值 (_指令文本组 [176], “0f,92,ea0,,,setnae,eb”)
赋值 (_指令文本组 [177], “0f,93,ea0,,,setae,eb”)
赋值 (_指令文本组 [178], “0f,93,ea0,,,setnb,eb”)
赋值 (_指令文本组 [179], “0f,93,ea0,,,setnc,eb”)
赋值 (_指令文本组 [180], “0f,94,ea0,,,sete,eb”)
赋值 (_指令文本组 [181], “0f,94,ea0,,,setz,eb”)
赋值 (_指令文本组 [182], “0f,95,ea0,,,setne,eb”)
赋值 (_指令文本组 [183], “0f,95,ea0,,,setnz,eb”)
赋值 (_指令文本组 [184], “0f,96,ea0,,,setbe,eb”)
赋值 (_指令文本组 [185], “0f,96,ea0,,,setna,eb”)
赋值 (_指令文本组 [186], “0f,97,ea0,,,seta,eb”)
赋值 (_指令文本组 [187], “0f,97,ea0,,,setnbe,eb”)
赋值 (_指令文本组 [188], “0f,98,ea0,,,sets,eb”)
赋值 (_指令文本组 [189], “0f,99,ea0,,,setns,eb”)
赋值 (_指令文本组 [190], “0f,8a,disp16,,*,jp,disp16”)
赋值 (_指令文本组 [191], “0f,8a,disp16,,*,jpe,disp16”)
赋值 (_指令文本组 [192], “0f,8b,disp16,,*,jnp,disp16”)
赋值 (_指令文本组 [193], “0f,8b,disp16,,*,jpo,disp16”)
赋值 (_指令文本组 [194], “0f,8c,disp16,,*,jl,disp16”)
赋值 (_指令文本组 [195], “0f,8c,disp16,,*,jnge,disp16”)
赋值 (_指令文本组 [196], “0f,8d,disp16,,*,jge,disp16”)
赋值 (_指令文本组 [197], “0f,8d,disp16,,*,jnl,disp16”)
赋值 (_指令文本组 [198], “0f,8e,disp16,,*,jle,disp16”)
赋值 (_指令文本组 [199], “0f,8e,disp16,,*,jng,disp16”)
赋值 (_指令文本组 [200], “0f,8f,disp16,,*,jg,disp16”)
赋值 (_指令文本组 [201], “0f,8f,disp16,,*,jnle,disp16”)
赋值 (_指令文本组 [202], “0f,9a,ea0,,,setp,eb”)
赋值 (_指令文本组 [203], “0f,9a,ea0,,,setpe,eb”)
赋值 (_指令文本组 [204], “0f,9b,ea0,,,setnp,eb”)
赋值 (_指令文本组 [205], “0f,9b,ea0,,,setpo,eb”)
赋值 (_指令文本组 [206], “0f,9c,ea0,,,setl,eb”)
赋值 (_指令文本组 [207], “0f,9c,ea0,,,setnge,eb,,”)
赋值 (_指令文本组 [208], “0f,9d,ea0,,,setge,eb,,”)
赋值 (_指令文本组 [209], “0f,9d,ea0,,,setnl,eb,,”)
赋值 (_指令文本组 [210], “0f,9e,ea0,,,setle,eb,,”)
赋值 (_指令文本组 [211], “0f,9e,ea0,,,setng,eb,,”)
赋值 (_指令文本组 [212], “0f,9f,ea0,,,setg,eb,,”)
赋值 (_指令文本组 [213], “0f,9f,ea0,,,setnle,eb,,”)
赋值 (_指令文本组 [214], “0f,a0,,,*,push,fs,,”)
赋值 (_指令文本组 [215], “0f,a1,,,*,pop,fs,,”)
赋值 (_指令文本组 [216], “0f,a3,ea0,,*,bt,ew,reg16,”)
赋值 (_指令文本组 [217], “0f,a4,ea0,data8,*,shld,ew,reg16,data8”)
赋值 (_指令文本组 [218], “0f,a5,ea0,,*,shld,ew,reg16,cl”)
赋值 (_指令文本组 [219], “0f,a6,ea0,,,cmpxchg,eb,reg8,”)
赋值 (_指令文本组 [220], “0f,a7,ea0,,,cmpxchg,ew,reg16,”)
赋值 (_指令文本组 [221], “0f,a8,,,*,push,gs,,”)
赋值 (_指令文本组 [222], “0f,a9,,,*,pop,gs,,”)
赋值 (_指令文本组 [223], “0f,ab,ea0,,*,bts,ew,reg16,”)
赋值 (_指令文本组 [224], “0f,ac,ea0,data8,*,shrd,ew,reg16,data8”)
赋值 (_指令文本组 [225], “0f,ad,ea0,,*,shrd,ew,reg16,cl”)
赋值 (_指令文本组 [226], “0f,af,ea0,,*,imul,reg16,ed,”)
赋值 (_指令文本组 [227], “0f,b2,ea0,,*,lss,reg16,ea,”)
赋值 (_指令文本组 [228], “0f,b3,ea0,,*,btr,ew,reg16,”)
赋值 (_指令文本组 [229], “0f,b4,ea0,,*,lfs,reg16,ea,”)
赋值 (_指令文本组 [230], “0f,b5,ea0,,*,lgs,reg16,ea,”)
赋值 (_指令文本组 [231], “0f,b6,ea0,,*,movzx,reg16,eb,”)
赋值 (_指令文本组 [232], “0f,b7,ea0,,*,movzx,reg16,ew,”)
赋值 (_指令文本组 [233], “0f,ba,ea/4,data8,*,bt,ew,data8,”)
赋值 (_指令文本组 [234], “0f,ba,ea/5,data8,*,bts,ew,data8,”)
赋值 (_指令文本组 [235], “0f,ba,ea/6,data8,*,btr,ew,data8,”)
赋值 (_指令文本组 [236], “0f,ba,ea/7,data8,*,btc,ew,data8,”)
赋值 (_指令文本组 [237], “0f,bb,ea0,,*,btc,ew,reg16,”)
赋值 (_指令文本组 [238], “0f,bc,ea0,,*,bsf,reg16,ed,”)
赋值 (_指令文本组 [239], “0f,bd,ea0,,*,bsr,reg16,ed”)
赋值 (_指令文本组 [240], “0f,be,ea0,,*,movsx,reg16,eb”)
赋值 (_指令文本组 [241], “0f,bf,ea0,,*,movsx,reg16,ew”)
赋值 (_指令文本组 [242], “0f,c0,ea0,,,xadd,eb,reg8”)
赋值 (_指令文本组 [243], “0f,c1,ea0,,,xadd,eb,reg16”)
赋值 (_指令文本组 [244], “0f,c8,,,,bswap,ax,”)
赋值 (_指令文本组 [245], “0f,c9,,,,bswap,cx,”)
赋值 (_指令文本组 [246], “0f,ca,,,,bswap,dx,”)
赋值 (_指令文本组 [247], “0f,cb,,,,bswap,bx,”)
赋值 (_指令文本组 [248], “0f,cc,,,,bswap,sp,”)
赋值 (_指令文本组 [249], “0f,cd,,,,bswap,bp,”)
赋值 (_指令文本组 [250], “0f,ce,,,,bswap,si,”)
赋值 (_指令文本组 [251], “0f,cf,,,,bswap,di,”)
赋值 (_指令文本组 [252], “1a,,ea0,,,sbb,reg8,eb”)
赋值 (_指令文本组 [253], “1b,,ea0,,*,sbb,reg16,ed”)
赋值 (_指令文本组 [254], “1c,,data8,,,sbb,al,data8”)
赋值 (_指令文本组 [255], “1d,,data16,,*,sbb,ax,data16”)
赋值 (_指令文本组 [256], “1e,,,,*,push,ds,”)
赋值 (_指令文本组 [257], “1f,,,,*,pop,ds,”)
赋值 (_指令文本组 [258], “2a,,ea0,,,sub,reg8,eb”)
赋值 (_指令文本组 [259], “2b,,ea0,,*,sub,reg16,ed”)
赋值 (_指令文本组 [260], “2c,,data8,,,sub,al,data8”)
赋值 (_指令文本组 [261], “2d,,data16,,*,sub,ax,data16”)
赋值 (_指令文本组 [262], “2e,,,,,cs:,,”)
赋值 (_指令文本组 [263], “2f,,,,,das,,”)
赋值 (_指令文本组 [264], “3a,,ea0,,,cmp,reg8,eb”)
赋值 (_指令文本组 [265], “3b,,ea0,,*,cmp,reg16,ed”)
赋值 (_指令文本组 [266], “3c,,data8,,,cmp,al,data8”)
赋值 (_指令文本组 [267], “3d,,data16,,*,cmp,ax,data16”)
赋值 (_指令文本组 [268], “3e,,,,,ds:,,”)
赋值 (_指令文本组 [269], “3f,,,,,aas,,”)
赋值 (_指令文本组 [270], “4a,,,,*,dec,dx,”)
赋值 (_指令文本组 [271], “4b,,,,*,dec,bx,,”)
赋值 (_指令文本组 [272], “4c,,,,*,dec,sp,,”)
赋值 (_指令文本组 [273], “4d,,,,*,dec,bp,,”)
赋值 (_指令文本组 [274], “4e,,,,*,dec,si,,”)
赋值 (_指令文本组 [275], “4f,,,,*,dec,di,,”)
赋值 (_指令文本组 [276], “5a,,,,*,pop,bx,,”)
赋值 (_指令文本组 [277], “5b,,,,*,pop,dx,,”)
赋值 (_指令文本组 [278], “5c,,,,*,pop,sp,,”)
赋值 (_指令文本组 [279], “5d,,,,*,pop,bp,,”)
赋值 (_指令文本组 [280], “5e,,,,*,pop,si,,”)
赋值 (_指令文本组 [281], “5f,,,,*,pop,di,,”)
赋值 (_指令文本组 [282], “6a,,data8,,,push,data8,,”)
赋值 (_指令文本组 [283], “6b,,ea0,data8,*,imul,reg16,ed,data8”)
赋值 (_指令文本组 [284], “6c,,,,,insb,,,”)
赋值 (_指令文本组 [285], “6d,,,,*,insd,,,”)
赋值 (_指令文本组 [286], “6e,,,,,outsb,,,”)
赋值 (_指令文本组 [287], “6f,,,,*,outsd,,”)
赋值 (_指令文本组 [288], “7a,,disp8,,,jp,disp8,”)
赋值 (_指令文本组 [289], “7a,,disp8,,,jpe,disp8,”)
赋值 (_指令文本组 [290], “7b,,disp8,,,jnp,disp8,”)
赋值 (_指令文本组 [291], “7b,,disp8,,,jpo,disp8,”)
赋值 (_指令文本组 [292], “7c,,disp8,,,jl,disp8,”)
赋值 (_指令文本组 [293], “7c,,disp8,,,jnge,disp8,”)
赋值 (_指令文本组 [294], “7d,,disp8,,,jge,disp8,”)
赋值 (_指令文本组 [295], “7d,,disp8,,,jnl,disp8,”)
赋值 (_指令文本组 [296], “7e,,disp8,,,jle,disp8,”)
赋值 (_指令文本组 [297], “7e,,disp8,,,jng,disp8,”)
赋值 (_指令文本组 [298], “7f,,disp8,,,jg,disp8,”)
赋值 (_指令文本组 [299], “7f,,disp8,,,jnle,disp8,”)
赋值 (_指令文本组 [300], “8a,,ea0,,,mov,reg8,eb”)
赋值 (_指令文本组 [301], “8b,,ea0,,*,mov,reg16,ed”)
赋值 (_指令文本组 [302], “8c,,ea/s,,,mov,ew,sreg”)
赋值 (_指令文本组 [303], “8d,,ea0,,*,lea,reg16,ea”)
赋值 (_指令文本组 [304], “8e,,ea/s,,,mov,sreg,ew”)
赋值 (_指令文本组 [305], “8f,,ea0,,*,pop,ew,”)
赋值 (_指令文本组 [306], “9a,,offset32,,,call,offset32,”)
赋值 (_指令文本组 [307], “9b,,,,,wait,,”)
赋值 (_指令文本组 [308], “9c,,,,*,pushfd,,”)
赋值 (_指令文本组 [309], “9d,,,,*,popfd,,”)
赋值 (_指令文本组 [310], “9e,,,,,sahf,,”)
赋值 (_指令文本组 [311], “9f,,,,,lahf,,”)
赋值 (_指令文本组 [312], “a0,,data8,,,mov,al,[data8]”)
赋值 (_指令文本组 [313], “a1,,data16,,*,mov,ax,[data16]”)
赋值 (_指令文本组 [314], “a2,,data8,,,mov,[data8],al”)
赋值 (_指令文本组 [315], “a3,,data16,,*,mov,[data16],ax”)
赋值 (_指令文本组 [316], “a4,,,,,movsb,,”)
赋值 (_指令文本组 [317], “a5,,,,*,movsd,,”)
赋值 (_指令文本组 [318], “a6,,,,,cmpsb,,”)
赋值 (_指令文本组 [319], “a7,,,,*,cmpsd,,”)
赋值 (_指令文本组 [320], “a8,,data8,,,test,al,data8”)
赋值 (_指令文本组 [321], “a9,,data16,,*,test,ax,data16”)
赋值 (_指令文本组 [322], “aa,,,,,stosb,,”)
赋值 (_指令文本组 [323], “ab,,,,*,stosd,,”)
赋值 (_指令文本组 [324], “ac,,,,,lodsb,,”)
赋值 (_指令文本组 [325], “ad,,,,*,lodsd,,”)
赋值 (_指令文本组 [326], “ae,,,,,scasb,,”)
赋值 (_指令文本组 [327], “af,,,,*,scasd,,”)
赋值 (_指令文本组 [328], “b0,,data8,,,mov,al,data8”)
赋值 (_指令文本组 [329], “b1,,data8,,,mov,cl,data8”)
赋值 (_指令文本组 [330], “b2,,data8,,,mov,dl,data8”)
赋值 (_指令文本组 [331], “b3,,data8,,,mov,bl,data8”)
赋值 (_指令文本组 [332], “b4,,data8,,,mov,ah,data8”)
赋值 (_指令文本组 [333], “b5,,data8,,,mov,ch,data8”)
赋值 (_指令文本组 [334], “b6,,data8,,,mov,dh,data8”)
赋值 (_指令文本组 [335], “b7,,data8,,,mov,bh,data8”)
赋值 (_指令文本组 [336], “b8,,data16,,*,mov,ax,data16”)
赋值 (_指令文本组 [337], “b9,,data16,,*,mov,cx,data16”)
赋值 (_指令文本组 [338], “ba,,data16,,*,mov,dx,data16”)
赋值 (_指令文本组 [339], “bb,,data16,,*,mov,bx,data16”)
赋值 (_指令文本组 [340], “bc,,data16,,*,mov,sp,data16”)
赋值 (_指令文本组 [341], “bd,,data16,,*,mov,bp,data16”)
赋值 (_指令文本组 [342], “be,,data16,,*,mov,si,data16”)
赋值 (_指令文本组 [343], “bf,,data16,,*,mov,di,data16”)
赋值 (_指令文本组 [344], “c0,,ea/0,data8,,rol,eb,data8”)
赋值 (_指令文本组 [345], “c0,,ea/1,data8,,ror,eb,data8”)
赋值 (_指令文本组 [346], “c0,,ea/2,data8,,rcl,eb,data8”)
赋值 (_指令文本组 [347], “c0,,ea/3,data8,,rcr,eb,data8”)
赋值 (_指令文本组 [348], “c0,,ea/4,data8,,shl,eb,data8”)
赋值 (_指令文本组 [349], “c0,,ea/5,data8,,shr,eb,data8”)
赋值 (_指令文本组 [350], “c0,,ea/7,data8,,sar,eb,data8”)
赋值 (_指令文本组 [351], “c1,,ea/0,data8,*,rol,ew,data8”)
赋值 (_指令文本组 [352], “c1,,ea/1,data8,*,ror,ew,data8”)
赋值 (_指令文本组 [353], “c1,,ea/2,data8,*,rcl,ew,data8”)
赋值 (_指令文本组 [354], “c1,,ea/3,data8,*,rcr,ew,data8”)
赋值 (_指令文本组 [355], “c1,,ea/4,data8,*,shl,ew,data8”)
赋值 (_指令文本组 [356], “c1,,ea/5,data8,*,shr,ew,data8”)
赋值 (_指令文本组 [357], “c1,,ea/7,data8,*,sar,ew,data8”)
赋值 (_指令文本组 [358], “c2,,data16,,,ret,data16,”)
赋值 (_指令文本组 [359], “c3,,,,,ret,,”)
赋值 (_指令文本组 [360], “c4,,ea0,,*,les,reg16,ed”)
赋值 (_指令文本组 [361], “c5,,ea0,,*,lds,reg16,ed”)
赋值 (_指令文本组 [362], “c6,,ea/0,data8,,mov,eb,data8”)
赋值 (_指令文本组 [363], “c7,,ea/0,data16,*,mov,ew,data16”)
赋值 (_指令文本组 [364], “c8,,data16,data8,,enter,data16,data8”)
赋值 (_指令文本组 [365], “c9,,,,,leave,,”)
赋值 (_指令文本组 [366], “ca,,data16,,,retf,data16,”)
赋值 (_指令文本组 [367], “cb,,,,,retf,,”)
赋值 (_指令文本组 [368], “cc,,,,,int3,,”)
赋值 (_指令文本组 [369], “cd,,data8,,,int,data8,”)
赋值 (_指令文本组 [370], “ce,,,,,into,,”)
赋值 (_指令文本组 [371], “cf,,,,,iret,,”)
赋值 (_指令文本组 [372], “d0,,ea/0,,,rol,eb,1”)
赋值 (_指令文本组 [373], “d0,,ea/1,,,ror,eb,1”)
赋值 (_指令文本组 [374], “d0,,ea/2,,,rcl,eb,1”)
赋值 (_指令文本组 [375], “d0,,ea/3,,,rcr,eb,1”)
赋值 (_指令文本组 [376], “d0,,ea/4,,,shl,eb,1”)
赋值 (_指令文本组 [377], “d0,,ea/5,,,shr,eb,1”)
赋值 (_指令文本组 [378], “d0,,ea/5,,,shr,eb,1”)
赋值 (_指令文本组 [379], “d0,,ea/7,,,sar,eb,1”)
赋值 (_指令文本组 [380], “d1,,ea/0,,*,rol,ew,1”)
赋值 (_指令文本组 [381], “d1,,ea/1,,*,ror,ew,1”)
赋值 (_指令文本组 [382], “d1,,ea/2,,*,rcl,ew,1”)
赋值 (_指令文本组 [383], “d1,,ea/3,,*,rcr,ew,1”)
赋值 (_指令文本组 [384], “d1,,ea/4,,*,shl,ew,1”)
赋值 (_指令文本组 [385], “d1,,ea/5,,*,shr,ew,1”)
赋值 (_指令文本组 [386], “d1,,ea/7,,*,sar,ew,1”)
赋值 (_指令文本组 [387], “d2,,ea/0,,,rol,eb,cl”)
赋值 (_指令文本组 [388], “d2,,ea/1,,,ror,eb,cl”)
赋值 (_指令文本组 [389], “d2,,ea/2,,,rcl,eb,cl”)
赋值 (_指令文本组 [390], “d2,,ea/3,,,rcr,eb,cl”)
赋值 (_指令文本组 [391], “d2,,ea/4,,,shl,eb,cl”)
赋值 (_指令文本组 [392], “d2,,ea/5,,,shr,eb,cl”)
赋值 (_指令文本组 [393], “d2,,ea/7,,,sar,eb,cl”)
赋值 (_指令文本组 [394], “d3,,ea/0,,*,rol,ew,cl”)
赋值 (_指令文本组 [395], “d3,,ea/1,,*,ror,ew,cl”)
赋值 (_指令文本组 [396], “d3,,ea/2,,*,rcl,ew,cl”)
赋值 (_指令文本组 [397], “d3,,ea/3,,*,rcr,ew,cl”)
赋值 (_指令文本组 [398], “d3,,ea/4,,*,shl,ew,cl”)
赋值 (_指令文本组 [399], “d3,,ea/5,,*,shr,ew,cl”)
赋值 (_指令文本组 [400], “d3,,ea/7,,*,sar,ew,cl”)
赋值 (_指令文本组 [401], “d4,,,,,aam,,”)
赋值 (_指令文本组 [402], “d5,,,,,aad,,”)
赋值 (_指令文本组 [403], “d7,,,,,xlat,,”)
赋值 (_指令文本组 [404], “d8,,ea/0,,,fadd,real16,”)
赋值 (_指令文本组 [405], “d8,,ea/1,,,fmul,real16,”)
赋值 (_指令文本组 [406], “d8,,ea/2,,,fcom,real16,”)
赋值 (_指令文本组 [407], “d8,,ea/3,,,fcomp,real16,”)
赋值 (_指令文本组 [408], “d8,,ea/4,,,fsub,real16,”)
赋值 (_指令文本组 [409], “d8,,ea/5,,,fsubr,real16,”)
赋值 (_指令文本组 [410], “d8,,ea/6,,,fdiv,real16,”)
赋值 (_指令文本组 [411], “d8,,ea/7,,,fdivr,real16,”)
赋值 (_指令文本组 [412], “d8,,c0+i,,,fadd,st,st(i)”)
赋值 (_指令文本组 [413], “d8,,c8+i,,,fmul,st,st(i)”)
赋值 (_指令文本组 [414], “d8,,d0+i,,,fcom,st,st(i)”)
赋值 (_指令文本组 [415], “d8,,d8+i,,,fcomp,st,st(i)”)
赋值 (_指令文本组 [416], “d8,,e0+i,,,fsub,st,st(i)”)
赋值 (_指令文本组 [417], “d8,,e8+i,,,fsubr,st,st(i)”)
赋值 (_指令文本组 [418], “d8,,f0+i,,,fdiv,st,st(i)”)
赋值 (_指令文本组 [419], “d8,,f8+i,,,fdivr,st,st(i)”)
赋值 (_指令文本组 [420], “d9,d0,,,,fnop,,”)
赋值 (_指令文本组 [421], “d9,e0,,,,fchs,,”)
赋值 (_指令文本组 [422], “d9,e1,,,,fabs,,”)
赋值 (_指令文本组 [423], “d9,e4,,,,ftst,,”)
赋值 (_指令文本组 [424], “d9,e5,,,,fxam,,”)
赋值 (_指令文本组 [425], “d9,e9,,,,fldl2t,,”)
赋值 (_指令文本组 [426], “d9,ea,,,,fldl2e,,”)
赋值 (_指令文本组 [427], “d9,eb,,,,fldpi,,”)
赋值 (_指令文本组 [428], “d9,ec,,,,fldlg2,,”)
赋值 (_指令文本组 [429], “d9,ed,,,,fldln2,,”)
赋值 (_指令文本组 [430], “d9,ee,,,,fldz,,”)
赋值 (_指令文本组 [431], “d9,f0,,,,f2xm1,,”)
赋值 (_指令文本组 [432], “d9,f1,,,,fyl2x,”)
赋值 (_指令文本组 [433], “d9,f2,,,,fptan,”)
赋值 (_指令文本组 [434], “d9,f3,,,,fpatan,”)
赋值 (_指令文本组 [435], “d9,f4,,,,fxtract,”)
赋值 (_指令文本组 [436], “d9,f5,,,,fxtract,”)
赋值 (_指令文本组 [437], “d9,f6,,,,fdecstp,”)
赋值 (_指令文本组 [438], “d9,f7,,,,fincstp,”)
赋值 (_指令文本组 [439], “d9,f8,,,,fprem,”)
赋值 (_指令文本组 [440], “d9,f9,,,,fyl2xp1,”)
赋值 (_指令文本组 [441], “d9,fa,,,,fsqrt,”)
赋值 (_指令文本组 [442], “d9,fb,,,,fsincos,”)
赋值 (_指令文本组 [443], “d9,fc,,,,frndint,”)
赋值 (_指令文本组 [444], “d9,fd,,,,fscale,”)
赋值 (_指令文本组 [445], “d9,fe,,,,fsin,”)
赋值 (_指令文本组 [446], “d9,ff,,,,fcos,”)
赋值 (_指令文本组 [447], “d9,,ea/0,,,fld,real16”)
赋值 (_指令文本组 [448], “d9,,ea/2,,,fst,real16”)
赋值 (_指令文本组 [449], “d9,,ea/3,,,fstp,real16”)
赋值 (_指令文本组 [450], “d9,,ea/4,,,fldenv,ea”)
赋值 (_指令文本组 [451], “d9,,ea/5,,,fldcw,ew”)
赋值 (_指令文本组 [452], “d9,,ea/6,,,fstenv,ea”)
赋值 (_指令文本组 [453], “d9,,c0+i,,,fld,st(i)”)
赋值 (_指令文本组 [454], “d9,,c8+i,,,fxch,st(i)”)
赋值 (_指令文本组 [455], “da,e9,,,,fucompp,”)
赋值 (_指令文本组 [456], “da,,ea/0,,,fiadd,int16”)
赋值 (_指令文本组 [457], “da,,ea/1,,,fimul,int16”)
赋值 (_指令文本组 [458], “da,,ea/2,,,ficom,int16”)
赋值 (_指令文本组 [459], “da,,ea/3,,,ficomp,int16”)
赋值 (_指令文本组 [460], “da,,ea/4,,,fisub,int16”)
赋值 (_指令文本组 [461], “da,,ea/5,,,fisubr,int16”)
赋值 (_指令文本组 [462], “da,,ea/6,,,fidiv,int16”)
赋值 (_指令文本组 [463], “da,,ea/7,,,fidivr,int16”)
赋值 (_指令文本组 [464], “db,e2,,,,fclex,,”)
赋值 (_指令文本组 [465], “db,e3,,,,finit,,”)
赋值 (_指令文本组 [466], “db,,ea/0,,,fild,int16,”)
赋值 (_指令文本组 [467], “db,,ea/2,,,fist,int16,”)
赋值 (_指令文本组 [468], “db,,ea/3,,,fistp,int16,”)
赋值 (_指令文本组 [469], “db,,ea/5,,,fld,real80,”)
赋值 (_指令文本组 [470], “db,,ea/7,,,fstp,real80,”)
赋值 (_指令文本组 [471], “dc,,ea/0,,,fadd,real64,”)
赋值 (_指令文本组 [472], “dc,,ea/1,,,fmul,real64,”)
赋值 (_指令文本组 [473], “dc,,ea/2,,,fcom,real64,”)
赋值 (_指令文本组 [474], “dc,,ea/3,,,fcomp,real64,”)
赋值 (_指令文本组 [475], “dc,,ea/4,,,fsub,real64,”)
赋值 (_指令文本组 [476], “dc,,ea/5,,,fsubr,real64,”)
赋值 (_指令文本组 [477], “dc,,ea/6,,,fdiv,real64,”)
赋值 (_指令文本组 [478], “dc,,ea/7,,,fdivr,real64,”)
赋值 (_指令文本组 [479], “dc,,c0+i,,,fadd,st(i),st”)
赋值 (_指令文本组 [480], “dc,,c8+i,,,fmul,st(i),st”)
赋值 (_指令文本组 [481], “dc,,e0+i,,,fsubr,st(i),st”)
赋值 (_指令文本组 [482], “dc,,e8+i,,,fsub,st(i),st”)
赋值 (_指令文本组 [483], “dc,,f0+i,,,fdivr,st(i),st”)
赋值 (_指令文本组 [484], “dc,,f8+i,,,fdiv,st(i),st”)
赋值 (_指令文本组 [485], “dd,,ea/0,,,fld,real64,”)
赋值 (_指令文本组 [486], “dd,,ea/2,,,fst,real64,”)
赋值 (_指令文本组 [487], “dd,,ea/3,,,fstp,real64,”)
赋值 (_指令文本组 [488], “dd,,ea/4,,,frstor,ea,”)
赋值 (_指令文本组 [489], “dd,,ea/6,,,fsave,ea,”)
赋值 (_指令文本组 [490], “dd,,ea/7,,,fstsw,ew,”)
赋值 (_指令文本组 [491], “dd,,c0+i,,,ffree,st(i),”)
赋值 (_指令文本组 [492], “dd,,d0+i,,,fst,st(i),”)
赋值 (_指令文本组 [493], “dd,,d8+i,,,fstp,st(i),”)
赋值 (_指令文本组 [494], “dd,,e0+i,,,fucom,st(i),”)
赋值 (_指令文本组 [495], “dd,,e8+i,,,fucomp,st(i),”)
赋值 (_指令文本组 [496], “de,d9,,,,fcompp,,”)
赋值 (_指令文本组 [497], “de,,ea/0,,,fiadd,int16,”)
赋值 (_指令文本组 [498], “de,,ea/1,,,fimul,int16,”)
赋值 (_指令文本组 [499], “de,,ea/2,,,ficom,int16,”)
赋值 (_指令文本组 [500], “de,,ea/3,,,ficomp,int16,”)
赋值 (_指令文本组 [501], “de,,ea/4,,,fisub,int16,”)
赋值 (_指令文本组 [502], “de,,ea/5,,,fisubr,int16,”)
赋值 (_指令文本组 [503], “de,,ea/6,,,fidiv,int16,”)
赋值 (_指令文本组 [504], “de,,ea/7,,,fidivr,int16,”)
赋值 (_指令文本组 [505], “de,,c0+i,,,faddp,st(i),st”)
赋值 (_指令文本组 [506], “de,,c8+i,,,fmulp,st(i),st”)
赋值 (_指令文本组 [507], “de,,e0+i,,,fsubrp,st(i),st”)
赋值 (_指令文本组 [508], “de,,e8+i,,,fsubp,st(i),st”)
赋值 (_指令文本组 [509], “de,,f0+i,,,fdivrp,st(i),st”)
赋值 (_指令文本组 [510], “de,,f8+i,,,fdivp,st(i),st”)
赋值 (_指令文本组 [511], “df,e0,,,,fstsw,ax,”)
赋值 (_指令文本组 [512], “df,,ea/0,,,fild,int16,”)
赋值 (_指令文本组 [513], “df,,ea/2,,,fist,int16,”)
赋值 (_指令文本组 [514], “df,,ea/3,,,fistp,int16,”)
赋值 (_指令文本组 [515], “df,,ea/4,,,fbld,int16,”)
赋值 (_指令文本组 [516], “df,,ea/5,,,fild,int16,”)
赋值 (_指令文本组 [517], “df,,ea/6,,,fbstp,bcd80,”)
赋值 (_指令文本组 [518], “df,,ea/7,,,fistp,int64,”)
赋值 (_指令文本组 [519], “e0,,disp8,,,loopne,disp8,”)
赋值 (_指令文本组 [520], “e0,,disp8,,,loopnz,disp8,”)
赋值 (_指令文本组 [521], “e1,,disp8,,,loope,disp8,”)
赋值 (_指令文本组 [522], “e1,,disp8,,,loopz,disp8,”)
赋值 (_指令文本组 [523], “e2,,disp8,,,loop,disp8,”)
赋值 (_指令文本组 [524], “e3,,data8,,,jcxz,data8,”)
赋值 (_指令文本组 [525], “e4,,data8,,,in,al,data8”)
赋值 (_指令文本组 [526], “e5,,data8,,*,in,ax,data8”)
赋值 (_指令文本组 [527], “e6,,data8,,,out,data8,al”)
赋值 (_指令文本组 [528], “e7,,data8,,*,out,data8,ax”)
赋值 (_指令文本组 [529], “e8,,disp16,,*,call,disp16,”)
赋值 (_指令文本组 [530], “e9,,disp16,,,jmp,disp16,”)
赋值 (_指令文本组 [531], “ea,,ea48,,*,jmp,farea48,”)
赋值 (_指令文本组 [532], “eb,,disp8,,,jmp,disp8,”)
赋值 (_指令文本组 [533], “ec,,,,,in,al,dx”)
赋值 (_指令文本组 [534], “ed,,,,*,in,ax,dx”)
赋值 (_指令文本组 [535], “ee,,,,,out,dx,al”)
赋值 (_指令文本组 [536], “ef,,,,*,out,dx,ax”)
赋值 (_指令文本组 [537], “f0,,,,,lock,,”)
赋值 (_指令文本组 [538], “f2,,,,,repne,,”)
赋值 (_指令文本组 [539], “f2,,,,,repnz,,”)
赋值 (_指令文本组 [540], “f3,,,,,rep,,”)
赋值 (_指令文本组 [541], “f3,,,,,repe,,”)
赋值 (_指令文本组 [542], “f3,,,,,repz,,”)
赋值 (_指令文本组 [543], “f4,,,,,hlt,,”)
赋值 (_指令文本组 [544], “f5,,,,,cmc,,”)
赋值 (_指令文本组 [545], “f6,,ea/0,data8,,test,eb,data8”)
赋值 (_指令文本组 [546], “f6,,ea/2,,,not,eb,”)
赋值 (_指令文本组 [547], “f6,,ea/3,,,neg,eb,”)
赋值 (_指令文本组 [548], “f6,,ea/4,,,mul,al,eb”)
赋值 (_指令文本组 [549], “f6,,ea/5,,,imul,al,eb”)
赋值 (_指令文本组 [550], “f6,,ea/6,,,div,al,eb”)
赋值 (_指令文本组 [551], “f6,,ea/7,,,idiv,al,eb”)
赋值 (_指令文本组 [552], “f7,,ea/0,data16,*,test,ew,data16”)
赋值 (_指令文本组 [553], “f7,,ea/2,,*,not,ew,”)
赋值 (_指令文本组 [554], “f7,,ea/3,,*,neg,ew,”)
赋值 (_指令文本组 [555], “f7,,ea/4,,*,mul,ax,ed”)
赋值 (_指令文本组 [556], “f7,,ea/5,,*,imul,ax,ed”)
赋值 (_指令文本组 [557], “f7,,ea/6,,*,div,ax,ed”)
赋值 (_指令文本组 [558], “f7,,ea/7,,*,idiv,ax,ed”)
赋值 (_指令文本组 [559], “f8,,,,,clc,,”)
赋值 (_指令文本组 [560], “f9,,,,,stc,”)
赋值 (_指令文本组 [561], “fa,,,,,cli,”)
赋值 (_指令文本组 [562], “fb,,,,,sti,”)
赋值 (_指令文本组 [563], “fc,,,,,cld,”)
赋值 (_指令文本组 [564], “fd,,,,,std,”)
赋值 (_指令文本组 [565], “fe,,ea/0,,,inc,eb”)
赋值 (_指令文本组 [566], “fe,,ea/1,,,dec,eb”)
赋值 (_指令文本组 [567], “ff,,ea/0,,*,inc,ew”)
赋值 (_指令文本组 [568], “ff,,ea/1,,*,dec,ew”)
赋值 (_指令文本组 [569], “ff,,ea/2,,*,call,ew”)
赋值 (_指令文本组 [570], “ff,,ea/3,,*,call,farea”)
赋值 (_指令文本组 [571], “ff,,ea/4,,*,jmp,ew”)
赋值 (_指令文本组 [572], “ff,,ea/5,,*,jmp,farea”)
赋值 (_指令文本组 [573], “ff,,ea/6,,*,push,ew”)


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.类模块 代码转指令类16, , , 

.程序集变量 子程序组, 整数型, , "256", 
.程序集变量 程序代码, 字节集, , , 
.程序集变量 代码位置, 整数型, , , 
.程序集变量 程序资源, 资源数据类型1, , , 
.程序集变量 错误提示文本组, 文本型, , "0", 
.程序集变量 本行代码, 字节集, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
赋值 (子程序组 [1], 取子程序地址 (&子程序1))
赋值 (子程序组 [2], 取子程序地址 (&子程序2))
赋值 (子程序组 [3], 取子程序地址 (&子程序3))
赋值 (子程序组 [4], 取子程序地址 (&子程序4))
赋值 (子程序组 [5], 取子程序地址 (&子程序5))
赋值 (子程序组 [6], 取子程序地址 (&子程序6))
赋值 (子程序组 [7], 取子程序地址 (&子程序7))
赋值 (子程序组 [8], 取子程序地址 (&子程序8))
赋值 (子程序组 [9], 取子程序地址 (&子程序9))
赋值 (子程序组 [10], 取子程序地址 (&子程序10))
赋值 (子程序组 [11], 取子程序地址 (&子程序11))
赋值 (子程序组 [12], 取子程序地址 (&子程序12))
赋值 (子程序组 [13], 取子程序地址 (&子程序13))
赋值 (子程序组 [14], 取子程序地址 (&子程序14))
赋值 (子程序组 [15], 取子程序地址 (&子程序15))
赋值 (子程序组 [16], 取子程序地址 (&子程序16))
赋值 (子程序组 [17], 取子程序地址 (&子程序17))
赋值 (子程序组 [18], 取子程序地址 (&子程序18))
赋值 (子程序组 [19], 取子程序地址 (&子程序19))
赋值 (子程序组 [20], 取子程序地址 (&子程序20))
赋值 (子程序组 [21], 取子程序地址 (&子程序21))
赋值 (子程序组 [22], 取子程序地址 (&子程序22))
赋值 (子程序组 [23], 取子程序地址 (&子程序23))
赋值 (子程序组 [24], 取子程序地址 (&子程序24))
赋值 (子程序组 [25], 取子程序地址 (&子程序25))
赋值 (子程序组 [26], 取子程序地址 (&子程序26))
赋值 (子程序组 [27], 取子程序地址 (&子程序27))
赋值 (子程序组 [28], 取子程序地址 (&子程序28))
赋值 (子程序组 [29], 取子程序地址 (&子程序29))
赋值 (子程序组 [30], 取子程序地址 (&子程序30))
赋值 (子程序组 [31], 取子程序地址 (&子程序31))
赋值 (子程序组 [32], 取子程序地址 (&子程序32))
赋值 (子程序组 [33], 取子程序地址 (&子程序33))
赋值 (子程序组 [34], 取子程序地址 (&子程序34))
赋值 (子程序组 [35], 取子程序地址 (&子程序35))
赋值 (子程序组 [36], 取子程序地址 (&子程序36))
赋值 (子程序组 [37], 取子程序地址 (&子程序37))
赋值 (子程序组 [38], 取子程序地址 (&子程序38))
赋值 (子程序组 [39], 取子程序地址 (&子程序39))
赋值 (子程序组 [40], 取子程序地址 (&子程序40))
赋值 (子程序组 [41], 取子程序地址 (&子程序41))
赋值 (子程序组 [42], 取子程序地址 (&子程序42))
赋值 (子程序组 [43], 取子程序地址 (&子程序43))
赋值 (子程序组 [44], 取子程序地址 (&子程序44))
赋值 (子程序组 [45], 取子程序地址 (&子程序45))
赋值 (子程序组 [46], 取子程序地址 (&子程序46))
赋值 (子程序组 [47], 取子程序地址 (&子程序47))
赋值 (子程序组 [48], 取子程序地址 (&子程序48))
赋值 (子程序组 [49], 取子程序地址 (&子程序49))
赋值 (子程序组 [50], 取子程序地址 (&子程序50))
赋值 (子程序组 [51], 取子程序地址 (&子程序51))
赋值 (子程序组 [52], 取子程序地址 (&子程序52))
赋值 (子程序组 [53], 取子程序地址 (&子程序53))
赋值 (子程序组 [54], 取子程序地址 (&子程序54))
赋值 (子程序组 [55], 取子程序地址 (&子程序55))
赋值 (子程序组 [56], 取子程序地址 (&子程序56))
赋值 (子程序组 [57], 取子程序地址 (&子程序57))
赋值 (子程序组 [58], 取子程序地址 (&子程序58))
赋值 (子程序组 [59], 取子程序地址 (&子程序59))
赋值 (子程序组 [60], 取子程序地址 (&子程序60))
赋值 (子程序组 [61], 取子程序地址 (&子程序61))
赋值 (子程序组 [62], 取子程序地址 (&子程序62))
赋值 (子程序组 [63], 取子程序地址 (&子程序63))
赋值 (子程序组 [64], 取子程序地址 (&子程序64))
赋值 (子程序组 [65], 取子程序地址 (&子程序65))
赋值 (子程序组 [66], 取子程序地址 (&子程序66))
赋值 (子程序组 [67], 取子程序地址 (&子程序67))
赋值 (子程序组 [68], 取子程序地址 (&子程序68))
赋值 (子程序组 [69], 取子程序地址 (&子程序69))
赋值 (子程序组 [70], 取子程序地址 (&子程序70))
赋值 (子程序组 [71], 取子程序地址 (&子程序71))
赋值 (子程序组 [72], 取子程序地址 (&子程序72))
赋值 (子程序组 [73], 取子程序地址 (&子程序73))
赋值 (子程序组 [74], 取子程序地址 (&子程序74))
赋值 (子程序组 [75], 取子程序地址 (&子程序75))
赋值 (子程序组 [76], 取子程序地址 (&子程序76))
赋值 (子程序组 [77], 取子程序地址 (&子程序77))
赋值 (子程序组 [78], 取子程序地址 (&子程序78))
赋值 (子程序组 [79], 取子程序地址 (&子程序79))
赋值 (子程序组 [80], 取子程序地址 (&子程序80))
赋值 (子程序组 [81], 取子程序地址 (&子程序81))
赋值 (子程序组 [82], 取子程序地址 (&子程序82))
赋值 (子程序组 [83], 取子程序地址 (&子程序83))
赋值 (子程序组 [84], 取子程序地址 (&子程序84))
赋值 (子程序组 [85], 取子程序地址 (&子程序85))
赋值 (子程序组 [86], 取子程序地址 (&子程序86))
赋值 (子程序组 [87], 取子程序地址 (&子程序87))
赋值 (子程序组 [88], 取子程序地址 (&子程序88))
赋值 (子程序组 [89], 取子程序地址 (&子程序89))
赋值 (子程序组 [90], 取子程序地址 (&子程序90))
赋值 (子程序组 [91], 取子程序地址 (&子程序91))
赋值 (子程序组 [92], 取子程序地址 (&子程序92))
赋值 (子程序组 [93], 取子程序地址 (&子程序93))
赋值 (子程序组 [94], 取子程序地址 (&子程序94))
赋值 (子程序组 [95], 取子程序地址 (&子程序95))
赋值 (子程序组 [96], 取子程序地址 (&子程序96))
赋值 (子程序组 [97], 取子程序地址 (&子程序97))
赋值 (子程序组 [98], 取子程序地址 (&子程序98))
赋值 (子程序组 [99], 取子程序地址 (&子程序99))
赋值 (子程序组 [100], 取子程序地址 (&子程序100))
赋值 (子程序组 [101], 取子程序地址 (&子程序101))
赋值 (子程序组 [102], 取子程序地址 (&子程序102))
赋值 (子程序组 [103], 取子程序地址 (&子程序103))
赋值 (子程序组 [104], 取子程序地址 (&子程序104))
赋值 (子程序组 [105], 取子程序地址 (&子程序105))
赋值 (子程序组 [106], 取子程序地址 (&子程序106))
赋值 (子程序组 [107], 取子程序地址 (&子程序107))
赋值 (子程序组 [108], 取子程序地址 (&子程序108))
赋值 (子程序组 [109], 取子程序地址 (&子程序109))
赋值 (子程序组 [110], 取子程序地址 (&子程序110))
赋值 (子程序组 [111], 取子程序地址 (&子程序111))
赋值 (子程序组 [112], 取子程序地址 (&子程序112))
赋值 (子程序组 [113], 取子程序地址 (&子程序113))
赋值 (子程序组 [114], 取子程序地址 (&子程序114))
赋值 (子程序组 [115], 取子程序地址 (&子程序115))
赋值 (子程序组 [116], 取子程序地址 (&子程序116))
赋值 (子程序组 [117], 取子程序地址 (&子程序117))
赋值 (子程序组 [118], 取子程序地址 (&子程序118))
赋值 (子程序组 [119], 取子程序地址 (&子程序119))
赋值 (子程序组 [120], 取子程序地址 (&子程序120))
赋值 (子程序组 [121], 取子程序地址 (&子程序121))
赋值 (子程序组 [122], 取子程序地址 (&子程序122))
赋值 (子程序组 [123], 取子程序地址 (&子程序123))
赋值 (子程序组 [124], 取子程序地址 (&子程序124))
赋值 (子程序组 [125], 取子程序地址 (&子程序125))
赋值 (子程序组 [126], 取子程序地址 (&子程序126))
赋值 (子程序组 [127], 取子程序地址 (&子程序127))
赋值 (子程序组 [128], 取子程序地址 (&子程序128))
赋值 (子程序组 [129], 取子程序地址 (&子程序129))
赋值 (子程序组 [130], 取子程序地址 (&子程序130))
赋值 (子程序组 [131], 取子程序地址 (&子程序131))
赋值 (子程序组 [132], 取子程序地址 (&子程序132))
赋值 (子程序组 [133], 取子程序地址 (&子程序133))
赋值 (子程序组 [134], 取子程序地址 (&子程序134))
赋值 (子程序组 [135], 取子程序地址 (&子程序135))
赋值 (子程序组 [136], 取子程序地址 (&子程序136))
赋值 (子程序组 [137], 取子程序地址 (&子程序137))
赋值 (子程序组 [138], 取子程序地址 (&子程序138))
赋值 (子程序组 [139], 取子程序地址 (&子程序139))
赋值 (子程序组 [140], 取子程序地址 (&子程序140))
赋值 (子程序组 [141], 取子程序地址 (&子程序141))
赋值 (子程序组 [142], 取子程序地址 (&子程序142))
赋值 (子程序组 [143], 取子程序地址 (&子程序143))
赋值 (子程序组 [144], 取子程序地址 (&子程序144))
赋值 (子程序组 [145], 取子程序地址 (&子程序145))
赋值 (子程序组 [146], 取子程序地址 (&子程序146))
赋值 (子程序组 [147], 取子程序地址 (&子程序147))
赋值 (子程序组 [148], 取子程序地址 (&子程序148))
赋值 (子程序组 [149], 取子程序地址 (&子程序149))
赋值 (子程序组 [150], 取子程序地址 (&子程序150))
赋值 (子程序组 [151], 取子程序地址 (&子程序151))
赋值 (子程序组 [152], 取子程序地址 (&子程序152))
赋值 (子程序组 [153], 取子程序地址 (&子程序153))
赋值 (子程序组 [154], 取子程序地址 (&子程序154))
赋值 (子程序组 [155], 取子程序地址 (&子程序155))
赋值 (子程序组 [156], 取子程序地址 (&子程序156))
赋值 (子程序组 [157], 取子程序地址 (&子程序157))
赋值 (子程序组 [158], 取子程序地址 (&子程序158))
赋值 (子程序组 [159], 取子程序地址 (&子程序159))
赋值 (子程序组 [160], 取子程序地址 (&子程序160))
赋值 (子程序组 [161], 取子程序地址 (&子程序161))
赋值 (子程序组 [162], 取子程序地址 (&子程序162))
赋值 (子程序组 [163], 取子程序地址 (&子程序163))
赋值 (子程序组 [164], 取子程序地址 (&子程序164))
赋值 (子程序组 [165], 取子程序地址 (&子程序165))
赋值 (子程序组 [166], 取子程序地址 (&子程序166))
赋值 (子程序组 [167], 取子程序地址 (&子程序167))
赋值 (子程序组 [168], 取子程序地址 (&子程序168))
赋值 (子程序组 [169], 取子程序地址 (&子程序169))
赋值 (子程序组 [170], 取子程序地址 (&子程序170))
赋值 (子程序组 [171], 取子程序地址 (&子程序171))
赋值 (子程序组 [172], 取子程序地址 (&子程序172))
赋值 (子程序组 [173], 取子程序地址 (&子程序173))
赋值 (子程序组 [174], 取子程序地址 (&子程序174))
赋值 (子程序组 [175], 取子程序地址 (&子程序175))
赋值 (子程序组 [176], 取子程序地址 (&子程序176))
赋值 (子程序组 [177], 取子程序地址 (&子程序177))
赋值 (子程序组 [178], 取子程序地址 (&子程序178))
赋值 (子程序组 [179], 取子程序地址 (&子程序179))
赋值 (子程序组 [180], 取子程序地址 (&子程序180))
赋值 (子程序组 [181], 取子程序地址 (&子程序181))
赋值 (子程序组 [182], 取子程序地址 (&子程序182))
赋值 (子程序组 [183], 取子程序地址 (&子程序183))
赋值 (子程序组 [184], 取子程序地址 (&子程序184))
赋值 (子程序组 [185], 取子程序地址 (&子程序185))
赋值 (子程序组 [186], 取子程序地址 (&子程序186))
赋值 (子程序组 [187], 取子程序地址 (&子程序187))
赋值 (子程序组 [188], 取子程序地址 (&子程序188))
赋值 (子程序组 [189], 取子程序地址 (&子程序189))
赋值 (子程序组 [190], 取子程序地址 (&子程序190))
赋值 (子程序组 [191], 取子程序地址 (&子程序191))
赋值 (子程序组 [192], 取子程序地址 (&子程序192))
赋值 (子程序组 [193], 取子程序地址 (&子程序193))
赋值 (子程序组 [194], 取子程序地址 (&子程序194))
赋值 (子程序组 [195], 取子程序地址 (&子程序195))
赋值 (子程序组 [196], 取子程序地址 (&子程序196))
赋值 (子程序组 [197], 取子程序地址 (&子程序197))
赋值 (子程序组 [198], 取子程序地址 (&子程序198))
赋值 (子程序组 [199], 取子程序地址 (&子程序199))
赋值 (子程序组 [200], 取子程序地址 (&子程序200))
赋值 (子程序组 [201], 取子程序地址 (&子程序201))
赋值 (子程序组 [202], 取子程序地址 (&子程序202))
赋值 (子程序组 [203], 取子程序地址 (&子程序203))
赋值 (子程序组 [204], 取子程序地址 (&子程序204))
赋值 (子程序组 [205], 取子程序地址 (&子程序205))
赋值 (子程序组 [206], 取子程序地址 (&子程序206))
赋值 (子程序组 [207], 取子程序地址 (&子程序207))
赋值 (子程序组 [208], 取子程序地址 (&子程序208))
赋值 (子程序组 [209], 取子程序地址 (&子程序209))
赋值 (子程序组 [210], 取子程序地址 (&子程序210))
赋值 (子程序组 [211], 取子程序地址 (&子程序211))
赋值 (子程序组 [212], 取子程序地址 (&子程序212))
赋值 (子程序组 [213], 取子程序地址 (&子程序213))
赋值 (子程序组 [214], 取子程序地址 (&子程序214))
赋值 (子程序组 [215], 取子程序地址 (&子程序215))
赋值 (子程序组 [216], 取子程序地址 (&子程序216))
赋值 (子程序组 [217], 取子程序地址 (&子程序217))
赋值 (子程序组 [218], 取子程序地址 (&子程序218))
赋值 (子程序组 [219], 取子程序地址 (&子程序219))
赋值 (子程序组 [220], 取子程序地址 (&子程序220))
赋值 (子程序组 [221], 取子程序地址 (&子程序221))
赋值 (子程序组 [222], 取子程序地址 (&子程序222))
赋值 (子程序组 [223], 取子程序地址 (&子程序223))
赋值 (子程序组 [224], 取子程序地址 (&子程序224))
赋值 (子程序组 [225], 取子程序地址 (&子程序225))
赋值 (子程序组 [226], 取子程序地址 (&子程序226))
赋值 (子程序组 [227], 取子程序地址 (&子程序227))
赋值 (子程序组 [228], 取子程序地址 (&子程序228))
赋值 (子程序组 [229], 取子程序地址 (&子程序229))
赋值 (子程序组 [230], 取子程序地址 (&子程序230))
赋值 (子程序组 [231], 取子程序地址 (&子程序231))
赋值 (子程序组 [232], 取子程序地址 (&子程序232))
赋值 (子程序组 [233], 取子程序地址 (&子程序233))
赋值 (子程序组 [234], 取子程序地址 (&子程序234))
赋值 (子程序组 [235], 取子程序地址 (&子程序235))
赋值 (子程序组 [236], 取子程序地址 (&子程序236))
赋值 (子程序组 [237], 取子程序地址 (&子程序237))
赋值 (子程序组 [238], 取子程序地址 (&子程序238))
赋值 (子程序组 [239], 取子程序地址 (&子程序239))
赋值 (子程序组 [240], 取子程序地址 (&子程序240))
赋值 (子程序组 [241], 取子程序地址 (&子程序241))
赋值 (子程序组 [242], 取子程序地址 (&子程序242))
赋值 (子程序组 [243], 取子程序地址 (&子程序243))
赋值 (子程序组 [244], 取子程序地址 (&子程序244))
赋值 (子程序组 [245], 取子程序地址 (&子程序245))
赋值 (子程序组 [246], 取子程序地址 (&子程序246))
赋值 (子程序组 [247], 取子程序地址 (&子程序247))
赋值 (子程序组 [248], 取子程序地址 (&子程序248))
赋值 (子程序组 [249], 取子程序地址 (&子程序249))
赋值 (子程序组 [250], 取子程序地址 (&子程序250))
赋值 (子程序组 [251], 取子程序地址 (&子程序251))
赋值 (子程序组 [252], 取子程序地址 (&子程序252))
赋值 (子程序组 [253], 取子程序地址 (&子程序253))
赋值 (子程序组 [254], 取子程序地址 (&子程序254))
赋值 (子程序组 [255], 取子程序地址 (&子程序255))
赋值 (子程序组 [256], 取子程序地址 (&子程序256))
赋值 (代码位置, 1)


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 取一个字节, 逻辑型, , 位置加一
.参数 返回字节, 字节型, 参考, 

.局部变量 当前位置, 整数型, 静态, , 

赋值 (当前位置, 代码位置)
.如果真 (等于 (当前位置, -1))
    加入成员 (错误提示文本组, “到数据结尾!”)
    返回 (假)
.如果真结束
赋值 (返回字节, 取字节集数据 (程序代码, 1, 当前位置))
赋值 (代码位置, 当前位置)
赋值 (本行代码, 相加 (本行代码, 到字节集 (返回字节)))
返回 (真)


.子程序 取一个字, 逻辑型, , 位置加二
.参数 返回字, 短整数型, 参考, 

.局部变量 当前位置, 整数型, 静态, , 

赋值 (当前位置, 代码位置)
.如果真 (等于 (当前位置, -1))
    加入成员 (错误提示文本组, “到数据结尾!”)
    返回 (假)
.如果真结束
赋值 (返回字, 取字节集数据 (程序代码, 2, 当前位置))
赋值 (代码位置, 当前位置)
赋值 (本行代码, 相加 (本行代码, 到字节集 (返回字)))
返回 (真)


.子程序 取一个双字, 逻辑型, , 位置加四
.参数 返回数, 整数型, 参考, 

.局部变量 当前位置, 整数型, 静态, , 

赋值 (当前位置, 代码位置)
.如果真 (等于 (当前位置, -1))
    加入成员 (错误提示文本组, “到数据结尾!”)
    返回 (假)
.如果真结束
赋值 (返回数, 取字节集数据 (程序代码, 3, 当前位置))
赋值 (代码位置, 当前位置)
赋值 (本行代码, 相加 (本行代码, 到字节集 (返回数)))
返回 (真)


.子程序 取一行文本, 逻辑型, , 位置增加文本长度+1
.参数 返回数, 文本型, 参考, 

.局部变量 当前位置, 整数型, 静态, , 

赋值 (当前位置, 代码位置)
.如果真 (等于 (当前位置, -1))
    加入成员 (错误提示文本组, “到数据结尾!”)
    返回 (假)
.如果真结束
赋值 (返回数, 取字节集数据 (程序代码, 10, 当前位置))
赋值 (代码位置, 当前位置)
赋值 (本行代码, 相加 (本行代码, 到字节集 (返回数)))
返回 (真)


.子程序 读入代码数据, 空白型, , 
.参数 代码, 字节集, , 

赋值 (程序代码, 代码)
赋值 (代码位置, 1)
读取程序资源 ()
赋值 (代码位置, 1)


.子程序 取一条代码指令, 逻辑型, , 返回当前位置指令文本,输入的字节集需追加一个结尾字节(读入代码时将自动加入)
.参数 指令文本, 文本型, 参考, 
.参数 返回位置, 整数型, 参考, 

.局部变量 指令代码, 字节型, , , 
.局部变量 错误文本, 文本型, , , 
.局部变量 空字节集, 字节集, , , 

赋值 (指令文本, “”)
赋值 (本行代码, 空字节集)
.如果真 (小于 (返回位置, 1))
    返回 (假)
.如果真结束
赋值 (代码位置, 返回位置)
.如果真 (等于 (取一个字节 (指令代码), 假))
    赋值 (返回位置, 代码位置)
    返回 (假)
.如果真结束
.如果真 (等于 (代码转指令_子程序 (子程序组 [相加 (指令代码, 1)], 指令文本), 假))
    加入成员 (错误提示文本组, 相加 (“子程序调用错误!第”, 到文本 (代码位置), “行”))
    加入成员 (错误提示文本组, 相加 (错误文本, 到文本 (代码位置), “行”))
    赋值 (返回位置, 代码位置)
    返回 (假)
.如果真结束
.如果真 (等于 (取文本长度 (指令文本), 0))
    加入成员 (错误提示文本组, 相加 (“取指令错误!>>”, 取错误提示文本_子 ()))
    赋值 (返回位置, 代码位置)
    返回 (假)
.如果真结束
赋值 (返回位置, 代码位置)
返回 (真)


.子程序 置当前位置, 空白型, , 
.参数 新位置, 整数型, , 

.如果真 (小于 (新位置, 1))
    加入成员 (错误提示文本组, “置位置错误!”)
    赋值 (代码位置, 1)
    返回 ()
.如果真结束
赋值 (代码位置, 新位置)


.子程序 取当前位置, 整数型, , 
返回 (代码位置)


.子程序 读取程序资源, 逻辑型, , 
.局部变量 i, 整数型, , , 
.局部变量 注释资源数, 整数型, , , 
.局部变量 标号资源数, 整数型, , , 
.局部变量 变量资源数, 整数型, , , 
.局部变量 一个字节, 字节型, , , 

 ' eb 06 代码以这两个字节开头,新位置为7
.如果 (取一个字 (i))
    .如果真 (不等于 (i, 1771))
        加入成员 (错误提示文本组, “代码中无法确定资源位置或不含资源!(#资源001)”)
        返回 (假)
    .如果真结束
    
.否则
    加入成员 (错误提示文本组, “代码中无法确定资源位置或不含资源!(#资源002)”)
    返回 (假)
.如果结束
.如果真 (等于 (取一个双字 (i), 假))
    .如果真 (小于 (i, 255))
        加入成员 (错误提示文本组, “代码中无法确定资源位置或不含资源!(#资源003)”)
        返回 (假)
    .如果真结束
    
.如果真结束

置当前位置 (i)

.如果真 (等于 (取一个字 (注释资源数), 假))
    加入成员 (错误提示文本组, “代码中无法确定资源位置或不含资源!(#资源004)”)
    返回 (假)
.如果真结束
重定义数组 (程序资源.注释, 假, 注释资源数)
.计次循环首 (注释资源数, i)
    .如果真 (等于 (取一个双字 (程序资源.注释 [i], 位置行号), 假))
        加入成员 (错误提示文本组, “取注释资源_位置行号错误!(#资源005)”)
        返回 (假)
    .如果真结束
    .如果真 (等于 (取一行文本 (程序资源.注释 [i], 文本内容), 假))
        加入成员 (错误提示文本组, “取注释资源_文本内容错误!(#资源006)”)
        返回 (假)
    .如果真结束
    
.计次循环尾 ()
.如果真 (等于 (取一个字 (标号资源数), 假))
    加入成员 (错误提示文本组, “代码中无法确定资源位置或不含资源!(#资源006)”)
    返回 (假)
.如果真结束
重定义数组 (程序资源.标号, 假, 标号资源数)
.计次循环首 (标号资源数, i)
    .如果真 (等于 (取一个双字 (程序资源.标号 [i], 定义位置行号), 假))
        加入成员 (错误提示文本组, “取标号资源_定义位置行号错误!(#资源007)”)
        返回 (假)
    .如果真结束
    .如果真 (等于 (取一行文本 (程序资源.标号 [i], 名称), 假))
        加入成员 (错误提示文本组, “取标号资源_名称错误!(#资源008)”)
        返回 (假)
    .如果真结束
    
.计次循环尾 ()
.如果真 (等于 (取一个字 (变量资源数), 假))
    加入成员 (错误提示文本组, “代码中无法确定资源位置或不含资源!(#资源009)”)
    返回 (假)
.如果真结束
重定义数组 (程序资源.变量, 假, 变量资源数)
.计次循环首 (变量资源数, i)
    .如果真 (等于 (取一个双字 (程序资源.变量 [i], 定义位置从头偏移量), 假))
        加入成员 (错误提示文本组, “取变量资源_位置偏移错误!(#资源010)”)
        返回 (假)
    .如果真结束
    .如果真 (等于 (取一行文本 (程序资源.变量 [i], 名称), 假))
        加入成员 (错误提示文本组, “取变量资源_名称错误!(#资源011)”)
        返回 (假)
    .如果真结束
    .如果真 (等于 (取一个字节 (程序资源.变量 [i], 类型), 假))
        加入成员 (错误提示文本组, “取变量资源_类型错误!(#资源012)”)
        返回 (假)
    .如果真结束
    .计次循环首 (程序资源.变量 [i], 类型, )
        .如果真 (等于 (取一个字节 (一个字节), 假))
            加入成员 (错误提示文本组, “取变量资源_一个字节错误!(#资源013)”)
            返回 (假)
        .如果真结束
        赋值 (程序资源.变量 [i], 内容, 相加 (程序资源.变量 [i], 内容, 到字节集 (一个字节)))
    .计次循环尾 ()
.计次循环尾 ()
返回 (真)


.子程序 取错误提示文本组, 逻辑型, , 无错误提示返回假,否则返回真
.参数 错误文本组, 文本型, 参考 数组, 

赋值 (错误文本组, 错误提示文本组)
.如果真 (等于 (取数组成员数 (错误文本组), 0))
    返回 (假)
.如果真结束
返回 (真)


.子程序 取本行代码集, 字节集, , 
返回 (本行代码)


.子程序 清空错误提示文本组, 空白型, , 
重定义数组 (错误提示文本组, 假, 0)


.子程序 置操作尺寸_类, 空白型, , 
.参数 输入数据, 逻辑型, , 

置操作尺寸 (输入数据)

.类模块 寻址判断类, , , 

.程序集变量 reg8文本组, 文本型, , "8", 
.程序集变量 reg16文本组, 文本型, , "8", 
.程序集变量 reg32文本组, 文本型, , "8", 
.程序集变量 匿名程序集变量_3319, 空白型, , , 
.程序集变量 sreg文本组, 文本型, , "8", 
.程序集变量 s文本组, 文本型, , "4", 
.程序集变量 匿名程序集变量_3318, 空白型, , , 
.程序集变量 modrm文本组_00_16, 文本型, , "8", 
.程序集变量 modrm文本组_01_16, 文本型, , "8", 
.程序集变量 modrm文本组_10_16, 文本型, , "8", 
.程序集变量 m00段前缀文本组_16, 文本型, , "8", 
.程序集变量 m01段前缀文本组_16, 文本型, , "8", 
.程序集变量 匿名程序集变量_3315, 空白型, , , 
.程序集变量 modrm文本组_00_32, 文本型, , "8", 
.程序集变量 modrm文本组_01_32, 文本型, , "8", 
.程序集变量 modrm文本组_10_32, 文本型, , "8", 
.程序集变量 m00段前缀文本组_32, 文本型, , "8", 
.程序集变量 m01段前缀文本组_32, 文本型, , "8", 
.程序集变量 匿名程序集变量_3327, 空白型, , , 
.程序集变量 操作数尺寸文本组, 文本型, , "3", 
.程序集变量 匿名程序集变量_3320, 空白型, , , 
.程序集变量 eb前缀, 文本型, , , 
.程序集变量 ew前缀, 文本型, , , 
.程序集变量 段前缀, 文本型, , , 
.程序集变量 前缀判断, 字节型, , , 
.子程序 _初始化, 空白型, , 当基于本类的对象被创建后，此方法会被自动调用
 ' reg,modrm文本组初始化
初始mrr文本 ()


.子程序 初始mrr文本, 空白型, , 
赋值 (eb前缀, “<byte>”)
赋值 (ew前缀, “<word>”)

赋值 (reg8文本组, 分割文本 (#reg8文本, , ))
赋值 (reg16文本组, 分割文本 (#reg16文本, , ))
赋值 (reg32文本组, 分割文本 (#reg32文本, , ))

赋值 (sreg文本组, 分割文本 (#sreg文本, , ))
赋值 (s文本组, 分割文本 (#s文本, , ))

赋值 (modrm文本组_00_16, 分割文本 (#modrm文本_00_16, , ))
赋值 (modrm文本组_01_16, 分割文本 (#modrm文本_01_16, , ))
赋值 (modrm文本组_10_16, 分割文本 (#modrm文本_10_16, , ))
赋值 (modrm文本组_00_32, 分割文本 (#modrm文本_00_32, , ))
赋值 (modrm文本组_01_32, 分割文本 (#modrm文本_01_32, , ))
赋值 (modrm文本组_10_32, 分割文本 (#modrm文本_10_32, , ))

赋值 (m00段前缀文本组_16, 分割文本 (#m00段前缀_16, , ))
赋值 (m01段前缀文本组_16, 分割文本 (#m01段前缀_16, , ))
赋值 (m00段前缀文本组_32, 分割文本 (#m00段前缀_32, , ))
赋值 (m01段前缀文本组_32, 分割文本 (#m01段前缀_32, , ))

赋值 (操作数尺寸文本组, 分割文本 (#操作数尺寸文本, , ))


.子程序 _销毁, 空白型, , 当基于本类的对象被销毁前，此方法会被自动调用


.子程序 mod_reg_rm取值, 空白型, , 
.参数 输入字节, 字节型, , 
.参数 mod, 字节型, 参考 可空, 
.参数 reg, 字节型, 参考 可空, 
.参数 rm, 字节型, 参考 可空, 

赋值 (reg, 右移 (位与 (输入字节, 56), 3))
赋值 (mod, 右移 (位与 (输入字节, 192), 6))
赋值 (rm, 位与 (输入字节, 7))


.子程序 mod取值, 字节型, , 
.参数 输入字节, 字节型, , 

返回 (右移 (位与 (输入字节, 192), 6))


.子程序 reg取值, 字节型, , 
.参数 输入字节, 字节型, , 

返回 (右移 (位与 (输入字节, 56), 3))


.子程序 rm取值, 字节型, , 
.参数 输入字节, 字节型, , 

返回 (位与 (输入字节, 7))


.子程序 取reg8文本, 文本型, , 
.参数 输入字节, 字节型, , 

.如果真 (大于 (输入字节, 7))
    返回 (“”)
.如果真结束
返回 (reg8文本组 [相加 (输入字节, 1)])


.子程序 取reg16文本, 文本型, , 
.参数 输入字节, 字节型, , 

.如果真 (大于 (输入字节, 8))
    返回 (“”)
.如果真结束
返回 (reg16文本组 [相加 (输入字节, 1)])


.子程序 取reg32文本, 文本型, , 
.参数 输入字节, 字节型, , 

.如果真 (大于 (输入字节, 8))
    返回 (“”)
.如果真结束
返回 (reg32文本组 [相加 (输入字节, 1)])


.子程序 取sreg文本, 文本型, , 
.参数 输入字节, 字节型, , 

.如果真 (大于 (输入字节, 7))
    返回 (“”)
.如果真结束
返回 (sreg文本组 [相加 (输入字节, 1)])


.子程序 取crn文本, 文本型, , 
.参数 输入字节, 字节型, , 

.判断开始 (等于 (输入字节, 0))
    返回 (“cr0”)
.判断 (等于 (输入字节, 2))
    返回 (“cr2”)
.判断 (等于 (输入字节, 3))
    返回 (“cr3”)
.默认
    
.判断结束
返回 (“”)


.子程序 取drn文本, 文本型, , 
.参数 输入字节, 字节型, , 

.如果真 (或者 (等于 (输入字节, 4), 等于 (输入字节, 5), 大于 (输入字节, 7)))
    返回 (“”)
.如果真结束
返回 (相加 (“dr”, 到文本 (输入字节)))


.子程序 取trn文本, 文本型, , 
.参数 输入字节, 字节型, , 

.如果真 (或者 (小于 (输入字节, 3), 大于 (输入字节, 7)))
    返回 (“”)
.如果真结束
返回 (相加 (“tr”, 到文本 (输入字节)))


.子程序 取modrm文本_16, 文本型, , 
.参数 mod, 字节型, , 
.参数 rm, 字节型, , 

.局部变量 当前段前缀, 文本型, , , 

赋值 (当前段前缀, 段前缀)
赋值 (段前缀, “”)
.如果真 (等于 (当前段前缀, “”))
    .如果 (等于 (mod, 0))
        赋值 (当前段前缀, m00段前缀文本组_16 [相加 (rm, 1)])
    .否则
        赋值 (当前段前缀, m01段前缀文本组_16 [相加 (rm, 1)])
    .如果结束
    
.如果真结束
赋值 (当前段前缀, 相加 (当前段前缀, #_段分隔符))
.判断开始 (等于 (mod, 0))
    返回 (相加 (当前段前缀, modrm文本组_00_16 [相加 (rm, 1)]))
.判断 (等于 (mod, 1))
    返回 (相加 (当前段前缀, modrm文本组_01_16 [相加 (rm, 1)]))
.判断 (等于 (mod, 2))
    返回 (相加 (当前段前缀, modrm文本组_10_16 [相加 (rm, 1)]))
.默认
    
.判断结束
返回 (“*取值错误!*”)


.子程序 取modrm文本_32, 文本型, , 
.参数 mod, 字节型, , 
.参数 rm, 字节型, , 

.局部变量 当前段前缀, 文本型, , , 

赋值 (当前段前缀, 段前缀)
赋值 (段前缀, “”)
.如果真 (等于 (当前段前缀, “”))
    .如果 (等于 (mod, 0))
        赋值 (当前段前缀, m00段前缀文本组_32 [相加 (rm, 1)])
    .否则
        赋值 (当前段前缀, m01段前缀文本组_32 [相加 (rm, 1)])
    .如果结束
    
.如果真结束
赋值 (当前段前缀, 相加 (当前段前缀, #_段分隔符))
.判断开始 (等于 (mod, 0))
    返回 (相加 (当前段前缀, modrm文本组_00_32 [相加 (rm, 1)]))
.判断 (等于 (mod, 1))
    返回 (相加 (当前段前缀, modrm文本组_01_32 [相加 (rm, 1)]))
.判断 (等于 (mod, 2))
    返回 (相加 (当前段前缀, modrm文本组_10_32 [相加 (rm, 1)]))
.默认
    
.判断结束
返回 (“*取值错误!*”)


.子程序 eb取值文本, 文本型, , 
.参数 mod, 字节型, , 
.参数 rm, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 

.判断开始 (等于 (mod, 0))
    赋值 (返回文本, 相加 (#byte, 取modrm文本_16 (mod, rm)))
    .如果真 (等于 (rm, 6))
        代码转指令.取一个字 (x16)
        赋值 (返回文本, 相加 (#byte, 子文本替换 (取modrm文本_16 (mod, rm), “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
    .如果真结束
    
.判断 (等于 (mod, 1))
     ' 返回文本 ＝ “/b ” ＋ 取modrm文本(mod,rm)
    代码转指令.取一个字节 (x8)
    赋值 (返回文本, 相加 (#byte, 子文本替换 (取modrm文本_16 (mod, rm), “d8”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x8)), 2, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 2))
     ' 返回文本 ＝ “/b ” ＋ 取modrm文本(mod,rm)
    代码转指令.取一个字 (x16)
    赋值 (返回文本, 相加 (#byte, 子文本替换 (取modrm文本_16 (mod, rm), “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 3))
    赋值 (返回文本, reg8文本组 [相加 (rm, 1)])
.默认
    返回 (“”)
.判断结束
返回 (返回文本)


.子程序 ew取值文本, 文本型, , 
.参数 mod, 字节型, , 
.参数 rm, 字节型, , 

.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 
.局部变量 返回文本, 文本型, , , 

.判断开始 (等于 (mod, 0))
    赋值 (返回文本, 相加 (#word, 取modrm文本_16 (mod, rm)))
    .如果真 (等于 (rm, 6))
        代码转指令.取一个字 (x16)
        赋值 (返回文本, 相加 (#word, 子文本替换 (取modrm文本_16 (mod, rm), “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
    .如果真结束
    
.判断 (等于 (mod, 1))
    代码转指令.取一个字节 (x8)
    赋值 (返回文本, 相加 (#word, 子文本替换 (取modrm文本_16 (mod, rm), “d8”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x8)), 2, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 2))
    代码转指令.取一个字 (x16)
    赋值 (返回文本, 相加 (#word, 子文本替换 (取modrm文本_16 (mod, rm), “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 3))
    赋值 (返回文本, reg16文本组 [相加 (rm, 1)])
.默认
    返回 (“”)
.判断结束
返回 (返回文本)


.子程序 ed取值文本, 文本型, , 
.参数 mod, 字节型, , 
.参数 rm, 字节型, , 

.局部变量 x8, 字节型, , , 
.局部变量 x32, 整数型, , , 
.局部变量 返回文本, 文本型, , , 

.判断开始 (等于 (mod, 0))
    赋值 (返回文本, 相加 (#dword, 取modrm文本_32 (mod, rm)))
    .如果真 (等于 (rm, 5))
        代码转指令.取一个双字 (x32)
        赋值 (返回文本, 相加 (#dword, “[”, 调整文本长度_增加 (到小写 (取十六进制文本 (x32)), 8, “0”, 真), #_十六进制数据后缀, “]”))
        返回 (返回文本)
    .如果真结束
    .如果真 (等于 (rm, 4))
        赋值 (返回文本, sib取值 (mod))
    .如果真结束
    
.判断 (等于 (mod, 1))
    .如果真 (等于 (rm, 4))
        返回 (sib取值 (mod))
    .如果真结束
    代码转指令.取一个字节 (x8)
    赋值 (返回文本, 相加 (#dword, 子文本替换 (取modrm文本_32 (mod, rm), “d8”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x8)), 2, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 2))
    .如果真 (等于 (rm, 4))
        返回 (sib取值 (mod))
    .如果真结束
    代码转指令.取一个双字 (x32)
    赋值 (返回文本, 相加 (#dword, 子文本替换 (取modrm文本_32 (mod, rm), “d32”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x32)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 3))
    赋值 (返回文本, reg32文本组 [相加 (rm, 1)])
.默认
    返回 (“”)
.判断结束
返回 (返回文本)


.子程序 sib取值, 文本型, , 
.参数 mod, 字节型, , 

.局部变量 x8, 字节型, , , 
.局部变量 x32, 整数型, , , 
.局部变量 s, 字节型, , , 
.局部变量 s文本, 文本型, , , 
.局部变量 i, 字节型, , , 
.局部变量 i文本, 文本型, , , 
.局部变量 b, 字节型, , , 
.局部变量 b文本, 文本型, , , 
.局部变量 段前缀文本_局, 文本型, , , 
.局部变量 返回文本, 文本型, , , 

.如果真 (等于 (代码转指令.取一个字节 (x8), 假))
    返回 (“”)
.如果真结束
mod_reg_rm取值 (x8, s, i, b)
赋值 (i文本, 取reg32文本 (i))
赋值 (b文本, 取reg32文本 (b))
.如果真 (等于 (i, 4))
    返回 (“* 错误 *”)
.如果真结束
.如果 (等于 (s, 0))
    赋值 (s文本, “”)
.否则
    赋值 (s文本, s文本组 [相加 (s, 1)])
.如果结束
.判断开始 (等于 (mod, 0))
    赋值 (段前缀文本_局, m00段前缀文本组_32 [1])
    .如果 (等于 (b, 5))
        .如果真 (等于 (代码转指令.取一个双字 (x32), 假))
            返回 (“”)
        .如果真结束
        赋值 (返回文本, 相加 (段前缀文本_局, #_段分隔符, “[”, 调整文本长度_增加 (到小写 (取十六进制文本 (x32)), 8, “0”, 真), i文本, s文本, #_十六进制数据后缀, “]”))
    .否则
        赋值 (返回文本, 相加 (段前缀文本_局, #_段分隔符, “[”, b文本, “+”, i文本, “+”, s文本, “]”))
    .如果结束
    返回 (返回文本)
.判断 (等于 (mod, 1))
    .如果真 (等于 (代码转指令.取一个双字 (x8), 假))
        返回 (“”)
    .如果真结束
    赋值 (段前缀文本_局, m01段前缀文本组_32 [1])
    赋值 (返回文本, 相加 (段前缀文本_局, #_段分隔符, “[”, b文本, “+”, i文本, “+”, s文本, “+”, 调整文本长度_增加 (到小写 (取十六进制文本 (x8)), 8, “0”, 真), i文本, s文本, #_十六进制数据后缀, “]”))
.判断 (等于 (mod, 2))
    .如果真 (等于 (代码转指令.取一个双字 (x32), 假))
        返回 (“”)
    .如果真结束
    赋值 (段前缀文本_局, m01段前缀文本组_32 [1])
    赋值 (返回文本, 相加 (段前缀文本_局, #_段分隔符, “[”, b文本, “+”, i文本, “+”, s文本, “+”, 调整文本长度_增加 (到小写 (取十六进制文本 (x32)), 8, “0”, 真), i文本, s文本, #_十六进制数据后缀, “]”))
.默认
    
.判断结束
返回 (返回文本)


.子程序 ea取值文本_自定义, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 
.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 
.局部变量 返回文本, 文本型, , , 

赋值 (mod, mod取值 (输入字节))
赋值 (rm, rm取值 (输入字节))
.判断开始 (等于 (mod, 0))
    赋值 (返回文本, modrm文本组_00_16 [相加 (rm, 1)])
    .如果真 (等于 (rm, 6))
        代码转指令.取一个字 (x16)
        赋值 (返回文本, 子文本替换 (modrm文本组_00_16 [相加 (rm, 1)], “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真))
    .如果真结束
    
.判断 (等于 (mod, 1))
    代码转指令.取一个字节 (x8)
    赋值 (返回文本, 子文本替换 (modrm文本组_01_16 [相加 (rm, 1)], “d8”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x8)), 2, “0”, 真), #_十六进制数据后缀), 1, , 真))
.判断 (等于 (mod, 2))
    代码转指令.取一个字 (x16)
    赋值 (返回文本, 子文本替换 (modrm文本组_10_16 [相加 (rm, 1)], “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真))
.判断 (等于 (mod, 3))
    赋值 (返回文本, reg16文本组 [相加 (rm, 1)])
.默认
    返回 (“”)
.判断结束
返回 (返回文本)


.子程序 ea到文本_reg8_eb, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, 相加 (reg8文本组 [相加 (reg, 1)], #_参数分隔符, eb取值文本 (mod, rm)))
返回 (返回文本)


.子程序 ea到文本_eb_reg8, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, 相加 (eb取值文本 (mod, rm), #_参数分隔符, reg8文本组 [相加 (reg, 1)]))
返回 (返回文本)


.子程序 ea到文本_reg16_ew, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, 相加 (reg16文本组 [相加 (reg, 1)], #_参数分隔符, ew取值文本 (mod, rm)))
返回 (返回文本)


.子程序 ea到文本_ew_reg16, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, 相加 (ew取值文本 (mod, rm), #_参数分隔符, reg16文本组 [相加 (reg, 1)]))
返回 (返回文本)


.子程序 ea到文本_reg32_ed, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, 相加 (reg32文本组 [相加 (reg, 1)], #_参数分隔符, ed取值文本 (mod, rm)))
返回 (返回文本)


.子程序 ea到文本_ed_reg32, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, 相加 (ed取值文本 (mod, rm), #_参数分隔符, reg32文本组 [相加 (reg, 1)]))
返回 (返回文本)


.子程序 ea_n到文本_ed, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, ed取值文本 (mod, rm))
返回 (返回文本)


.子程序 ea_n到文本_ew, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, ew取值文本 (mod, rm))
返回 (返回文本)


.子程序 ea_n到文本_eb, 文本型, , 
.参数 输入字节, 字节型, , 

.局部变量 返回文本, 文本型, , , 
.局部变量 reg, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 rm, 字节型, , , 

mod_reg_rm取值 (输入字节, mod, reg, rm)
赋值 (返回文本, eb取值文本 (mod, rm))
返回 (返回文本)


.子程序 ea取值文本_mod_rm, 文本型, , 
.参数 mod, 字节型, , 
.参数 rm, 字节型, , 
.参数 操作数尺寸, 字节型, 可空, 1为字节,2为字,4为双字,以上为X字节

.局部变量 返回文本, 文本型, , , 
.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 
.局部变量 操作数前缀文本, 文本型, , , 
.局部变量 段前缀文本, 文本型, , , 

.如果真 (是否为空 (操作数尺寸))
    赋值 (操作数尺寸, 1)
.如果真结束
.如果 (或者 (等于 (操作数尺寸, 1), 等于 (操作数尺寸, 2), 等于 (操作数尺寸, 4)))
    赋值 (操作数前缀文本, 操作数尺寸文本组 [操作数尺寸])
.否则
    赋值 (操作数前缀文本, 相加 (“<”, 到文本 (操作数尺寸), “字节>”))
.如果结束
.如果 (等于 (mod, 0))
    赋值 (段前缀文本, m00段前缀文本组_16 [相加 (rm, 1)])
.否则
    赋值 (段前缀文本, m01段前缀文本组_16 [相加 (rm, 1)])
.如果结束
.如果真 (不等于 (段前缀, “”))
    赋值 (段前缀文本, 段前缀)
.如果真结束
赋值 (段前缀文本, 相加 (段前缀文本, #_段分隔符))
.判断开始 (等于 (mod, 0))
    赋值 (返回文本, 相加 (操作数前缀文本, 段前缀文本, modrm文本组_00_16 [相加 (rm, 1)]))
    .如果真 (等于 (rm, 6))
        代码转指令.取一个字 (x16)
        赋值 (返回文本, 相加 (操作数前缀文本, 段前缀文本, 子文本替换 (modrm文本组_00_16 [相加 (rm, 1)], “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
    .如果真结束
    
.判断 (等于 (mod, 1))
    代码转指令.取一个字节 (x8)
    赋值 (返回文本, 相加 (操作数前缀文本, 段前缀文本, 子文本替换 (modrm文本组_01_16 [相加 (rm, 1)], “d8”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x8)), 2, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 2))
    代码转指令.取一个字 (x16)
    赋值 (返回文本, 相加 (操作数前缀文本, 段前缀文本, 子文本替换 (modrm文本组_10_16 [相加 (rm, 1)], “d16”, 相加 (调整文本长度_增加 (到小写 (取十六进制文本 (x16)), 4, “0”, 真), #_十六进制数据后缀), 1, , 真)))
.判断 (等于 (mod, 3))
    赋值 (返回文本, reg8文本组 [相加 (rm, 1)])
.默认
    返回 (“”)
.判断结束
赋值 (段前缀, “”)
返回 (返回文本)


.子程序 取段前缀, 文本型, , 外部使用,取后即清空
.局部变量 前段前缀, 文本型, , , 

.如果真 (不等于 (段前缀, “”))
    赋值 (前段前缀, 段前缀)
    赋值 (段前缀, “”)
.如果真结束
返回 (前段前缀)


.子程序 置段前缀, 逻辑型, , 
.参数 新前缀, 文本型, , 

.如果真 (等于 (寻找文本 (#段前缀文本, 新前缀, 1, 假), -1))
    返回 (假)
.如果真结束
赋值 (段前缀, 新前缀)
返回 (真)


.程序集 代码转指令子程序集, , , 

.程序集变量 错误文本, 文本型, , , 
.程序集变量 是否32位, 逻辑型, , , 
.程序集变量 是否正确, 逻辑型, , , 
.子程序 取错误提示文本_子, 文本型, , 发生错误取错误文本
返回 (错误文本)


.子程序 置操作尺寸, 空白型, , 真为32位，假为16位，默认为假
.参数 置操作尺寸位_局, 逻辑型, , 

赋值 (是否32位, 置操作尺寸位_局)


.子程序 代码转指令_子程序, 逻辑型, 公开, 
.参数 子程序指针, 整数型, , 
.参数 返回文本, 文本型, 参考, 

.局部变量 文本信息, 文本型, , , 

赋值 (文本信息, “”)
赋值 (是否正确, 真)
.如果真 (等于 (调用子程序 (子程序指针, , 文本信息, ), 假))
    返回 (假)
.如果真结束
赋值 (返回文本, 文本信息)
返回 (是否正确)


.子程序 子程序1, 文本型, , 返回解译指令文本,如果错误为空
.局部变量 i, 字节型, , , 

 ' 00 ea : add eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].本节指令长度 ＝ 2

赋值 (是否正确, 代码转指令.取一个字节 (i))
返回 (相加 (#_add, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (i)))


.子程序 子程序2, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 指令文本_集, 文本型, , , 

 ' 01 ea : add ed,reg32  *
 ' =====================
 ' '输出指令结构 [目前指令行数].w位 ＝ 1
 ' '输出指令结构 [目前指令行数].d位 ＝ 0

赋值 (是否正确, 代码转指令.取一个字节 (i))
.如果 (是否32位)
    返回 (相加 (#_add, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (i)))
.否则
    返回 (相加 (#_add, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (i)))
.如果结束



.子程序 子程序3, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 02 ea : add reg8,eb
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_add, #指令分隔符, 寻址判断.ea到文本_reg8_eb (i)))


.子程序 子程序4, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 03 ea : add reg32,ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (i)
.如果 (是否32位)
    返回 (相加 (#_add, #指令分隔符, 寻址判断.ea到文本_reg32_ed (i)))
.否则
    返回 (相加 (#_add, #指令分隔符, 寻址判断.ea到文本_reg16_ew (i)))
.如果结束


.子程序 子程序5, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 04 data8 : add al,data8
 ' =========================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_add, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序6, 文本型, , 
.局部变量 i16, 短整数型, , , 
.局部变量 i32, 整数型, , , 

 ' 05 data32 : add eax,data32  *
 ' ===========================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 返回( “add eax"+#_参数分隔符

.如果 (是否32位)
    代码转指令.取一个双字 (i32)
    返回 (相加 (#_add, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (i32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (i16)
    返回 (相加 (#_add, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (i16)), #_十六进制数据后缀))
.如果结束


.子程序 子程序7, 文本型, , 
 ' 06 : push es  *
 ' ==================
返回 (相加 (#_push, #指令分隔符, #__es))


.子程序 子程序8, 文本型, , 
 ' 07 : pop es  *
 ' ================
返回 (相加 (#_pop, #指令分隔符, #__es))


.子程序 子程序9, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 08 ea : or eb,reg8
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_or, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (i)))


.子程序 子程序10, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 09 ea : or ed,reg32  *
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
.如果 (是否32位)
    返回 (相加 (#_or, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (i)))
.否则
    返回 (相加 (#_or, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (i)))
.如果结束


.子程序 子程序11, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 0a ea : or reg8,eb
 ' =======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_or, #指令分隔符, 寻址判断.ea到文本_reg8_eb (i)))


.子程序 子程序12, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 0b ea : or reg32,ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
.如果 (是否32位)
    返回 (相加 (#_or, #指令分隔符, 寻址判断.ea到文本_reg32_ed (i)))
.否则
    返回 (相加 (#_or, #指令分隔符, 寻址判断.ea到文本_reg16_ew (i)))
.如果结束


.子程序 子程序13, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 0c data8 : or al,data8
 ' ========================

代码转指令.取一个字节 (i)
返回 (相加 (#_or, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序14, 文本型, , 
.局部变量 i16, 短整数型, , , 
.局部变量 i32, 整数型, , , 

 ' 0d data32 : or eax,data32
 ' ===========================

.如果 (是否32位)
    代码转指令.取一个字 (i32)
    返回 (相加 (#_or, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (i32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (i16)
    返回 (相加 (#_or, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (i16)), #_十六进制数据后缀))
.如果结束


.子程序 子程序15, 文本型, , 
 ' 0e : push cs  *
 ' ===============
返回 (相加 (#_push, #指令分隔符, #__cs))


.子程序 子程序16, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 
.局部变量 指令文本_集, 文本型, , , 

 ' 0f

代码转指令.取一个字节 (i)
.判断开始 (等于 (i, 0)) ' 0f 00 ea
    代码转指令.取一个字节 (x8)
    赋值 (i, 寻址判断.reg取值 (x8))
    .判断开始 (等于 (i, 0)) ' 0f 00 ea/0 : sldt ew
        返回 (相加 (#_sldt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 1)) ' 0f 00 ea/1 : str ew
        返回 (相加 (#_str, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 2)) ' 0f 00 ea/2 : lldt ew
        返回 (相加 (#_lldt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 3)) ' 0f 00 ea/3 : ltr ew
        返回 (相加 (#_ltr, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 4)) ' 0f 00 ea/4 : verr ew
        返回 (相加 (#_verr, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 5)) ' 0f 00 ea/5 : verw ew
        返回 (相加 (#_verw, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .默认
        
    .判断结束
    
.判断 (等于 (i, 1)) ' 0f 01 ea
    代码转指令.取一个字节 (x8)
    赋值 (i, 寻址判断.reg取值 (x8))
    .判断开始 (等于 (i, 0)) ' 0f 01 ea/0
        返回 (相加 (#_sgdt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 1)) ' 0f 01 ea/1
        返回 (相加 (#_sidt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 2)) ' 0f 01 ea/2
        返回 (相加 (#_lgdt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 3)) ' 0f 01 ea/3
        返回 (相加 (#_lidt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 4)) ' 0f 01 ea/4
        返回 (相加 (#_smsw, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 6)) ' 0f 01 ea/6
        返回 (相加 (#_lmsw, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .判断 (等于 (i, 7)) ' 0f 01 ea/6
        返回 (相加 (#_invlpg, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
    .默认
        
    .判断结束
    
.判断 (等于 (i, 2))
     ' 判断 (当前指令.代码2 ＝ 2)  ' 0f 02 ea * : lar reg32,ew
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_lar, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 3))
     ' 判断 (当前指令.代码2 ＝ 3)  ' 0f 03 ea  * : lsl reg32,ew
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_lsl, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 6))
     ' 判断 (当前指令.代码2 ＝ 6)  ' 0f 06 : clts
    返回 (#_clts)
.判断 (等于 (i, 8))
     ' 判断 (当前指令.代码2 ＝ 8)  ' 0f 08
    返回 (#_invd)
.判断 (等于 (i, 9))
     ' 判断 (当前指令.代码2 ＝ 9)  ' 0f 09
    返回 (#_wbinvd)
.判断 (等于 (i, 16))
     ' 判断 (当前指令.代码2 ＝ 16)  ' 0f 10 ea : invlpg ea(ew)
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_invlpg, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 32))
     ' 判断 (当前指令.代码2 ＝ 32)  ' 0f 20 -/n/reg : mov crn,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_mov, #指令分隔符, 寻址判断.取crn文本 (寻址判断.reg取值 (x8)), #_参数分隔符, 寻址判断.取reg16文本 (寻址判断.rm取值 (x8))))
.判断 (等于 (i, 33))
     ' 判断 (当前指令.代码2 ＝ 33)  ' 0f 21 -/n/reg : mov drn,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_mov, #指令分隔符, 寻址判断.取drn文本 (寻址判断.reg取值 (x8)), #_参数分隔符, 寻址判断.取reg16文本 (寻址判断.rm取值 (x8))))
.判断 (等于 (i, 34))
     ' 判断 (当前指令.代码2 ＝ 34)  ' 0f 22 -/n/reg : mov reg32,crn
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_mov, #指令分隔符, 寻址判断.取reg16文本 (寻址判断.rm取值 (x8)), #_参数分隔符, 寻址判断.取crn文本 (寻址判断.reg取值 (x8))))
.判断 (等于 (i, 35))
     ' 判断 (当前指令.代码2 ＝ 35)  ' 0f 23 -/n/reg : mov reg32,drn
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_mov, #指令分隔符, 寻址判断.取reg16文本 (寻址判断.rm取值 (x8)), #_参数分隔符, 寻址判断.取drn文本 (寻址判断.reg取值 (x8))))
.判断 (等于 (i, 36))
     ' 判断 (当前指令.代码2 ＝ 36)  ' 0f 24 -/n/reg : mov trn,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_mov, #指令分隔符, 寻址判断.取trn文本 (寻址判断.reg取值 (x8)), #_参数分隔符, 寻址判断.取reg16文本 (寻址判断.rm取值 (x8))))
.判断 (等于 (i, 38))
     ' 判断 (当前指令.代码2 ＝ 38)  ' 0f 26 -/n/reg : mov reg32,trn
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_mov, #指令分隔符, 寻址判断.取reg16文本 (寻址判断.rm取值 (x8)), #_参数分隔符, 寻址判断.取trn文本 (寻址判断.reg取值 (x8))))
.判断 (等于 (i, 128))
     ' 判断 (当前指令.代码2 ＝ 128)  ' 0f 80 disp32  * : jo disp32
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jo, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 129))
     ' 判断 (当前指令.代码2 ＝ 129)  ' 0f 81 disp32  * : jno disp32
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jno, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 130))
     ' 判断 (当前指令.代码2 ＝ 130)  ' 0f 82 disp32  * : jb disp32(jb/jne)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jb, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 131))
     ' 判断 (当前指令.代码2 ＝ 131)  ' 0f 83 disp32  * : jnb disp32(jnb/jae)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jnb, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 132))
     ' 判断 (当前指令.代码2 ＝ 132)  ' 0f 84 disp32  * : jz disp32(jz/je)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jz, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 133))
     ' 判断 (当前指令.代码2 ＝ 133)  ' 0f 85 disp32  * : jnz disp32(jnz/jne)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jnz, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 134))
     ' 判断 (当前指令.代码2 ＝ 134)  ' 0f 86 disp32  * : jbe disp32(jbe/jna)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jbe, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 135))
     ' 判断 (当前指令.代码2 ＝ 135)  ' 0f 87 disp32  * : jnbe disp32(jnbe/ja)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jnbe, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 136))
     ' 判断 (当前指令.代码2 ＝ 136)  ' 0f 88 disp32  * : js disp32
    代码转指令.取一个字 (x16)
    返回 (相加 (#_js, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 137))
     ' 判断 (当前指令.代码2 ＝ 137)  ' 0f 89 disp32  * : jns disp32
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jns, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 138))
     ' 判断 (当前指令.代码2 ＝ 138)  ' 0f 8a disp32  * : jp disp32(jp/jpe)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jp, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 139))
     ' 判断 (当前指令.代码2 ＝ 139)  ' 0f 8b disp32  * : jnp disp32(jnp/jpo)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jnp, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 140))
     ' 判断 (当前指令.代码2 ＝ 140)  ' 0f 8c disp32  * : jl disp32(jl/jnge)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jl, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 141))
     ' 判断 (当前指令.代码2 ＝ 141)  ' 0f 8d disp32  * : jnl disp32(jnl/jge)
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jnl, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 142))
     ' 判断 (当前指令.代码2 ＝ 142)  ' 0f 8e disp32  *
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jle, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 143))
     ' 判断 (当前指令.代码2 ＝ 143)  ' 0f 8f disp32  *
    代码转指令.取一个字 (x16)
    返回 (相加 (#_jnle, #指令分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 144))
     ' 判断 (当前指令.代码2 ＝ 144)  ' 0f 90 ea  * : seto eb
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_seto, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 145))
     ' 判断 (当前指令.代码2 ＝ 145)  ' 0f 91 ea : setno eb
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setno, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 146))
     ' 判断 (当前指令.代码2 ＝ 146)  ' 0f 92 ea : setb eb(setb/setnae/setc)
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setb, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 147))
     ' 判断 (当前指令.代码2 ＝ 147)  ' 0f 93 ea : setnb eb(setnb/setae/setnc)
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setae, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 148))
     ' 判断 (当前指令.代码2 ＝ 148)  ' 0f 94 ea : setz eb (setz/sete)
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_sete, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 149))
     ' 判断 (当前指令.代码2 ＝ 149)  ' 0f 95 ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setnz, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 150))
     ' 判断 (当前指令.代码2 ＝ 150)  ' 0f 96 ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setbe, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 151))
     ' 判断 (当前指令.代码2 ＝ 151)  ' 0f 97 ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_seta, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 152))
     ' 判断 (当前指令.代码2 ＝ 152)  ' 0f 98 ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_sets, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 153))
     ' 判断 (当前指令.代码2 ＝ 153)  ' 0f 99 ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setns, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 154))
     ' 判断 (当前指令.代码2 ＝ 154)  ' 0f 9a ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setp, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 155))
     ' 判断 (当前指令.代码2 ＝ 155)  ' 0f 9b ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setnp, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 156))
     ' 判断 (当前指令.代码2 ＝ 156)  ' 0f 9c ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setl, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 157))
     ' 判断 (当前指令.代码2 ＝ 157)  ' 0f 9d ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setge, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 158))
     ' 判断 (当前指令.代码2 ＝ 158)  ' 0f 9e ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setle, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 159))
     ' 判断 (当前指令.代码2 ＝ 159)  ' 0f 9f ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_setg, #指令分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 160))
     ' 判断 (当前指令.代码2 ＝ 160)  ' 0f a0  *
    返回 (相加 (#_push, #指令分隔符, #__fs))
.判断 (等于 (i, 161))
     ' 判断 (当前指令.代码2 ＝ 161)  ' 0f a1  *
    返回 (相加 (#_pop, #指令分隔符, #__fs))
.判断 (等于 (i, 163))
     ' 判断 (当前指令.代码2 ＝ 163)  ' 0f a3 ea  * : bt ed,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_bt, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
.判断 (等于 (i, 164))
     ' 判断 (当前指令.代码2 ＝ 164)  ' 0f a4 ea data8 * : shld ed,reg32,data8
    代码转指令.取一个字节 (x8)
    赋值 (指令文本_集, 相加 (#_shld, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
    代码转指令.取一个字节 (x8)
    返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x8)), #_十六进制数据后缀))
.判断 (等于 (i, 165))
     ' 判断 (当前指令.代码2 ＝ 165)  ' 0f a5 ea  *shld ed,reg32,cl
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_shld, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8), #_参数分隔符, “cl”))
.判断 (等于 (i, 166))
     ' 判断 (当前指令.代码2 ＝ 166)  ' 0f a6 ea : cmpxchg eb,reg8
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_cmpxchg, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x8)))
.判断 (等于 (i, 167))
     ' 判断 (当前指令.代码2 ＝ 167)  ' 0f a7 ea: cmpxchg ed,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_cmpxchg, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
.判断 (等于 (i, 168))
     ' 判断 (当前指令.代码2 ＝ 168)  ' 0f a8  *
    返回 (相加 (#_push, #指令分隔符, #__gs))
.判断 (等于 (i, 169))
     ' 判断 (当前指令.代码2 ＝ 169)  ' 0f a9  *
    返回 (相加 (#_pop, #指令分隔符, #__gs))
.判断 (等于 (i, 171))
     ' 判断 (当前指令.代码2 ＝ 170)  ' 0f ab ea  * : bts ed,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_bts, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
.判断 (等于 (i, 172))
     ' 判断 (当前指令.代码2 ＝ 172)  ' 0f ac ea data8  * : shrd ed,reg32,data8
    代码转指令.取一个字节 (x8)
    赋值 (指令文本_集, 相加 (#_shrd, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
    代码转指令.取一个字节 (x8)
    返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x8)), #_十六进制数据后缀))
.判断 (等于 (i, 173))
     ' 判断 (当前指令.代码2 ＝ 173)  ' 0f ad ea  * : shrd ed,reg32,cl
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_shrd, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8), #_参数分隔符, “cl”))
.判断 (等于 (i, 175))
     ' 判断 (当前指令.代码2 ＝ 175)  ' 0f af ea  * : imul reg32,ed
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_imul, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 176)) ' 0f b0 ea : cmpxchg eb,reg8
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_cmpxchg, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x8)))
.判断 (等于 (i, 177)) ' 0f b1 ea * : cmpxchg ed,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_cmpxchg, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
.判断 (等于 (i, 178))
     ' 判断 (当前指令.代码2 ＝ 178)  ' 0f b2 ea  * : lss reg32,ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_lss, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 179))
     ' 判断 (当前指令.代码2 ＝ 179)  ' 0f b3 ea  * : btr ed,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_btr, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
.判断 (等于 (i, 180))
     ' 判断 (当前指令.代码2 ＝ 180)  ' 0f b4 ea  * : lfs reg32,ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_lfs, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 181))
     ' 判断 (当前指令.代码2 ＝ 181)  ' 0f b5 ea  * : lgs reg32,ea
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_lgs, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 182))
     ' 判断 (当前指令.代码2 ＝ 182)  ' 0f b6 ea  * : movzx reg32,eb
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_movzx, #指令分隔符, 寻址判断.取reg16文本 (寻址判断.reg取值 (x8)), #_参数分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 183))
     ' 判断 (当前指令.代码2 ＝ 183)  ' 0f b7 ea  * : movzx reg32,ew
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_movzx, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 186))
     ' 判断 (当前指令.代码2 ＝ 186)  ' 0f ba ea  *
     ' ea/4 5 6 ,data
    代码转指令.取一个字节 (x8)
    赋值 (i, 寻址判断.reg取值 (x8))
    .判断开始 (等于 (i, 4)) ' 0f ba ea/4 data8 : bt ed,data8
        赋值 (指令文本_集, 相加 (#_bt, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
        代码转指令.取一个字节 (x8)
        返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x8)), #_十六进制数据后缀))
    .判断 (等于 (i, 5)) ' 0f ba ea/5 data8 : bts ed,data8
        赋值 (指令文本_集, 相加 (#_bts, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
        代码转指令.取一个字节 (x8)
        返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x8)), #_十六进制数据后缀))
    .判断 (等于 (i, 6)) ' 0f ba ea/6 data8 : btr ed,data8
        赋值 (指令文本_集, 相加 (#_btr, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
        代码转指令.取一个字节 (x8)
        返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x8)), #_十六进制数据后缀))
    .判断 (等于 (i, 7)) ' 0f ba ea/7 data8 : btc ed,data8
        赋值 (指令文本_集, 相加 (#_btc, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
        代码转指令.取一个字节 (x8)
        返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x8)), #_十六进制数据后缀))
    .默认
        
    .判断结束
    
.判断 (等于 (i, 187))
     ' 判断 (当前指令.代码2 ＝ 187)  ' 0f bb ea  * : btc ed,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_btc, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x8)))
.判断 (等于 (i, 188))
     ' 判断 (当前指令.代码2 ＝ 188)  ' 0f bc ea  * : bsf reg32,ed
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_bsf, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 189))
     ' 判断 (当前指令.代码2 ＝ 189)  ' 0f bd ea  * : bsr reg32,ed
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_bsr, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 190))
     ' 判断 (当前指令.代码2 ＝ 190)  ' 0f be ea  * : movsx reg32,eb
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_movsx, #指令分隔符, 寻址判断.取reg16文本 (寻址判断.reg取值 (x8)), #_参数分隔符, 寻址判断.ea_n到文本_eb (x8)))
.判断 (等于 (i, 191))
     ' 判断 (当前指令.代码2 ＝ 191)  ' 0f bf ea  * : movsx reg32,ew
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_movsx, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
.判断 (等于 (i, 192))
     ' 判断 (当前指令.代码2 ＝ 192)  ' 0f c0 ea : xadd eb,reg8
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_xadd, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x8)))
.判断 (等于 (i, 193))
     ' 判断 (当前指令.代码2 ＝ 193)  ' 0f c1 ea : xadd eb,reg32
    代码转指令.取一个字节 (x8)
    返回 (相加 (#_xadd, #指令分隔符, 寻址判断.ea_n到文本_eb (x8), #_参数分隔符, 寻址判断.取reg16文本 (寻址判断.reg取值 (x8))))
.判断 (等于 (i, 200))
     ' 判断 (当前指令.代码2 ＝ 200)  ' 0f c8 : bswap eax
    返回 (相加 (#_bswap, #指令分隔符, “ax”))
.判断 (等于 (i, 201))
     ' 判断 (当前指令.代码2 ＝ 201)  ' 0f c9 : bswap ecx
    返回 (相加 (#_bswap, #指令分隔符, “cx”))
.判断 (等于 (i, 202))
     ' 判断 (当前指令.代码2 ＝ 202)  ' 0f ca : bswap edx
    返回 (相加 (#_bswap, #指令分隔符, “dx”))
.判断 (等于 (i, 203))
     ' 判断 (当前指令.代码2 ＝ 203)  ' 0f cb : bswap ebx
    返回 (相加 (#_bswap, #指令分隔符, “bx”))
.判断 (等于 (i, 204))
     ' 判断 (当前指令.代码2 ＝ 204)  ' 0f cc : bswap esp
    返回 (相加 (#_bswap, #指令分隔符, “sp”))
.判断 (等于 (i, 205))
     ' 判断 (当前指令.代码2 ＝ 205)  ' 0f cd : bswap ebp
    返回 (相加 (#_bswap, #指令分隔符, “bp”))
.判断 (等于 (i, 206))
     ' 判断 (当前指令.代码2 ＝ 206)  ' 0f ce : bswap esi
    返回 (相加 (#_bswap, #指令分隔符, “si”))
.判断 (等于 (i, 207))
     ' 判断 (当前指令.代码2 ＝ 207)  ' 0f cf : bswap edi
    返回 (相加 (#_bswap, #指令分隔符, “di”))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序17, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 10 ea : adc eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_adc, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x)))


.子程序 子程序18, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 11 ea : adc ed,reg32  *
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 0
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_adc, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (x)))
.否则
    返回 (相加 (#_adc, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x)))
.如果结束



.子程序 子程序19, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 12 ea : adc reg8,eb
 ' =====================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_adc, #指令分隔符, 寻址判断.ea到文本_reg8_eb (x)))


.子程序 子程序20, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 13 ea : adc reg32,ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].d位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_adc, #指令分隔符, 寻址判断.ea到文本_reg32_ed (x)))
.否则
    返回 (相加 (#_adc, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
.如果结束



.子程序 子程序21, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 14 data8 : adc al,data8
 ' ==========================

代码转指令.取一个字节 (x)
返回 (相加 (#_adc, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序22, 文本型, , 
.局部变量 x16, 短整数型, , , 
.局部变量 x32, 整数型, , , 

 ' 15 data32 : adc eax,data32  *
 ' =============================

.如果 (是否32位)
    代码转指令.取一个字 (x32)
    返回 (相加 (#_adc, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (x32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (x16)
    返回 (相加 (#_adc, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.如果结束


.子程序 子程序23, 文本型, , 
 ' 16 : push ss  *
 ' ==============
返回 (相加 (#_push, #指令分隔符, #__ss))



.子程序 子程序24, 文本型, , 
 ' 17 : pop ss  *
 ' ==============
返回 (相加 (#_pop, #指令分隔符, #__ss))



.子程序 子程序25, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 18 ea : sbb eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_sbb, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x)))



.子程序 子程序26, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 19 ea : sbb ed,reg32  *
 ' =======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_sbb, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (x)))
.否则
    返回 (相加 (#_sbb, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x)))
.如果结束



.子程序 子程序27, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 1a ea : sbb reg8,eb
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
返回 (相加 (#_sbb, #指令分隔符, 寻址判断.ea到文本_reg8_eb (x)))



.子程序 子程序28, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 1b ea : sbb reg32,ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_sbb, #指令分隔符, 寻址判断.ea到文本_reg32_ed (x)))
.否则
    返回 (相加 (#_sbb, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
.如果结束



.子程序 子程序29, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 1c data8 : sbb al,data8
 ' =========================

代码转指令.取一个字节 (x)
返回 (相加 (#_sbb, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序30, 文本型, , 
.局部变量 x16, 短整数型, , , 
.局部变量 x32, 整数型, , , 

 ' 1d data32 : sbb eax,data32  *
 ' ===========================

.如果 (是否32位)
    代码转指令.取一个字 (x32)
    返回 (相加 (#_sbb, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (x32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (x16)
    返回 (相加 (#_sbb, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.如果结束



.子程序 子程序31, 文本型, , 
 ' 1e : push ds  *
 ' ===============
返回 (相加 (#_push, #指令分隔符, #__ds))


.子程序 子程序32, 文本型, , 
 ' 1f : pop ds  *
 ' =============
返回 (相加 (#_pop, #指令分隔符, #__ds))


.子程序 子程序33, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 20 ea : and eb,reg8
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_and, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x)))



.子程序 子程序34, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 21 ea : and ed,reg32  *
 ' ========================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_and, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (x)))
.否则
    返回 (相加 (#_and, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x)))
.如果结束



.子程序 子程序35, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 22 ea : and reg8,eb
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
返回 (相加 (#_and, #指令分隔符, 寻址判断.ea到文本_reg8_eb (x)))



.子程序 子程序36, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 23 ea : and reg32,ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_and, #指令分隔符, 寻址判断.ea到文本_reg32_ed (x)))
.否则
    返回 (相加 (#_and, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
.如果结束



.子程序 子程序37, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 24 data8 : and al,data8
 ' ===========================

代码转指令.取一个字节 (x)
返回 (相加 (#_and, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序38, 文本型, , 
.局部变量 x16, 短整数型, , , 
.局部变量 x32, 整数型, , , 

 ' 25 data32 : and eax,data32  *
 ' ===========================

.如果 (是否32位)
    代码转指令.取一个字 (x32)
    返回 (相加 (#_and, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (x32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (x16)
    返回 (相加 (#_and, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.如果结束



.子程序 子程序39, 文本型, , 
 ' 26 : es:
 ' ==============
寻址判断.置段前缀 (#__es)
返回 (“;<es段>”)



.子程序 子程序40, 文本型, , 
 ' 27 : daa
 ' ===========
返回 (#_daa)


.子程序 子程序41, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 28 ea : sub eb,reg8
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_sub, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x)))



.子程序 子程序42, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 29 ea : sub ed,reg32  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_sub, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (x)))
.否则
    返回 (相加 (#_sub, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x)))
.如果结束



.子程序 子程序43, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 2a ea : sub reg8,eb
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
返回 (相加 (#_sub, #指令分隔符, 寻址判断.ea到文本_reg8_eb (x)))



.子程序 子程序44, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 2b ea : sub reg32,ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_sub, #指令分隔符, 寻址判断.ea到文本_reg32_ed (x)))
.否则
    返回 (相加 (#_sub, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
.如果结束



.子程序 子程序45, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 2c data8 : sub al,data8
 ' ===========================

代码转指令.取一个字节 (x)
返回 (相加 (#_sub, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序46, 文本型, , 
.局部变量 x16, 短整数型, , , 
.局部变量 x32, 整数型, , , 

 ' 2d data32 : sub eax,data32  *
 ' ============================

.如果 (是否32位)
    代码转指令.取一个字 (x32)
    返回 (相加 (#_sub, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (x32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (x16)
    返回 (相加 (#_sub, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.如果结束



.子程序 子程序47, 文本型, , 
 ' 2e : cs:
 ' ===========
寻址判断.置段前缀 (#__cs)
返回 (“;<代码段>”)


.子程序 子程序48, 文本型, , 
 ' 2f : das
 ' ==============
返回 (#_das)


.子程序 子程序49, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 30 ea : xor eb,reg8
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_xor, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x)))



.子程序 子程序50, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 31 ea : xor ed,reg32  *
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_xor, #指令分隔符, 寻址判断.ea到文本_reg32_ed (x)))
.否则
    返回 (相加 (#_xor, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
.如果结束



.子程序 子程序51, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 32 ea : xor reg8,eb
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
返回 (相加 (#_xor, #指令分隔符, 寻址判断.ea到文本_reg8_eb (x)))



.子程序 子程序52, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 33 ea : xor reg32,ed  *
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_xor, #指令分隔符, 寻址判断.ea到文本_reg32_ed (x)))
.否则
    返回 (相加 (#_xor, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
.如果结束



.子程序 子程序53, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 34 data8 : xor al,data8
 ' =========================

代码转指令.取一个字节 (x)
返回 (相加 (#_xor, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序54, 文本型, , 
.局部变量 x16, 短整数型, , , 
.局部变量 x32, 整数型, , , 

 ' 35 data32 : xor eax,data32  *
 ' ===========================

.如果 (是否32位)
    代码转指令.取一个字 (x32)
    返回 (相加 (#_xor, #指令分隔符, “eax”, #_参数分隔符, 到小写 (取十六进制文本 (x32)), #_十六进制数据后缀))
.否则
    代码转指令.取一个字 (x16)
    返回 (相加 (#_xor, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.如果结束



.子程序 子程序55, 文本型, , 
 ' 36 : ss
 ' ===========
寻址判断.置段前缀 (#__ss)
返回 (“;<ss:>”)


.子程序 子程序56, 文本型, , 
 ' 37 : aaa
 ' ============
返回 (#_aaa)


.子程序 子程序57, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 38 ea : cmp eb,reg8
 ' ====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_cmp, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (x)))



.子程序 子程序58, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 39 ea : cmp ed,reg32  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
.如果 (是否32位)
    返回 (相加 (#_cmp, #指令分隔符, 寻址判断.ea到文本_ed_reg32 (x)))
.否则
    返回 (相加 (#_cmp, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x)))
.如果结束



.子程序 子程序59, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 3a ea : cmp reg8,eb
 ' ======================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

赋值 (是否正确, 代码转指令.取一个字节 (x))
返回 (相加 (#_cmp, #指令分隔符, 寻址判断.ea到文本_reg8_eb (x)))



.子程序 子程序60, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 3b ea : cmp reg32,ed  *
 ' =====================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (x)
返回 (相加 (#_cmp, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))



.子程序 子程序61, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 3c data8 : cmp data8
 ' ===================

代码转指令.取一个字节 (x)
返回 (相加 (#_cmp, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序62, 文本型, , 
.局部变量 x, 短整数型, , , 

 ' 3d data32 : cmp data32  *
 ' ========================

代码转指令.取一个字 (x)
返回 (相加 (#_cmp, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序63, 文本型, , 
 ' 3e : ds:
 ' ============
寻址判断.置段前缀 (#__ds)
返回 (“;<ds:>”)



.子程序 子程序64, 文本型, , 
 ' 3f : aas
 ' ===========
返回 (#_aas)


.子程序 子程序65, 文本型, , 
 ' 40 : inc eax  *
 ' ===============
返回 (相加 (#_inc, #指令分隔符, “ax”))


.子程序 子程序66, 文本型, , 
 ' 41 : inc ecx  *
 ' =================
返回 (相加 (#_inc, #指令分隔符, “cx”))


.子程序 子程序67, 文本型, , 
 ' 42 : inc edx  *
 ' ==============
返回 (相加 (#_inc, #指令分隔符, “dx”))


.子程序 子程序68, 文本型, , 
 ' 43 : inc ebx  *
 ' ===============
返回 (相加 (#_inc, #指令分隔符, “bx”))


.子程序 子程序69, 文本型, , 
 ' 44 : inc esp  *
 ' ==============
返回 (相加 (#_inc, #指令分隔符, “sp”))


.子程序 子程序70, 文本型, , 
 ' 45 : inc ebp  *
 ' ==============
返回 (相加 (#_inc, #指令分隔符, “bp”))


.子程序 子程序71, 文本型, , 
 ' 46 : inc esi  *
 ' ==============
返回 (相加 (#_inc, #指令分隔符, “si”))


.子程序 子程序72, 文本型, , 
 ' 47 : inc edi  *
 ' ===============
返回 (相加 (#_inc, #指令分隔符, “di”))


.子程序 子程序73, 文本型, , 
 ' 48 : dec eax  *
 ' ==============
返回 (相加 (#_dec, #指令分隔符, “ax”))


.子程序 子程序74, 文本型, , 
 ' 49 : dec ecx  *
 ' ==============
返回 (相加 (#_dec, #指令分隔符, “cx”))


.子程序 子程序75, 文本型, , 
 ' 4a : dec edx  *
 ' ==============
返回 (相加 (#_dec, #指令分隔符, “dx”))


.子程序 子程序76, 文本型, , 
 ' 4b : dec ebx  *
 ' ===============
返回 (相加 (#_dec, #指令分隔符, “bx”))


.子程序 子程序77, 文本型, , 
 ' 4c : dec esp  *
 ' ===============
返回 (相加 (#_dec, #指令分隔符, “sp”))


.子程序 子程序78, 文本型, , 
 ' 4d : dec ebp  *
 ' =============
返回 (相加 (#_dec, #指令分隔符, “bp”))


.子程序 子程序79, 文本型, , 
 ' 4e : dec esi  *
 ' ===================
返回 (相加 (#_dec, #指令分隔符, “si”))


.子程序 子程序80, 文本型, , 
 ' 4f : dec edi  *
 ' ==============
返回 (相加 (#_dec, #指令分隔符, “di”))


.子程序 子程序81, 文本型, , 
 ' 50 : push eax  *
 ' ===============
返回 (相加 (#_push, #指令分隔符, “ax”))


.子程序 子程序82, 文本型, , 
 ' 51 : push ecx  *
 ' ================
返回 (相加 (#_push, #指令分隔符, “cx”))


.子程序 子程序83, 文本型, , 
 ' 52 : push edx  *
 ' ==========================================
返回 (相加 (#_push, #指令分隔符, “dx”))


.子程序 子程序84, 文本型, , 
 ' 53 : push ebx  *
 ' ==========================================
返回 (相加 (#_push, #指令分隔符, “bx”))


.子程序 子程序85, 文本型, , 
 ' 54 : push esp  *
 ' ==========================================
返回 (相加 (#_push, #指令分隔符, “sp”))


.子程序 子程序86, 文本型, , 
 ' 55 : push ebp  *
 ' ==========================================
返回 (相加 (#_push, #指令分隔符, “bp”))


.子程序 子程序87, 文本型, , 
 ' 56 : push esi  *
 ' ==========================================
返回 (相加 (#_push, #指令分隔符, “si”))


.子程序 子程序88, 文本型, , 
 ' 57 : push edi  *
 ' ==========================================
返回 (相加 (#_push, #指令分隔符, “di”))


.子程序 子程序89, 文本型, , 
 ' 58 : pop eax  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “ax”))


.子程序 子程序90, 文本型, , 
 ' 59 : pop ecx  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “cx”))


.子程序 子程序91, 文本型, , 
 ' 5a : pop edx  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “dx”))


.子程序 子程序92, 文本型, , 
 ' 5b : pop ebx  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “bx”))


.子程序 子程序93, 文本型, , 
 ' 5c : pop esp  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “sp”))


.子程序 子程序94, 文本型, , 
 ' 5d : pop ebp  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “bp”))


.子程序 子程序95, 文本型, , 
 ' 5e : pop esi  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “si”))


.子程序 子程序96, 文本型, , 
 ' 5f : pop edi  *
 ' ==========================================
返回 (相加 (#_pop, #指令分隔符, “di”))


.子程序 子程序97, 文本型, , 
 ' 60 : pushad  *
 ' ==========================================
返回 (#_pushad)


.子程序 子程序98, 文本型, , 
 ' 61 : popad  *
 ' ==========================================
返回 (#_popad)


.子程序 子程序99, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 62 ea : bound reg32,ea  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
返回 (相加 (#_bound, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))



.子程序 子程序100, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 63 ea : arpl ew,reg16
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (x)
返回 (相加 (#_arpl, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (x)))



.子程序 子程序101, 文本型, , 
 ' 64 : fs:
 ' ==========================================
寻址判断.置段前缀 (#__fs)
返回 (“;<fs:>”)



.子程序 子程序102, 文本型, , 
 ' 65 : gs:
 ' ==========================================
寻址判断.置段前缀 (#__gs)
返回 (“;<gs:>”)



.子程序 子程序103, 文本型, , 
 ' 66 : opsiz:
 ' ==========================================
返回 (#_opsiz)


.子程序 子程序104, 文本型, , 
 ' 67 : adrsiz:
 ' ==========================================
返回 (#_adrsiz)


.子程序 子程序105, 文本型, , 
.局部变量 x, 短整数型, , , 

 ' 68 data32 : push data32  *
 ' ==========================================

代码转指令.取一个字 (x)
返回 (相加 (#_push, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序106, 文本型, , 
.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 
.局部变量 指令文本_集, 文本型, , , 

 ' 69 ea data32 : imul reg32,ed,data32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x8)
赋值 (指令文本_集, 相加 (#_imul, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x8)))
代码转指令.取一个字 (x16)
返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))



.子程序 子程序107, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 6a data8 : push data8
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_push, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序108, 文本型, , 
.局部变量 x, 字节型, , , 
.局部变量 指令文本_集, 文本型, , , 

 ' 6b ea data8 : imul reg32,ed,data8  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (x)
赋值 (指令文本_集, 相加 (#_imul, #指令分隔符, 寻址判断.ea到文本_reg16_ew (x)))
代码转指令.取一个字节 (x)
返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序109, 文本型, , 
.局部变量 段前缀, 文本型, , , 

 ' 6c : insb byte ptr es:[edi],dx
 ' ==========================================

赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__ds)
.如果真结束
返回 (相加 (#_insb, #指令分隔符, #byte, 段前缀, #_段分隔符, “[di]”, #_参数分隔符, “dx”))



.子程序 子程序110, 文本型, , 
.局部变量 段前缀, 文本型, , , 

 ' 6d *: insd dword ptr es:[edi],dx
 ' ==========================================

赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__ds)
.如果真结束
返回 (相加 (#_insw, #指令分隔符, #byte, 段前缀, #_段分隔符, “[di]”, #_参数分隔符, “dx”))



.子程序 子程序111, 文本型, , 
.局部变量 段前缀, 文本型, , , 

 ' 6e : outsb dx,byte ptr es:[edi]
 ' ==========================================

赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__es)
.如果真结束
返回 (相加 (#_outsb, #指令分隔符, “dx”, #_参数分隔符, #byte, 段前缀, #_段分隔符, “[di]”))



.子程序 子程序112, 文本型, , 
.局部变量 段前缀, 文本型, , , 

 ' 6f *: outsd dx,dword ptr es:[edi]
 ' ==========================================

赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__es)
.如果真结束
返回 (相加 (#_outsw, #指令分隔符, “dx”, #_参数分隔符, #byte, 段前缀, #_段分隔符, “[di]”))



.子程序 子程序113, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 70 disp8 : jo disp8
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jo, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序114, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 71 disp8 : jno disp8
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jno, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序115, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 72 disp8 : jb disp8 (jb/jnae)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jb, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序116, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 73 disp8 : jnb disp8 (jnb/jae)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jnb, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序117, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 74 disp8 : jz disp8 (jz/je)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jz, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序118, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 75 disp8 : jnz disp8 (jnz/jne)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jnz, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序119, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 76 disp8 : jbe disp8 (jbe/jna)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jbe, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序120, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 77 disp8 : jnbe disp8 (jnbe/ja)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jnbe, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序121, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 78 disp8 : js disp8
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_js, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序122, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 79 disp8 : jns disp8
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jns, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序123, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 7a disp8 : jp disp8 (jp/jpe)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jp, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序124, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 7b disp8 : jnp disp8 (jnp/jpo)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jnp, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序125, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 7c disp8 : jl disp8 (jl/jnge)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jl, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序126, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 7d disp8 : jnl disp8 (jnl/jge)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jnl, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序127, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 7e disp8 : jle disp8 (jle/jng)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jle, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序128, 文本型, , 
.局部变量 x, 字节型, , , 

 ' 7f disp8 : jnle disp8 (jnle/jg)
 ' ==========================================

代码转指令.取一个字节 (x)
返回 (相加 (#_jnle, #指令分隔符, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))



.子程序 子程序129, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 
.局部变量 指令文本信息, 文本型, , , 

 ' 80

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 data8 : add eb,data8
    赋值 (指令文本信息, 相加 (#_add, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 1))
     ' ea/1 data8 : or eb,data8
    赋值 (指令文本信息, 相加 (#_or, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2 data8 adc eb,data8
    赋值 (指令文本信息, 相加 (#_adc, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 3))
     ' ea/3 data8 sbb eb,data8
    赋值 (指令文本信息, 相加 (#_sbb, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 4))
     ' ea/4 data8 and eb,data8
    赋值 (指令文本信息, 相加 (#_and, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 5))
     ' ea/5 data8 sub eb,data8
    赋值 (指令文本信息, 相加 (#_sub, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 6))
     ' ea/6 data8 xor eb,data8
    赋值 (指令文本信息, 相加 (#_xor, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 7))
     ' ea/7 data8 cmp eb,data8
    赋值 (指令文本信息, 相加 (#_cmp, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序130, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 x, 字节型, , , 
.局部变量 指令文本信息, 文本型, , , 

 ' 81  *

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 data8 add ed,data32  *
    赋值 (指令文本信息, 相加 (#_add, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 1))
     ' ea/1 data8 or ed,data32  *
    赋值 (指令文本信息, 相加 (#_or, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2 data8 adc ed,data32  *
    赋值 (指令文本信息, 相加 (#_adc, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 3))
     ' ea/3 data8 sbb ed,data32  *
    赋值 (指令文本信息, 相加 (#_sbb, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 4))
     ' ea/4 data8 and ed,data32  *
    赋值 (指令文本信息, 相加 (#_and, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 5))
     ' ea/5 data8 sub ed,data32  *
    赋值 (指令文本信息, 相加 (#_sub, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 6))
     ' ea/6 data8 xor ed,data32  *
    赋值 (指令文本信息, 相加 (#_xor, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 7))
     ' ea/7 data8 cmp ed,data32  *
    赋值 (指令文本信息, 相加 (#_cmp, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序131, 文本型, , 
 ' 82 为空
 ' ==========================================
返回 (“;*82* 错误！”)


.子程序 子程序132, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 
.局部变量 指令文本信息, 文本型, , , 

 ' 83  *

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 data8 add ed,data8  *
    赋值 (指令文本信息, 相加 (#_add, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 1))
     ' ea/1 data8 or ed,data8  *
    赋值 (指令文本信息, 相加 (#_or, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2 data8 adc ed,data8  *
    赋值 (指令文本信息, 相加 (#_adc, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 3))
     ' ea/3 data8 sbb ed,data8  *
    赋值 (指令文本信息, 相加 (#_sbb, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 4))
     ' ea/4 data8 and ed,data8  *
    赋值 (指令文本信息, 相加 (#_and, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 5))
     ' ea/5 data8 sub ed,data8  *
    赋值 (指令文本信息, 相加 (#_sub, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 6))
     ' ea/6 data8 xor ed,data8  *
    赋值 (指令文本信息, 相加 (#_xor, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 7))
     ' ea/7 data8 cmp ed,data8  *
    赋值 (指令文本信息, 相加 (#_cmp, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (指令文本信息, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序133, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 84 ea : test eb,reg8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_test, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (i)))


.子程序 子程序134, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 85 ea : test ed,reg32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_test, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (i)))


.子程序 子程序135, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 86 ea : xchg eb,reg8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_xchg, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (i)))


.子程序 子程序136, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 87 ea : xchg ed,reg32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_xchg, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (i)))


.子程序 子程序137, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 88 ea : mov eb,reg8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, 寻址判断.ea到文本_eb_reg8 (i)))


.子程序 子程序138, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 89 ea : mov ed,reg32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 0

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, 寻址判断.ea到文本_ew_reg16 (i)))


.子程序 子程序139, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 8a ea : mov reg8,eb
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, 寻址判断.ea到文本_reg8_eb (i)))


.子程序 子程序140, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 8b ea : mov reg32,ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, 寻址判断.ea到文本_reg16_ew (i)))


.子程序 子程序141, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 8c ea/s : mov ew,sreg
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, 寻址判断.ea_n到文本_ew (i), #_参数分隔符, 寻址判断.取sreg文本 (寻址判断.reg取值 (i))))


.子程序 子程序142, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 8d ea : lea reg32,ea  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_lea, #指令分隔符, 寻址判断.ea到文本_reg16_ew (i)))


.子程序 子程序143, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 8e ea/sreg : mov sreg,ew
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, 寻址判断.取sreg文本 (寻址判断.reg取值 (i)), #_参数分隔符, 寻址判断.ea_n到文本_ew (i)))


.子程序 子程序144, 文本型, , 
.局部变量 i, 字节型, , , 

 ' 8f ea/modrm : pop ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_pop, #指令分隔符, 寻址判断.ea_n到文本_ew (i)))


.子程序 子程序145, 文本型, , 
 ' 90 : nop
 ' ==========================================
返回 (#_nop)


.子程序 子程序146, 文本型, , 
 ' 91 : xchg eax,ecx  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “cx”))


.子程序 子程序147, 文本型, , 
 ' 92 : xchg eax,edx  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “dx”))


.子程序 子程序148, 文本型, , 
 ' 93 : xchg eax,ebx  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “bx”))


.子程序 子程序149, 文本型, , 
 ' 94 : xchg eax,esp  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “sp”))


.子程序 子程序150, 文本型, , 
 ' 95 : xchg eax,ebp  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “bp”))


.子程序 子程序151, 文本型, , 
 ' 96 : xchg eax,esi  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “si”))


.子程序 子程序152, 文本型, , 
 ' 97 : xchg eax,edi  *
 ' ==========================================
返回 (相加 (#_xchg, #指令分隔符, “ax”, #_参数分隔符, “di”))


.子程序 子程序153, 文本型, , 
 ' 98 : cbw/cwde  *
 ' ==========================================
返回 (#_cbw)


.子程序 子程序154, 文本型, , 
 ' 99 : cwd
 ' ==========================================
返回 (#_cwd)


.子程序 子程序155, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 j, 短整数型, , , 

 ' 9a offset32 : call offset32
 ' ==========================================
代码转指令.取一个字 (i)
代码转指令.取一个字 (j)
返回 (相加 (#_call, #指令分隔符, 到小写 (取十六进制文本 (j)), #_段分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序156, 文本型, , 
 ' 9b : wait
 ' ==========================================
返回 (#_wait)


.子程序 子程序157, 文本型, , 
 ' 9c : pushfd  *
 ' ==========================================
返回 (#_pushfw)


.子程序 子程序158, 文本型, , 
 ' 9d : popfd  *
 ' ==========================================
返回 (#_popfw)


.子程序 子程序159, 文本型, , 
 ' 9e : sahf
 ' ==========================================
返回 (#_sahf)


.子程序 子程序160, 文本型, , 
 ' 9f : lahf
 ' ==========================================
返回 (#_lahf)


.子程序 子程序161, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 段前缀, 文本型, , , 

 ' a0 disp32 : mov al,byte ptr ds:[disp]
 ' ==========================================
代码转指令.取一个字 (i)
赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__ds)
.如果真结束
返回 (相加 (#_mov, #指令分隔符, “al”, #_参数分隔符, 段前缀, #_段分隔符, “[”, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, “]”))



.子程序 子程序162, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 段前缀, 文本型, , , 

 ' a1 disp32 : mov eax,word ptr ds:[disp]  *
 ' ==========================================
代码转指令.取一个字 (i)
赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__ds)
.如果真结束
返回 (相加 (#_mov, #指令分隔符, “ax”, #_参数分隔符, 段前缀, #_段分隔符, “[”, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, “]”))



.子程序 子程序163, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 段前缀, 文本型, , , 

 ' a2 disp32 : mov byte ptr ds:[disp],al
 ' ==========================================
代码转指令.取一个字 (i)
赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__ds)
.如果真结束
返回 (相加 (#_mov, #指令分隔符, 段前缀, #_段分隔符, “[”, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, “]”, #_参数分隔符, “al”))



.子程序 子程序164, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 段前缀, 文本型, , , 

 ' a3 disp32 : mov [disp],eax  *   disp为段内偏移
 ' ==========================================
代码转指令.取一个字 (i)
赋值 (段前缀, 寻址判断.取段前缀 ())
.如果真 (等于 (段前缀, “”))
    赋值 (段前缀, #__ds)
.如果真结束
返回 (相加 (#_mov, #指令分隔符, 段前缀, #_段分隔符, “[”, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, “]”, #_参数分隔符, “ax”))



.子程序 子程序165, 文本型, , 
 ' a4 : movsb
 ' ==========================================
返回 (#_movsb)


.子程序 子程序166, 文本型, , 
 ' a5 : movsd  *
 ' ==========================================
返回 (#_movsw)


.子程序 子程序167, 文本型, , 
 ' a6 : cmpsb
 ' ==========================================
返回 (#_cmpsb)


.子程序 子程序168, 文本型, , 
 ' a7 : cmpsd  *
 ' ==========================================
返回 (#_cmpsw)


.子程序 子程序169, 文本型, , 
.局部变量 i, 字节型, , , 

 ' a8 data8 : test al,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_test, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序170, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' a9 data32 : test eax,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_test, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序171, 文本型, , 
 ' aa : stosb
 ' ==========================================
返回 (#_stosb)


.子程序 子程序172, 文本型, , 
 ' ab : stosd  *
 ' ==========================================
返回 (#_stosw)


.子程序 子程序173, 文本型, , 
 ' ac : lodsb
 ' ==========================================
返回 (#_lodsb)


.子程序 子程序174, 文本型, , 
 ' ad : lodsd  *
 ' ==========================================
返回 (#_lodsw)


.子程序 子程序175, 文本型, , 
 ' ae : scasb
 ' ==========================================
返回 (#_scasb)


.子程序 子程序176, 文本型, , 
 ' af : scasd  *
 ' ==========================================
返回 (#_scasw)


.子程序 子程序177, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b0 data8 : mov al,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序178, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b1 data8 : mov cl,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “cl”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序179, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b2 data8 : mov dl,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “dl”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序180, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b3 data8 : mov bl,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “bl”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序181, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b4 data8 : mov ah,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “ah”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序182, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b5 data8 : mov ch,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “ch”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序183, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b6 data8 : mov dh,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “dh”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序184, 文本型, , 
.局部变量 i, 字节型, , , 

 ' b7 data8 : mov bh,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_mov, #指令分隔符, “bh”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序185, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' b8 data32 : mov eax,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序186, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' b9 data32 : mov ecx,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “cx”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序187, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' ba data32 : mov edx,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “dx”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序188, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' bb data32 : mov ebx,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “bx”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序189, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' bc data32 : mov esp,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “sp”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序190, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' bd data32 : mov ebp,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “bp”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序191, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' be data32 : mov esi,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “si”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序192, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' bf data32 : mov edi,data32  *
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_mov, #指令分隔符, “di”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序193, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 
.局部变量 t, 文本型, , , 

 ' c0

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 data8 : rol eb,data8
    赋值 (t, 相加 (#_rol, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 1))
     ' ea/1 data8 ror eb,data8
    赋值 (t, 相加 (#_ror, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2 data8 rcl eb,data8
    赋值 (t, 相加 (#_rcl, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 3))
     ' ea/3 data8 rcr eb,data8
    赋值 (t, 相加 (#_rcr, #指令分隔符, 寻址判断.ea_n到文本_eb (x)))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 4))
     ' ea/4 data8 shl eb,data8
    赋值 (t, 相加 (#_sal, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 5))
     ' ea/5 data8 shr eb,data8
    赋值 (t, 相加 (#_shr, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 6))
    
.判断 (等于 (i, 7))
     ' ea/7 data8 sar eb,data8
    赋值 (t, 相加 (#_sar, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符))
    代码转指令.取一个字节 (i)
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序194, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 
.局部变量 t, 文本型, , , 

 ' c1  *

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 data8 rol ed,data8  *
    赋值 (t, 相加 (#_rol, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178384 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 1))
     ' ea/1 data8 ror ed,data8  *
    赋值 (t, 相加 (#_ror, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178387 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2 data8 rcl ed,data8  *
    赋值 (t, 相加 (#_rcl, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178390 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 3))
     ' ea/3 data8 rcr ed,data8  *
    赋值 (t, 相加 (#_rcr, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178393 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 4))
     ' ea/4 data8 shl ed,data8  *
    赋值 (t, 相加 (#_sal, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178396 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 5))
     ' ea/5 data8 shr ed,data8  *
    赋值 (t, 相加 (#_shr, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178399 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 6))
    返回 (“”)
.判断 (等于 (i, 7))
     ' ea/7 data8 sar ed,data8  *
    赋值 (t, 相加 (#_sar, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符))
    .未知函数_67178402 ()
    返回 (相加 (t, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序195, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' c2 data16 : ret data16
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_ret, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序196, 文本型, , 
 ' c3 : ret
 ' ==========================================
返回 (#_ret)


.子程序 子程序197, 文本型, , 
.局部变量 i, 字节型, , , 

 ' c4 ea : les reg32,ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_les, #指令分隔符, 寻址判断.ea到文本_reg16_ew (i)))


.子程序 子程序198, 文本型, , 
.局部变量 i, 字节型, , , 

 ' c5 ea : lds reg32,ed  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1
 ' 输出指令结构 [目前指令行数].d位 ＝ 1

代码转指令.取一个字节 (i)
返回 (相加 (#_lds, #指令分隔符, 寻址判断.ea到文本_reg16_ew (i)))


.子程序 子程序199, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 指令文本_集, 文本型, , , 

 ' c6 ea/0 data8 : mov eb,data8
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 0

代码转指令.取一个字节 (i)
.如果真 (不等于 (寻址判断.reg取值 (i), 0))
    赋值 (错误文本, “指令错误! c6”)
.如果真结束
赋值 (指令文本_集, 相加 (#_mov, #指令分隔符, 寻址判断.ea_n到文本_eb (i)))
代码转指令.取一个字节 (i)
返回 (相加 (指令文本_集, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序200, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 短整数型, , , 
.局部变量 指令文本_集, 文本型, , , 

 ' c7 ea data32 : mov reg32,data32  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (i)
.如果真 (不等于 (寻址判断.reg取值 (i), 0))
    赋值 (错误文本, “指令错误! C7”)
.如果真结束
赋值 (指令文本_集, 相加 (#_mov, #指令分隔符, 寻址判断.ea_n到文本_ew (i), #_参数分隔符))
代码转指令.取一个字 (x)
返回 (相加 (指令文本_集, 到小写 (取十六进制文本 (x)), #_十六进制数据后缀))


.子程序 子程序201, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 j, 字节型, , , 

 ' c8 data16 data8 : enter data16,data8
 ' ==========================================

代码转指令.取一个字 (i)
代码转指令.取一个字节 (j)
返回 (相加 (#_enter, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, #_参数分隔符, 到小写 (取十六进制文本 (j)), #_十六进制数据后缀))


.子程序 子程序202, 文本型, , 
 ' c9 : leave
 ' ==========================================
返回 (#_leave)


.子程序 子程序203, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' ca data16 : retf data16
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_retf, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序204, 文本型, , 
 ' cb : retf
 ' ==========================================
返回 (#_retf)


.子程序 子程序205, 文本型, , 
 ' cc : int 3
 ' ==========================================
返回 (#_int3)


.子程序 子程序206, 文本型, , 
.局部变量 i, 字节型, , , 

 ' cd data8 : int data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_int, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序207, 文本型, , 
 ' ce : into
 ' ==========================================
返回 (#_into)


.子程序 子程序208, 文本型, , 
 ' cf : iret
 ' ==========================================
返回 (#_iret)


.子程序 子程序209, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' d0

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 rol eb,1
    返回 (相加 (#_rol, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.判断 (等于 (i, 1))
     ' ea/1 ror eb,1
    返回 (相加 (#_ror, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.判断 (等于 (i, 2))
     ' ea/2 rcl eb,1
    返回 (相加 (#_rcl, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.判断 (等于 (i, 3))
     ' ea/3 rcr eb,1
    返回 (相加 (#_rcr, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.判断 (等于 (i, 4))
     ' ea/4 shl eb,1
    返回 (相加 (#_sal, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.判断 (等于 (i, 5))
     ' ea/5 shr eb,1
    返回 (相加 (#_shr, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.判断 (等于 (i, 6))
    
.判断 (等于 (i, 7))
     ' ea/7 sar eb,1
    返回 (相加 (#_sar, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “1”))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序210, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' d1  *

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 rol ed,1  *
    返回 (相加 (#_rol, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.判断 (等于 (i, 1))
     ' ea/1 ror ed,1  *
    返回 (相加 (#_ror, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.判断 (等于 (i, 2))
     ' ea/2 rcl ed,1  *
    返回 (相加 (#_rcl, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.判断 (等于 (i, 3))
     ' ea/3 rcr ed,1  *
    返回 (相加 (#_rcr, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.判断 (等于 (i, 4))
     ' ea/4 shl ed,1  *
    返回 (相加 (#_sal, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.判断 (等于 (i, 5))
     ' ea/5 shr ed,1  *
    返回 (相加 (#_shr, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.判断 (等于 (i, 6))
    
.判断 (等于 (i, 7))
     ' ea/7 sar ed,1  *
    返回 (相加 (#_sar, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “1”))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序211, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' d2

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 rol eb,cl
    返回 (相加 (#_rol, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 1))
     ' ea/1 ror eb,cl
    返回 (相加 (#_ror, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 2))
     ' ea/2 rcl eb,cl
    返回 (相加 (#_rcl, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 3))
     ' ea/3 rcr eb,cl
    返回 (相加 (#_rcr, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 4))
     ' ea/4 shl eb,cl
    返回 (相加 (#_sal, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 5))
     ' ea/5 shr eb,cl
    返回 (相加 (#_shr, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 6))
    
.判断 (等于 (i, 7))
     ' ea/7 sar eb,cl
    返回 (相加 (#_sar, #指令分隔符, 寻址判断.ea_n到文本_eb (x), #_参数分隔符, “cl”))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序212, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' d3  *

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 rol ed,cl  *
    返回 (相加 (#_rol, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 1))
     ' ea/1 ror ed,cl  *
    返回 (相加 (#_ror, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 2))
     ' ea/2 rcl ed,cl  *
    返回 (相加 (#_rcl, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 3))
     ' ea/3 rcr ed,cl  *
    返回 (相加 (#_rcr, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 4))
     ' ea/4 shl ed,cl  *
    返回 (相加 (#_sal, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 5))
     ' ea/5 shr ed,cl  *
    返回 (相加 (#_shr, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.判断 (等于 (i, 6))
    
.判断 (等于 (i, 7))
     ' ea/7 sar ed,cl  *
    返回 (相加 (#_sar, #指令分隔符, 寻址判断.ea_n到文本_ew (x), #_参数分隔符, “cl”))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序213, 文本型, , 
.局部变量 i, 字节型, , , 

 ' d4 : aam
 ' ==========================================
代码转指令.取一个字节 (i)
.如果 (等于 (i, 10))
    返回 (#_aam)
.否则
    返回 (相加 (#_aam, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.如果结束


.子程序 子程序214, 文本型, , 
.局部变量 i, 字节型, , , 

 ' d5 : aad
 ' ==========================================
代码转指令.取一个字节 (i)
.如果 (等于 (i, 10))
    返回 (#_aad)
.否则
    返回 (相加 (#_aad, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.如果结束


.子程序 子程序215, 文本型, , 
 ' d6
 ' ==========================================
返回 (“*d6* 错误！”)


.子程序 子程序216, 文本型, , 
 ' d7 xlat
 ' ==========================================
返回 (#_xlat)


.子程序 子程序217, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' d8 : esc0(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.mod取值 (x))
.如果 (等于 (i, 3))
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0))
        返回 (相加 (#_fadd, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 1))
        返回 (相加 (#_fmul, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 2))
        返回 (相加 (#_fcom, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 3))
        返回 (相加 (#_fcomp, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 4))
        返回 (相加 (#_fsub, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 5))
        返回 (相加 (#_fsubr, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 6))
        返回 (相加 (#_fdiv, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 7))
        返回 (相加 (#_fdivr, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .默认
        
    .判断结束
    
.否则
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0))
         ' d8 ea/0 fadd real32
        返回 (相加 (#_fadd, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 1))
         ' d8 ea/1 fmul real32
        返回 (相加 (#_fmul, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 2))
         ' d8 ea/2 fcom real32
        返回 (相加 (#_fcom, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 3))
         ' d8 ea/3 fcomp real32
        返回 (相加 (#_fcomp, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 4))
         ' d8 ea/4 fsub real32
        返回 (相加 (#_fsub, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 5))
         ' d8 ea/5 fsubr real32
        返回 (相加 (#_fsubr, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 6))
         ' d8 ea/6 fdiv real32
        返回 (相加 (#_fdiv, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 7))
         ' d8 ea/7 fdivr real32
        返回 (相加 (#_fdivr, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .默认
        
    .判断结束
    
.如果结束
返回 (“”)


.子程序 子程序218, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' d9 : esc1(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.mod取值 (x))
.如果 (等于 (i, 3))
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0))
        返回 (相加 (#_fld, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 1))
        返回 (相加 (#_fxch, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .默认
        
    .判断结束
    赋值 (i, x)
    .判断开始 (等于 (i, 208)) ' d9 d0
        返回 (#_fnop)
    .判断 (等于 (i, 224)) ' d9 e0
        返回 (#_fchs)
    .判断 (等于 (i, 225)) ' d9 e1
        返回 (#_fabs)
    .判断 (等于 (i, 228)) ' d9 e4
        返回 (#_ftst)
    .判断 (等于 (i, 229)) ' d9 e5
        返回 (#_fxam)
    .判断 (等于 (i, 232)) ' d9 e8
        返回 (#_fld1)
    .判断 (等于 (i, 233)) ' d9 e9
        返回 (#_fldl2t)
    .判断 (等于 (i, 234)) ' d9 ea
        返回 (#_fldl2e)
    .判断 (等于 (i, 235)) ' d9 eb
        返回 (#_fldpi)
    .判断 (等于 (i, 236)) ' d9 ec
        返回 (#_fldlg2)
    .判断 (等于 (i, 237)) ' d9 ed
        返回 (#_fldln2)
    .判断 (等于 (i, 238)) ' d9 ee
        返回 (#_fldz)
    .判断 (等于 (i, 240)) ' d9 f0
        返回 (#_f2xm1)
    .判断 (等于 (i, 241)) ' d9 f1
        返回 (#_fyl2x)
    .判断 (等于 (i, 242)) ' d9 f2
        返回 (#_fptan)
    .判断 (等于 (i, 243)) ' d9 f3
        返回 (#_fpatan)
    .判断 (等于 (i, 244)) ' d9 f4
        返回 (#_fxtract)
    .判断 (等于 (i, 245)) ' d9 f5
        返回 (#_fprem1)
    .判断 (等于 (i, 246)) ' d9 f6
        返回 (#_fdecstp)
    .判断 (等于 (i, 247)) ' d9 f7
        返回 (#_fincstp)
    .判断 (等于 (i, 248)) ' d9 f8
        返回 (#_fprem)
    .判断 (等于 (i, 249)) ' d9 f9
        返回 (#_fyl2xp1)
    .判断 (等于 (i, 250)) ' d9 fa
        返回 (#_fsqrt)
    .判断 (等于 (i, 251)) ' d9 fb
        返回 (#_fsincos)
    .判断 (等于 (i, 252)) ' d9 fc
        返回 (#_frndint)
    .判断 (等于 (i, 253)) ' d9 fd
        返回 (#_fscale)
    .判断 (等于 (i, 254)) ' d9 fe
        返回 (#_fsin)
    .判断 (等于 (i, 255)) ' d9 ff
        返回 (#_fcos)
    .默认
        
    .判断结束
    
.否则
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0))
        返回 (相加 (#_fld, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 2))
        返回 (相加 (#_fst, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 3))
        返回 (相加 (#_fstp, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 4))
        返回 (相加 (#_fldenv, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 5))
        返回 (相加 (#_fldcw, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 6))
        返回 (相加 (#_fstenv, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 7))
        返回 (相加 (#_fnstcw, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .默认
        
    .判断结束
    
.如果结束
返回 (“”)


.子程序 子程序219, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 mod, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' da : eac2(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
.如果真 (等于 (x, 233)) ' e9
    返回 (#_fucompp)
.如果真结束
赋值 (i, 寻址判断.reg取值 (x))
赋值 (mod, 寻址判断.mod取值 (x))
.如果 (不等于 (mod, 3))
    .判断开始 (等于 (i, 0))
        返回 (相加 (#_fiadd, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 1))
        返回 (相加 (#_fimul, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 2))
        返回 (相加 (#_ficom, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 3))
        返回 (相加 (#_ficomp, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 4))
        返回 (相加 (#_fisub, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 5))
        返回 (相加 (#_fisubr, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 6))
        返回 (相加 (#_fidiv, #指令分隔符, “<i32>”, 寻址判断.ea取值文本_自定义 (x)))
    .默认
        
    .判断结束
    返回 (“”)
.否则
    .判断开始 (等于 (i, 0))
        返回 (相加 (#_fcmovb, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 1))
        返回 (相加 (#_fcmove, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 2))
        返回 (相加 (#_fcmovbe, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 3))
        返回 (相加 (#_fcmovu, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 4))
         ' 返回 (#_fisub ＋ #指令分隔符 ＋ “<i32>” ＋ 寻址判断.ea取值文本_自定义 (x))
    .判断 (等于 (i, 5))
         ' 返回 (#_fisubr ＋ #指令分隔符 ＋ “<i32>” ＋ 寻址判断.ea取值文本_自定义 (x))
    .判断 (等于 (i, 6))
        
    .判断 (等于 (i, 7))
         ' 返回 (#_fidivr ＋ #指令分隔符 ＋ “<i32>” ＋ 寻址判断.ea取值文本_自定义 (x))
    .默认
        
    .判断结束
    
.如果结束
返回 (“”)


.子程序 子程序220, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' db : eac3(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
.如果真 (等于 (x, 226)) ' eb e2
    返回 (#_fnclex)
.如果真结束
.如果真 (等于 (x, 227)) ' eb e3
    返回 (#_fninit)
.如果真结束
赋值 (i, 寻址判断.reg取值 (x))
.如果真 (不等于 (寻址判断.mod取值 (x), 3))
    .判断开始 (等于 (i, 0))
        返回 (相加 (#_fild, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 1))
        返回 (相加 (#_fisttp, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 2))
        返回 (相加 (#_fist, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 3))
        返回 (相加 (#_fistp, #指令分隔符, “<r32>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 5))
        返回 (相加 (#_fld, #指令分隔符, “<r80>”, 寻址判断.ea取值文本_自定义 (x)))
    .判断 (等于 (i, 7))
        返回 (相加 (#_fstp, #指令分隔符, “<r80>”, 寻址判断.ea取值文本_自定义 (x)))
    .默认
        
    .判断结束
    返回 (“”)
.如果真结束
.判断开始 (等于 (i, 0))
    返回 (相加 (#_fcmovnb, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
.判断 (等于 (i, 1))
    返回 (相加 (#_fcmovne, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
.判断 (等于 (i, 2))
    返回 (相加 (#_fcmovnbe, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
.判断 (等于 (i, 3))
    返回 (相加 (#_fcmovnu, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
.判断 (等于 (i, 5))
    返回 (相加 (#_fucomi, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
.判断 (等于 (i, 6))
    返回 (相加 (#_fcomi, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序221, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' dc : eac4(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.mod取值 (x))
.如果真 (等于 (i, 3))
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0)) ' dc c0+i
        返回 (相加 (#_fadd, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 1)) ' dc c8+i
        返回 (相加 (#_fmul, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 4)) ' dc e0+i
        返回 (相加 (#_fsubr, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 5)) ' dc e8+i
        返回 (相加 (#_fsub, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 6)) ' dc f0+i
        返回 (相加 (#_fdivr, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 7)) ' dc f8+i
        返回 (相加 (#_fdiv, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .默认
        
    .判断结束
    
.如果真结束
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
    返回 (相加 (#_fadd, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 1))
    返回 (相加 (#_fmul, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 2))
    返回 (相加 (#_fcom, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 3))
    返回 (相加 (#_fcomp, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 4))
    返回 (相加 (#_fsub, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 5))
    返回 (相加 (#_fsubr, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 6))
    返回 (相加 (#_fdiv, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 7))
    返回 (相加 (#_fdivr, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序222, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' dd : eac5(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.mod取值 (x))
.如果真 (等于 (i, 3))
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0)) ' dd c0+i
        返回 (相加 (#_ffree, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 2)) ' dd d0+i
        返回 (相加 (#_fst, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 3)) ' dd d8+i
        返回 (相加 (#_fstp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 4)) ' dd e0+i
        返回 (相加 (#_fucom, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 5)) ' dd e8+i
        返回 (相加 (#_fucomp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .默认
        
    .判断结束
    
.如果真结束
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
    返回 (相加 (#_fld, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 2))
    返回 (相加 (#_fst, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 3))
    返回 (相加 (#_fstp, #指令分隔符, “<r64>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 4))
    返回 (相加 (#_frstor, #指令分隔符, “<a32>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 6))
    返回 (相加 (#_fnsave, #指令分隔符, “<a32>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 7))
    返回 (相加 (#_fnstcw, #指令分隔符, #byte, 寻址判断.ea取值文本_自定义 (x)))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序223, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' de : eac6(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
.如果真 (等于 (x, 217))
    返回 (#_fcompp)
.如果真结束
赋值 (i, 寻址判断.mod取值 (x))
.如果真 (等于 (i, 3))
    赋值 (i, 寻址判断.reg取值 (x))
    .判断开始 (等于 (i, 0)) ' de c0+i
        返回 (相加 (#_faddp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 1)) ' de c8+i
        返回 (相加 (#_fmulp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 4)) ' de e0+i
        返回 (相加 (#_fsubrp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 5)) ' de e8+i
        返回 (相加 (#_fsubp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 6)) ' de f0+i
        返回 (相加 (#_fdivrp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .判断 (等于 (i, 7)) ' de f8+i
        返回 (相加 (#_fdivp, #指令分隔符, “st”, 到文本 (寻址判断.rm取值 (x)), #_参数分隔符, “st0”))
    .默认
        
    .判断结束
    
.如果真结束
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
    返回 (相加 (#_fiadd, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 1))
    返回 (相加 (#_fimul, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 2))
    返回 (相加 (#_ficom, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 3))
    返回 (相加 (#_ficomp, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 4))
    返回 (相加 (#_fisub, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 5))
    返回 (相加 (#_fisubr, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 6))
    返回 (相加 (#_fidiv, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.判断 (等于 (i, 7))
    返回 (相加 (#_fidivr, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x)))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序224, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' df : eac7(ndp)
 ' ==========================================

代码转指令.取一个字节 (x)
.如果真 (等于 (x, 224))
    返回 (相加 (#_fstcw, “ax”))
.如果真结束
赋值 (i, 寻址判断.reg取值 (x))
.如果真 (等于 (寻址判断.mod取值 (x), 3))
    .判断开始 (等于 (i, 5))
        返回 (相加 (#_fucomip, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .判断 (等于 (i, 6))
        返回 (相加 (#_fcomip, #指令分隔符, “st0”, #_参数分隔符, “st”, 到文本 (寻址判断.rm取值 (x))))
    .默认
        
    .判断结束
    
.如果真结束
.判断开始 (等于 (i, 0))
    返回 (相加 (#_fild, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x))) ' int16
.判断 (等于 (i, 2))
    返回 (相加 (#_fist, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x))) ' int16
.判断 (等于 (i, 3))
    返回 (相加 (#_fistp, #指令分隔符, “<i16>”, 寻址判断.ea取值文本_自定义 (x))) ' int16
.判断 (等于 (i, 4))
    返回 (相加 (#_fbld, #指令分隔符, “<bcd80>”, 寻址判断.ea取值文本_自定义 (x))) ' bcd80
.判断 (等于 (i, 5))
    返回 (相加 (#_fild, #指令分隔符, “<i64>”, 寻址判断.ea取值文本_自定义 (x))) ' int64
.判断 (等于 (i, 6))
    返回 (相加 (#_fbstp, #指令分隔符, “<bcd80>”, 寻址判断.ea取值文本_自定义 (x))) ' bcd80
.判断 (等于 (i, 7))
    返回 (相加 (#_fistp, #指令分隔符, “<i64>”, 寻址判断.ea取值文本_自定义 (x))) ' int64
.默认
    
.判断结束
返回 (“”)


.子程序 子程序225, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e0 disp8 : loopne disp8(loopne/loopnz)
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_loopne, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序226, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e1 disp8 : loope disp8 (lppoe/loopz)
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_loope, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序227, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e2 disp8 : loop disp8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_loop, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序228, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e3 data8 : jcxz data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_jcxz, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序229, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e4 data8 : in al,data8
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_in, #指令分隔符, “al”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序230, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e5 data8 : in eax,data8  *
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_in, #指令分隔符, “ax”, #_参数分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序231, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e6 data8 : out data8,al
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_out, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, #_参数分隔符, “al”))


.子程序 子程序232, 文本型, , 
.局部变量 i, 字节型, , , 

 ' e7 data8 : out data8,eax  *
 ' ==========================================

代码转指令.取一个字节 (i)
返回 (相加 (#_out, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀, #_参数分隔符, “ax”))


.子程序 子程序233, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 j, 短整数型, , , 

 ' e8 ea(32) : call ea32    *  'ea32 为32位偏移量，call 下一句地址+偏移量
 ' ==========================================

代码转指令.取一个字 (i)
返回 (相加 (#_call, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序234, 文本型, , 
.局部变量 i, 短整数型, , , 

 ' e9 disp32 : jmp disp32
 ' ==========================================
代码转指令.取一个字 (i)
返回 (相加 (#_jmp, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序235, 文本型, , 
.局部变量 i, 短整数型, , , 
.局部变量 j, 短整数型, , , 

 ' ea ea(48) : jmp far ea48  *
 ' ==========================================
代码转指令.取一个字 (i)
代码转指令.取一个字 (j)
返回 (相加 (#_jmp, #指令分隔符, 到小写 (取十六进制文本 (j)), #_段分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序236, 文本型, , 
.局部变量 i, 字节型, , , 

 ' eb disp8 : jmp disp8 < 为偏移量
 ' ==========================================
代码转指令.取一个字节 (i)
返回 (相加 (#_jmp, #指令分隔符, 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))


.子程序 子程序237, 文本型, , 
 ' ec : in al,dx
 ' ==========================================
返回 (相加 (#_in, #指令分隔符, “al”, #_参数分隔符, “dx”))


.子程序 子程序238, 文本型, , 
 ' ed : in eax,dx  *
 ' ==========================================
返回 (相加 (#_in, #指令分隔符, “ax”, #_参数分隔符, “dx”))


.子程序 子程序239, 文本型, , 
 ' ee : out dx,al
 ' ==========================================
返回 (相加 (#_out, #指令分隔符, “dx”, #_参数分隔符, “al”))


.子程序 子程序240, 文本型, , 
 ' ef : out dx,eax  *
 ' ==========================================
返回 (相加 (#_out, #指令分隔符, “dx”, #_参数分隔符, “ax”))


.子程序 子程序241, 文本型, , 
 ' f0 : lock      前缀
 ' ==========================================
返回 (#_lock)


.子程序 子程序242, 文本型, , 
 ' f1
 ' ==========================================
返回 (“*f1* 错误！”)


.子程序 子程序243, 文本型, , 
 ' f2 : repne/repnz
 ' ==========================================
返回 (#_repne)


.子程序 子程序244, 文本型, , 
 ' f3 : rep/repe/repz
 ' ==========================================
返回 (#_rep)


.子程序 子程序245, 文本型, , 
 ' f4 : hlt
 ' ==========================================
返回 (#_hlt)


.子程序 子程序246, 文本型, , 
 ' f5 : cmc
 ' ==========================================
返回 (#_cmc)


.子程序 子程序247, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' f6 ea/n
 ' ==========================================

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
    代码转指令.取一个字节 (i)
     ' ea/0 data8  test eb,data8
    返回 (相加 (#_test, #指令分隔符, 寻址判断.ea_n到文本_eb (x), 到小写 (取十六进制文本 (i)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2  not eb
    返回 (相加 (#_not, #指令分隔符, 寻址判断.ea_n到文本_eb (x)))
.判断 (等于 (i, 3))
     ' ea/3 neg eb
    返回 (相加 (#_neg, #指令分隔符, 寻址判断.ea_n到文本_eb (x)))
.判断 (等于 (i, 4))
     ' ea/4 mul al,eb
    返回 (相加 (#_mul, #指令分隔符, “al”, #_参数分隔符, 寻址判断.ea_n到文本_eb (x)))
.判断 (等于 (i, 5))
     ' ea/5 imul al,eb
    返回 (相加 (#_imul, #指令分隔符, “al”, #_参数分隔符, 寻址判断.ea_n到文本_eb (x)))
.判断 (等于 (i, 6))
     ' ea/6 div al,eb
    返回 (相加 (#_div, #指令分隔符, “al”, #_参数分隔符, 寻址判断.ea_n到文本_eb (x)))
.判断 (等于 (i, 7))
     ' ea/7 idiv al,eb
    返回 (相加 (#_idiv, #指令分隔符, “al”, #_参数分隔符, 寻址判断.ea_n到文本_eb (x)))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序248, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x8, 字节型, , , 
.局部变量 x16, 短整数型, , , 

 ' f7 ea/n  *
 ' ==========================================

代码转指令.取一个字节 (x8)
赋值 (i, 寻址判断.reg取值 (x8))
.判断开始 (等于 (i, 0))
     ' ea/0 data32  test ed,data32  *
    代码转指令.取一个字 (x16)
    返回 (相加 (#_test, #指令分隔符, 寻址判断.ea_n到文本_ew (x8), 到小写 (取十六进制文本 (x16)), #_十六进制数据后缀))
.判断 (等于 (i, 2))
     ' ea/2  not ed  *
    返回 (相加 (#_not, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
.判断 (等于 (i, 3))
     ' ea/3 neg ed  *
    返回 (相加 (#_neg, #指令分隔符, 寻址判断.ea_n到文本_ew (x8)))
.判断 (等于 (i, 4))
     ' ea/4 mul eax,ed  *
    返回 (相加 (#_mul, #指令分隔符, “ax”, #_参数分隔符, 寻址判断.ea_n到文本_ew (x8)))
.判断 (等于 (i, 5))
     ' ea/5 imul eax,ed  *
    返回 (相加 (#_imul, #指令分隔符, “ax”, #_参数分隔符, 寻址判断.ea_n到文本_ew (x8)))
.判断 (等于 (i, 6))
     ' ea/6 div eax,ed  *
    返回 (相加 (#_div, #指令分隔符, “ax”, #_参数分隔符, 寻址判断.ea_n到文本_ew (x8)))
.判断 (等于 (i, 7))
     ' ea/7 idiv eax,ed  *
    返回 (相加 (#_idiv, #指令分隔符, “ax”, #_参数分隔符, 寻址判断.ea_n到文本_ew (x8)))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序249, 文本型, , 
 ' f8 : clc
 ' ==========================================
返回 (#_clc)


.子程序 子程序250, 文本型, , 
 ' f9 : stc
 ' ==========================================
返回 (#_stc)


.子程序 子程序251, 文本型, , 
 ' fa : cli
 ' ==========================================
返回 (#_cli)


.子程序 子程序252, 文本型, , 
 ' fb : sti
 ' ==========================================
返回 (#_sti)


.子程序 子程序253, 文本型, , 
 ' fc : cld
 ' ==========================================
返回 (#_cld)


.子程序 子程序254, 文本型, , 
 ' fd : std
 ' ==========================================
返回 (#_std)


.子程序 子程序255, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' fe ea/(0,1) :
 ' ==========================================

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 inc eb
    返回 (相加 (#_inc, #指令分隔符, 寻址判断.ea_n到文本_eb (x)))
.判断 (等于 (i, 1))
     ' ea/1 dec eb
    返回 (相加 (#_dec, #指令分隔符, 寻址判断.ea_n到文本_eb (x)))
.默认
    
.判断结束
返回 (“”)


.子程序 子程序256, 文本型, , 
.局部变量 i, 字节型, , , 
.局部变量 x, 字节型, , , 

 ' ff ea/n(n=0~6)  *
 ' ==========================================
 ' 输出指令结构 [目前指令行数].w位 ＝ 1

代码转指令.取一个字节 (x)
赋值 (i, 寻址判断.reg取值 (x))
.判断开始 (等于 (i, 0))
     ' ea/0 inc ed  *
    返回 (相加 (#_inc, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.判断 (等于 (i, 1))
     ' ea/1 dec ed  *
    返回 (相加 (#_dec, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.判断 (等于 (i, 2))
     ' ea/2 call ed  *
    返回 (相加 (#_call, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.判断 (等于 (i, 3))
     ' ea/3 call far ea  *
    返回 (相加 (#_call, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.判断 (等于 (i, 4))
     ' ea/4 jmp ed  *
    返回 (相加 (#_jmp, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.判断 (等于 (i, 5))
     ' ea/5 jmp far ea  *
    返回 (相加 (#_jmp, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.判断 (等于 (i, 6))
     ' ea/6 push ed  *
    返回 (相加 (#_push, #指令分隔符, 寻址判断.ea_n到文本_ew (x)))
.默认
    
.判断结束
返回 (“”)


.窗口程序集 测试窗口程序集, , , 

.程序集变量 代码字节集_全, 字节集, , , 
.子程序 _转换按钮1_被单击, 空白型, , 
.局部变量 字节长度, 整数型, , , 
.局部变量 本行指令文本, 文本型, , , 
.局部变量 错误文本组, 文本型, , "0", 
.局部变量 i, 整数型, , , 
.局部变量 x, 字节型, , , 
.局部变量 开始位置数, 整数型, , , 
.局部变量 当前位置, 整数型, , , 
.局部变量 输出文本信息, 文本型, , , 

赋值 (.内容, “”)
赋值 (.内容, “”)
赋值 (字节长度, 取字节集长度 (代码字节集_全))
.如果真 (等于 (字节长度, 0))
    赋值 (.内容, “输入代码为空!”)
    返回 ()
.如果真结束
代码转指令.清空错误提示文本组 ()
代码转指令.读入代码数据 (代码字节集_全)
赋值 (当前位置, 到数值 (.内容))
赋值 (开始位置数, 0)
.判断循环首 (代码转指令.取一条代码指令 (本行指令文本, 当前位置))
    赋值 (输出文本信息, 相加 (输出文本信息, 返回一行指令文本 (开始位置数, 本行指令文本)))
    赋值 (开始位置数, 相减 (当前位置, 1))
    赋值 (.位置, 当前位置)
.判断循环尾 ()
赋值 (.内容, 输出文本信息)
.如果真 (代码转指令.取错误提示文本组 (错误文本组))
    .计次循环首 (取数组成员数 (错误文本组), i)
        相加 (错误文本组 [i], #换行符).加入文本 ()
    .计次循环尾 ()
.如果真结束
赋值 (.起始选择位置, 0)
获取焦点 ()
赋值 (.位置, 0)


.子程序 _截入按钮2_被单击, 空白型, , 
.局部变量 文件号, 整数型, , , 
.局部变量 代码数据, 字节集, , , 
.局部变量 i, 整数型, , , 
.局部变量 j, 整数型, , , 
.局部变量 x, 字节型, , , 
.局部变量 位置_局, 整数型, , , 
.局部变量 文本信息, 文本型, , , 

赋值 (.内容, “”)
赋值 (位置_局, 1)
赋值 (.初始目录, 取运行目录 ())
.如果真 (打开 ())
    调试输出 (.文件名)
    赋值 (文件号, 打开文件 (.文件名, #读入, ))
    赋值 (代码数据, 读入字节集 (文件号, 取文件长度 (文件号)))
    赋值 (代码字节集_全, 代码数据)
    关闭文件 (文件号)
    赋值 (.最大位置, 取字节集长度 (代码数据))
     ' 编辑框1.内容 ＝ 字节集到十六进制文本 (代码数据, 16)
    .计次循环首 (相除 (.最大位置, 16), i)
        赋值 (文本信息, 相加 (文本信息, 字节到十六进制文本 (取字节集中间 (代码数据, 相加 (相乘 (相减 (i, 1), 16), 1), 16), 16)))
        赋值 (.位置, 相乘 (i, 16))
    .计次循环尾 ()
.如果真结束
赋值 (.内容, “”)
赋值 (.内容, 文本信息)
赋值 (.位置, 0)


.子程序 _窗口1_创建完毕, 空白型, , 
寻址判断.初始mrr文本 ()
十六进制字节文本组初使 ()


.子程序 _选择框1_被单击, 空白型, , 
.如果 (.选中)
    赋值 (.标题, “32位”)
.否则
    赋值 (.标题, “16位”)
.如果结束
代码转指令.置操作尺寸_类 (.选中)


.子程序 _编辑框4_失去焦点, 空白型, , 
.如果真 (小于 (到数值 (.内容), 1))
    赋值 (.内容, “1”)
.如果真结束
返回 ()


.子程序 _转换一行按钮2_被单击, 空白型, , 
.局部变量 字节长度, 整数型, , , 
.局部变量 本行指令文本, 文本型, , , 
.局部变量 错误文本组, 文本型, , "0", 
.局部变量 i, 整数型, , , 
.局部变量 x, 字节型, , , 
.局部变量 当前位置, 整数型, , , 

 ' 代码字节集_全 ＝ 十六进制文本到字节集 (整理文本_16进制 (编辑框1.内容))
赋值 (字节长度, 取字节集长度 (代码字节集_全))
.如果真 (等于 (字节长度, 0))
    赋值 (.内容, “输入代码为空!”)
    返回 ()
.如果真结束
代码转指令.清空错误提示文本组 ()
代码转指令.读入代码数据 (代码字节集_全)
赋值 (当前位置, 到数值 (.内容))
.判断循环首 (代码转指令.取一条代码指令 (本行指令文本, 当前位置))
    返回一行指令文本 (当前位置, 本行指令文本)
    赋值 (.位置, 当前位置)
.判断循环尾 ()
.如果真 (代码转指令.取错误提示文本组 (错误文本组))
    .计次循环首 (取数组成员数 (错误文本组), i)
        相加 (错误文本组 [i], #换行符).加入文本 ()
    .计次循环尾 ()
.如果真结束
赋值 (.起始选择位置, 0)
获取焦点 ()
赋值 (.位置, 0)


.子程序 返回一行指令文本, 文本型, , 
.参数 位置数据, 整数型, , 
.参数 文本指令, 文本型, , 

返回 (相加 (调整文本长度_增加 (取十六进制文本 (位置数据), 8, “0”, 真), “ --- ”, 调整文本长度_增加 (字节集到十六进制文本 (代码转指令.取本行代码集 ()), 24, “ ”, 假), “  ”, 文本指令, #换行符))



 ' 不属于任何一个程序集、类模块的函数：
