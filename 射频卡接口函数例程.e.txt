 ' 文件类型：Windows窗口程序

 ' 程序名称：
 ' 程序描述：
 ' 程序作者：
 ' 邮政编码：
 ' 联系地址：
 ' 联系电话：
 ' 传真号码：
 ' 电子信箱：
 ' 主页地址：
 ' 版权声明：
 ' 版本号：1.0
 ' 创建号：0.0

窗口 _启动窗口 ' 在程序启动后自动调入本窗口
    左边 = 50
    顶边 = 50
    宽度 = 839
    高度 = 395
    鼠标指针 = { 0,0,0,0 }
    标记 = “”
    可视 = 真
    禁止 = 假
    边框 = 2
    底图方式 = 1
    底色 = -16777216 '  0xFF000000
    最大化按钮 = 假
    最小化按钮 = 假
    控制按钮 = 真
    位置 = 1
    可否移动 = 真
    背景音乐播放次数 = 0
    回车下移焦点 = 假
    Esc键关闭 = 真
    F1键打开帮助 = 假
    帮助标志值 = 0
    在任务栏中显示 = 真
    随意移动 = 假
    外形 = 0
    总在最前 = 假
    保持标题栏激活 = 假
    窗口类名 = “”
    底图 =  ' 空
    图标 =  ' 空
    背景音乐 =  ' 空
    标题 = “射频卡32位动态库易语言调用示例，毫不保留贡献给易友（易语言论坛sx0574编写）其他函数懂的朋友帮忙完善”
    帮助文件名 = “”



.图片 dcrf32, " ' 已保存到：D:\易语言学习\Data\射频卡接口函数例程.e\dcrf32", , dcrf32.dll


 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 5 0 系统核心支持库
 ' spec A512548E76954B6E92C21055517615B0 3 0 特殊功能支持库





.DLL命令 dc_init, 整数型, "dcrf32.dll", "dc_init", , 初始化通讯口；（成功则返回串口标识符>0，失败返回负值）
    .参数 port, 短整数型, , 取值为0～19时，表示串口1～20；为100时，表示USB口通讯，此时波特率无效。
    .参数 baud, 整数型, , 为通讯波特率9600～115200

.DLL命令 dc_load_key_hex, 短整数型, "dcrf32.dll", "dc_load_key_hex", , 将密码装入读写模块RAM中（成功返回0）
    .参数 icdev, 整数型, , 通讯设备标识符
    .参数 mode, 短整数型, , 装入密码模式，同密码验证模式
    .参数 secnr, 短整数型, , 扇区号（M1卡：0～15；  ML卡：0）
    .参数 nkey, 文本型, 传址, 写入读写器中的卡密码（十六进制文本）

.DLL命令 dc_beep, 短整数型, "dcrf32.dll", "dc_beep", , 
    .参数 icdev, 整数型, , 
    .参数 time1, 短整数型, , 

.DLL命令 dc_disp_str, 短整数型, "dcrf32.dll", "dc_disp_str", , 在读写器的数码管上显示数字(RD800M读写器专用)
    .参数 icdev, 整数型, , 通讯设备标识符
    .参数 sdata, 文本型, , 要显示的字符串，由数值字符'0'-'F'和'.'组成

.DLL命令 dc_card, 短整数型, "DCRF32.dll", "dc_card", , 寻卡（成功则返回0）
    .参数 icdev, 整数型, , 设备号
    .参数 mode, 短整数型, , 模式
    .参数 varsecnr, 长整数型, 传址, 返回卡号

.DLL命令 dc_authentication, 短整数型, "dcrf32.dll", "dc_authentication", , 核对密码函数（成功返回0）
    .参数 icdev, 整数型, , 通讯设备标识符
    .参数 mode, 短整数型, , 装入密码模式，同密码验证模式
    .参数 secnr, 整数型, , 要验证密码的扇区号

.DLL命令 dc_write_hex, 短整数型, "dcrf32.dll", "dc_write_hex", , 向卡中写入数据（成功则返回 0）
    .参数 icdev, 整数型, , 通讯设备标识符
    .参数 adr, 短整数型, , M1卡-块地址（0～63）,扇区16*4-1（0～15*4-1固化）
    .参数 sdata, 文本型, 传址, 要写入的数据（十六进制文本）

.DLL命令 dc_read_hex, 短整数型, "dcrf32.dll", "dc_read_hex", , 读取卡中数据（成功则返回 0）
    .参数 icdev, 整数型, , 通讯设备标识符
    .参数 adr, 短整数型, , M1卡-块地址（0～63）,扇区16*4-1（0～15*4-1固化）
    .参数 sdata, 整数型, 传址 数组, 读出的数据（十六进制文本）

.DLL命令 dc_halt, 短整数型, "dcrf32.dll", "dc_halt", , 
    .参数 icdev, 整数型, , 

.DLL命令 dc_reset, 短整数型, "dcrf32.dll", "dc_reset", , 
    .参数 icdev, 整数型, , 
    .参数 msec, 短整数型, , 

.DLL命令 dc_exit, 整数型, "dcrf32.dll", "dc_exit", , 关闭端口
    .参数 icdev, 整数型, , 通讯设备标识符（端口句柄）在WIN32环境下icdev为串口的设备句柄，必须释放后才可以再次连接。（成功则返回 0）

.DLL命令 DLL以上函数都是些常用命令0还有很多自己研究, 空白型, "", "", , 
    .参数 匿名参数_86, 空白型, , 

.窗口程序集 窗口程序集1, , , 

.程序集变量 设备号, 短整数型, , , 
.程序集变量 十六进制的密匙, 文本型, , , 
.程序集变量 密码验证模式, 整数型, , , 
.程序集变量 校验的扇区, 整数型, , , 
.程序集变量 寻卡模式, 短整数型, , , 
.程序集变量 操作的块地址, 短整数型, , , 
.子程序 __启动窗口_创建完毕, 空白型, , 
 ' 易语言论坛sx0574编写
.如果 (等于 (文件是否存在 (相加 (取运行目录 (), “\”, “dcrf32.dll”)), 假))
    写到文件 (相加 (取运行目录 (), “\dcrf32.dll”), #dcrf32)
.否则
    
.如果结束
输出调试文本 (到文本 (文件是否存在 (相加 (取运行目录 (), “\”, “dcrf32.dll”))))

赋值 (操作的块地址, 相加 (相乘 (3, 4), 2)) ' 块2,M1卡-块地址（1～63）,0是固化的序列号 解析：3是扇区*4是每个扇区有4个块+2就是第2块
赋值 (“ffffffffffff”) ' 密码为"ffffffffffff"共12位数
赋值 (0) ' 0为KEYSET0的KEYB 密码,3为装载3扇区的密码到读写器，这和后面要校验3扇区的密码是相对应的
赋值 (校验的扇区, 3)
赋值 (寻卡模式, 1) ' 寻卡函数 寻卡模式=1 可对卡连续操作，为0时如果执行了HBLT（中止对该卡操作）操作,则卡必须离开感应区后才能再次操作

.子程序 _按钮1_被单击, 空白型, , 
.局部变量 返回值, 短整数型, , , 

赋值 (设备号, dc_init (100, 115200)) ' 这里初始化USB接口，波特率为115200没有用
.如果 (大于 (设备号, 0))
    “调用 dc_init()函数成功”.加入项目 ()
    dc_beep (设备号, 10) ' 如果icdev>0表示成功,读卡器蜂鸣10毫秒
.否则
    “调用 dc_init()函数出错”.加入项目 ()
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 (返回值))), “设备号:”, 到文本 (设备号)))

.子程序 _按钮2_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 

赋值 (返回值, dc_load_key_hex (设备号, 密码验证模式, 校验的扇区, 十六进制的密匙))
 ' 密码验证模式
 ' 对于M1卡的每个扇区，在读写器中均对应有三套密码（KEYSET0、KEYSET1、KEYSET2），每套密码包括B密码（KEYB）和B密码（KEYB），共六个密码，用0～2、4～6来表示这六个密码：
 ' 0――KEYSET0的KEYB
 ' 1――KEYSET1的KEYB
 ' 2――KEYSET2的KEYB
 ' 4――KEYSET0的KEYB
 ' 5――KEYSET1的KEYB
 ' 6――KEYSET2的KEYB
.如果 (等于 (返回值, 0))
    “调用 dc_Load_key_hex()函数成功”.加入项目 ()
    dc_beep (设备号, 10) ' 读卡器蜂鸣10毫秒
    
.否则
    “调用 dc_Load_key_hex()函数出错”.加入项目 ()
    
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 (返回值))), “设备号:”, 到文本 (设备号)))


.子程序 _蜂鸣_按钮_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 

赋值 (返回值, dc_beep (设备号, 10)) ' 读卡器蜂鸣10毫秒
.如果 (等于 (返回值, 0))
    “调用 dc_beep()函数成功”.加入项目 ()
.否则
    “调用 dc_beep()函数出错”.加入项目 ()
    
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 (返回值))), “设备号:”, 到文本 (设备号)))


.子程序 _按钮3_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 
.局部变量 字符, 文本型, , , 

赋值 (字符, “123.45”) ' 要显示的字符串，由数值字符'0'-'F'和'.'组成
赋值 (返回值, dc_disp_str (设备号, 字符))
.如果 (等于 (返回值, 0))
    “调用 dc_disp_str()函数成功”.加入项目 ()
    dc_beep (设备号, 10) ' 读卡器蜂鸣10毫秒
.否则
    “调用 dc_disp_str()函数出错”.加入项目 ()
.如果结束


.子程序 _按钮4_被单击, 空白型, , 
.局部变量 序列号, 长整数型, , , 
.局部变量 返回值, 短整数型, , , 


赋值 (返回值, dc_card (设备号, 寻卡模式, 序列号))
 ' 输出调试文本 (到文本 (序列号))
.如果 (不等于 (返回值, 0))
    “调用 dc_card()函数出错”.加入项目 ()
.否则
    .如果 (等于 (返回值, 0))
        “调用 dc_card()函数成功”.加入项目 ()
        相加 (“序列号:”, 到文本 (序列号)).加入项目 ()
        dc_beep (设备号, 10) ' 读卡器蜂鸣10毫秒
    .否则
        “没有找到卡片”.加入项目 ()
    .如果结束
    
.如果结束
 ' MODE为1可反复寻卡, MODE为0卡必须拿开才可重新操作!


.子程序 _按钮6_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 
.局部变量 缓冲区, 文本型, , , 
.局部变量 长度, 整数型, , , 

 ' 十六进制的密匙 ＝ “ffffffffffff”  ' 密码为"ffffffffffff"共12位数
dc_load_key_hex (设备号, 密码验证模式, 校验的扇区, 十六进制的密匙) ' 0为KEYSET0的KEYB 密码,3为装载3扇区的密码到读写器，这和后面要校验3扇区的密码是相对应的
赋值 (返回值, dc_authentication (设备号, 密码验证模式, 校验的扇区)) ' 检验2扇区的密码和读卡器的是否对应
.如果 (等于 (返回值, 0))
    dc_beep (设备号, 10)
    “调用dc_authentication 函数成功”.加入项目 ()
.否则
    “调用dc_authentication 函数失败”.加入项目 ()
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 (返回值))), “设备号:”, 到文本 (设备号)))


.子程序 _按钮9_被单击, 空白型, , 
.局部变量 要写入的数据32位, 文本型, , , 
.局部变量 返回值, 整数型, , , 
.局部变量 序列号, 长整数型, , , 

 ' 说明：要进行读写操作，都要先进行“寻卡dc_card、验证卡dc_authentication”成功后方能操作，自己体会。我就老是验证不成功就是没有“寻卡dc_card”操作
 ' 十六进制的密匙 ＝ “ffffffffffff”  ' 密码为"ffffffffffff"共12位数
赋值 (返回值, dc_load_key_hex (设备号, 密码验证模式, 校验的扇区, 十六进制的密匙))
.如果 (等于 (返回值, 0))
    “调用 dc_Load_key_hex()函数成功”.加入项目 ()
.否则
    “调用 dc_Load_key_hex()函数出错”.加入项目 ()
.如果结束
赋值 (寻卡模式, 1) ' 寻卡函数 寻卡模式=1 可对卡连续操作，为0时如果执行了HBLT（中止对该卡操作）操作,则卡必须离开感应区后才能再次操作
赋值 (返回值, dc_card (设备号, 寻卡模式, 序列号))
.如果 (不等于 (返回值, 0))
    “调用 dc_card()函数出错”.加入项目 ()
.否则
    .如果 (等于 (返回值, 0))
        “调用 dc_card()函数成功”.加入项目 ()
        相加 (“序列号:”, 到文本 (序列号)).加入项目 ()
    .否则
        “没有找到卡片”.加入项目 ()
    .如果结束
    
.如果结束
赋值 (返回值, dc_authentication (设备号, 密码验证模式, 校验的扇区)) ' 检验2扇区的密码和读卡器的是否对应
.如果 (等于 (返回值, 0))
    “调用dc_authentication 函数成功”.加入项目 ()
.否则
    “调用dc_authentication 函数失败”.加入项目 ()
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 (返回值))), “设备号:”, 到文本 (设备号)))

赋值 (要写入的数据32位, 相加 (删全部空 (.内容), 删全部空 (.内容), 删全部空 (.内容), “BBBBBBBBBBBBBBBBBBBBBBBBBB”)) ' “00112233445566778899BBBBCCDDEEFF”
赋值 (操作的块地址, 相加 (相乘 (3, 4), 2)) ' 块2,M1卡-块地址（1～63）,0是固化的序列号 解析：3是扇区*4是每个扇区有4个块+2就是第2块
输出调试文本 (要写入的数据32位)
赋值 (返回值, dc_write_hex (设备号, 操作的块地址, 要写入的数据32位))
.如果 (不等于 (返回值, 0))
    “调用 dc_write_hex函数出错”.加入项目 ()
    
.否则
    “调用 dc_write_hex函数成功”.加入项目 ()
    相加 (“数据为：”, 要写入的数据32位).加入项目 ()
    dc_beep (设备号, 10)
.如果结束


.子程序 _按钮7_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 
.局部变量 缓冲区的数据, 整数型, , "32", 
.局部变量 取出的数据, 文本型, , , 
.局部变量 缓冲区地址, 长整数型, , , 
.局部变量 序列号, 长整数型, , , 

 ' 说明：要进行读操作，都要先进行“寻卡dc_card、验证卡dc_authentication”成功后方能操作，自己体会。我就老是验证不成功就是没有“寻卡dc_card”操作
 ' 十六进制的密匙 ＝ “ffffffffffff”  ' 密码为"ffffffffffff"共12位数
 ' 密码验证模式 ＝ 0  这些都放在启动时赋值了
 ' 校验的扇区 ＝ 3
 ' 操作的块地址 ＝ 3 × 4 ＋ 2  ' 块2,M1卡-块地址（1～63）,0是固化的序列号 解析：3是扇区*4是每个扇区有4个块+2就是第2块
赋值 (返回值, dc_load_key_hex (设备号, 密码验证模式, 校验的扇区, 十六进制的密匙))
.如果 (等于 (返回值, 0))
    “调用 dc_Load_key_hex()函数成功”.加入项目 ()
.否则
    “调用 dc_Load_key_hex()函数出错”.加入项目 ()
.如果结束
赋值 (寻卡模式, 1) ' 寻卡函数 寻卡模式=1 可对卡连续操作，为0时如果执行了HBLT（中止对该卡操作）操作,则卡必须离开感应区后才能再次操作
赋值 (返回值, dc_card (设备号, 寻卡模式, 序列号))
.如果 (不等于 (返回值, 0))
    “调用 dc_card()函数出错”.加入项目 ()
.否则
    .如果 (等于 (返回值, 0))
        “调用 dc_card()函数成功”.加入项目 ()
        相加 (“序列号:”, 到文本 (序列号)).加入项目 ()
    .否则
        “没有找到卡片”.加入项目 ()
    .如果结束
    
.如果结束
赋值 (返回值, dc_authentication (设备号, 密码验证模式, 校验的扇区)) ' 检验2扇区的密码和读卡器的是否对应
.如果 (等于 (返回值, 0))
    “调用dc_authentication 函数成功”.加入项目 ()
.否则
    “调用dc_authentication 函数失败”.加入项目 ()
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 (返回值))), “设备号:”, 到文本 (设备号)))
赋值 (返回值, dc_read_hex (设备号, 操作的块地址, 缓冲区的数据))
.如果 (不等于 (返回值, 0))
    “调用 dc_read_hex()函数出错”.加入项目 ()
.否则
    “调用 dc_read_hex()函数成功”.加入项目 ()
    赋值 (取出的数据, 指针到文本 (取变量地址 (缓冲区的数据 [1])))
    输出调试文本 (取出的数据)
    相加 (“完整数据为:”, 取出的数据).加入项目 ()
    相加 (“完整数据为:”, 子文本替换 (取出的数据, “B”, “”, , , 真)).加入项目 ()
    dc_beep (设备号, 10)
    
.如果结束


.子程序 _按钮8_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 

赋值 (返回值, dc_halt (设备号))
.如果 (不等于 (返回值, 0))
    “调用 dc_halt()函数出错”.加入项目 ()
.否则
    “调用 dc_halt()函数成功”.加入项目 ()
    dc_beep (设备号, 10)
.如果结束


.子程序 _按钮11_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 
.局部变量 控制字符32位, 文本型, , , 
.局部变量 序列号, 长整数型, , , 

 ' 下面例子将3扇区的A套密码从ffffffffffff
 ' 改为123456123456,然后再改回ffffffffffff
 ' 该该密码程序针对的卡型是MIFARE ONE
 ' 密码验证模式 ＝ 1
 ' 寻卡模式 ＝ 1  ' 寻卡函数 寻卡模式=1 可对卡连续操作，为0时如果执行了HBLT（中止对该卡操作）操作,则卡必须离开感应区后才能再次操作
 ' 校验的扇区 ＝ 3
.如果 (等于 (.内容, “”))
    赋值 (十六进制的密匙, “ffffffffffff”)
.否则
    赋值 (十六进制的密匙, 相加 (.内容, “FF078069FFFFFFFFFFFF”))
.如果结束
赋值 (返回值, dc_load_key_hex (设备号, 密码验证模式, 校验的扇区, 十六进制的密匙))
.如果 (不等于 (返回值, 0))
    “调用 dc_Load_key_hex()函数出错!”.加入项目 ()
.否则
    “调用 dc_Load_key_hex()函数成功!”.加入项目 ()
.如果结束
赋值 (未知函数_167838009 ())
.如果 (不等于 (0))
    “调用 dc_card()函数出错”.加入项目 ()
.否则
    .如果 (等于 (0))
        “调用 dc_card()函数成功”.加入项目 ()
        相加 (“序列号:”, 到文本 ()).加入项目 ()
    .否则
        “没有找到卡片”.加入项目 ()
    .如果结束
    
.如果结束
赋值 (未知函数_167838019 ()) ' 检验2扇区的密码和读卡器的是否对应
.如果 (等于 (0))
    “调用dc_authentication 函数成功”.加入项目 ()
.否则
    “调用dc_authentication 函数失败”.加入项目 ()
.如果结束
输出调试文本 (相加 (到文本 (相加 (“返回值:”, 到文本 ())), “设备号:”, 到文本 ()))

 ' //现在把A密码改为FFFFFFFFFFFF,B密码写为123456123456
.如果 (等于 (.内容, “”))
    赋值 (控制字符32位, “123456123456FF078069FFFFFFFFFFFF”)
.否则
    赋值 (控制字符32位, 相加 (删全部空 (.内容), “FF078069FFFFFFFFFFFF”))
.如果结束
 ' 中间的FF078069不要变，左边123456123456是A密码；FFFFFFFFFFFF是B密码
赋值 (返回值, dc_write_hex (设备号, 相加 (相乘 (3, 4), 3), 控制字符32位)) ' 每个扇区的第4个是控制操作字符，不能保存用户的的数据，只是改写密码等。。。。
.如果 (不等于 (返回值, 0))
    “调用 dc_write_hex()函数出错”.加入项目 ()
.否则
    “调用 dc_write_hex()函数成功”.加入项目 ()
    dc_beep (设备号, 10) ' 读卡器蜂鸣10毫秒
    相加 (“A密码改为了”, .内容).加入项目 ()
.如果结束


.子程序 _按钮5_被单击, 空白型, , 
.局部变量 返回值, 整数型, , , 

.如果 (大于 (返回值, 0))
    赋值 (返回值, dc_reset (设备号, 10))
    赋值 (返回值, dc_exit (设备号))
    赋值 (返回值, -1)
.否则
    
.如果结束
结束 ()


.子程序 __启动窗口_将被销毁, 空白型, , 
.局部变量 返回值, 整数型, , , 

.如果 (大于 (返回值, 0))
    赋值 (返回值, dc_reset (设备号, 10))
    赋值 (返回值, dc_exit (设备号))
    赋值 (返回值, -1)
.否则
    
.如果结束


.子程序 _按钮10_被单击, 空白型, , 
.局部变量 临时, 文本型, , , 

赋值 (临时, .内容)
赋值 (.内容, .内容)
赋值 (.内容, 临时)

.子程序 _按钮13_被单击, 空白型, , 
清空 ()

.子程序 _编辑框2_被双击, 逻辑型, , 
.参数 横向位置, 整数型, , 
.参数 纵向位置, 整数型, , 
.参数 功能键状态, 整数型, , 

.局部变量 索引, 整数型, , , 

.如果 (.选中)
    赋值 (.内容, 到文本 (相加 (到数值 (.内容), 1)))
.否则
    赋值 (.内容, 到文本 (相减 (到数值 (.内容), 1)))
.如果结束

输出调试文本 (取文本长度 (.内容))
赋值 (索引, 取文本长度 (.内容))
赋值 (.内容, 多项选择 (索引, 相加 (“0”, .内容), .内容))




 ' 不属于任何一个程序集、类模块的函数：
