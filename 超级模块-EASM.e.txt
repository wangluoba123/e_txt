 ' 文件类型：未知类型

 ' 程序名称：超级汇编模块
 ' 程序描述：注意:模块使用十六进制处理数字,
对于非正确的指令可以被此模块处理的,
执行后会出现错误,请自行注意语法..
比如 bsf eax,[ecx]是正确的,
bsf [eax],ecx 是错误的,
但模块不会认为是错误的。
另外也不要故意为难模块,
比如:mov [100+eax+ecx-99],ebx
请写成 mov [eax+ecx+1],ebx
数字一定要写在后面.
比如:mov eax,[4*eax+ecx+78]
代码间不要有多余的空格.
比如:eax , [4 *eax + ecx+78] ×
eax,[4*eax+ecx+78]           √
模块指令的识别按OD反汇编的格式来的,
其他格式可能存在无法无别.
 ' 程序作者：gmxdngc&小烦
 ' 邮政编码：
 ' 联系地址：
 ' 联系电话：
 ' 传真号码：
 ' 电子信箱：
 ' 主页地址：
 ' 版权声明：
 ' 版本号：1.0
 ' 创建号：0.0



.常量 test, "“_start:mov eax,1	|
_bq1:			|
       add eax,2	|
       imul eax,eax,8   |
       retn		|”", , 
.常量 , , , 
.常量 w_byte, "0", , 
.常量 w_word, "2", , 
.常量 w_dword, "1", , 
.常量 , , , rrr:Index Register
.常量 , , , 32bit
.常量 eax, "0", , 
.常量 ecx, "1", , 
.常量 edx, "2", , 
.常量 ebx, "3", , 
.常量 esp, "4", , No Index
.常量 ebp, "5", , 
.常量 esi, "6", , 
.常量 edi, "7", , 
.常量 , , , 8bit
.常量 al, "0", , 
.常量 cl, "1", , 
.常量 dl, "2", , 
.常量 bl, "3", , 
.常量 ah, "4", , 
.常量 ch, "5", , 
.常量 dh, "6", , 
.常量 bh, "7", , 
.常量 , , , 16bit
.常量 ax, "0", , 
.常量 cx, "1", , 
.常量 dx, "2", , 
.常量 bx, "3", , 
.常量 sp, "4", , 
.常量 bp, "5", , 
.常量 si, "6", , 
.常量 di, "7", , 
.常量 , , , oo
.常量 m_reg_oo, "0", , 
.常量 reg_disp8_oo, "1", , 
.常量 reg_disp32_oo, "2", , 
.常量 reg_oo, "3", , 
.常量 , , , 
.常量 cs, "46", , 
.常量 ds, "62", , 
.常量 es, "38", , 
.常量 fs, "100", , 
.常量 gs, "101", , 
.常量 ss, "54", , 


 ' 所需要的支持库：
 ' krnln d09f2340818511d396f6aaf844c7e325 5 3 系统核心支持库




.全局变量 ocode, 字节型, , , 

.DLL命令 lstrcpyn_字节集, 整数型, "", "lstrcpyn", , 
    .参数 欲取其指针, 字节集, 传址, 
    .参数 欲取其指针, 字节集, 传址, 
    .参数 保留, 整数型, , 0

.DLL命令 CallWindowProc, 整数型, "", "CallWindowProcA", , 
    .参数 lpPrevWndFunc, 字节集, , 
    .参数 hWnd, 整数型, , 
    .参数 Msg, 整数型, , 
    .参数 wParam, 整数型, , 
    .参数 lParam, 整数型, , 

.程序集 程序集1, , , 易语言编程论坛全新域名：http://www.360bc.cn 保留2007年用户数据至今。

.子程序 _启动子程序, 整数型, , 请在本子程序中放置易模块初始化代码
_临时子程序 () ' 在初始化代码执行完毕后调用测试代码
返回 (0) ' 可以根据您的需要返回任意数值

.子程序 _临时子程序, 空白型, , 
.局部变量 time, 空白型, , , 
.局部变量 code, 字节集, , , 

 ' 本名称子程序用作测试程序用，仅在开发及调试环境中有效，编译发布程序前将被系统自动清空，请将所有用作测试的临时代码放在本子程序中。 ***注意不要修改本子程序的名称、参数及返回值类型。
赋值 (time, 取启动时间 ())
 ' _asm_ (“mov al,cl”)
 ' _asm_ (“mov ax,word [00401000]”)
 ' _asm_ (“mov word [00401000],ax”)
 ' _asm_ (“mov eax,ecx”)
 ' _asm_ (“mov eax,[edx+ecx*4+520]”)
 ' _asm_ (“mov [ebp+eax*8-52],esp”)
 ' _asm_ (“mov byte [eax+ecx*8+52],5”)
 ' _asm_ (“mov eax,522000”)
 ' _asm_ (“mov ax,word [eax+ecx*4+5201314]”)
 ' _asm_ (“bsf eax,ecx”)
 ' _asm_ (“bsr ecx,eax”)
 ' _asm_ (“bt eax,5”)
 ' _asm_ (“btc eax,5”)
 ' _asm_ (“btr eax,5”)
 ' _asm_ (“mov byte [eax+ecx*8+4],cl”)
 ' _asm_ (“mov eax,1”)
 ' _asm_ (“mov dword [eax],10”)
 ' _asm_ (“and dword [eax],79”)
 ' _asm_ (“mov eax,ecx,1”)
 ' _asm_ (“imul eax”)
 ' _asm_ (“dec eax”)
 ' _asm_ (“lgdt [00401000]”)
 ' _asm_ (“lidt [00401000]”)
 ' _asm_ (“sbb eax,00401000”)
 ' _asm_ (#test)
 ' code ＝ GetCode ()
EASM__asm (“call eax|||jmp 5667”)
EASM__asm (“jmp _@1”)
 ' 输出调试文本  (RunCode (code, 1, 2, 3, 4))

置剪辑板文本 (EASM_GetHexCode ())
输出调试文本 (相减 (取启动时间 (), time))


.程序集 EASM, , , 易语言编程论坛全新域名：http://www.360bc.cn 保留2007年用户数据至今。

.程序集变量 g_Codes, 字节集, , , 
.子程序 EASM_AddCode, 空白型, , 
.参数 Code, 字节集, , 

赋值 (g_Codes, 相加 (g_Codes, Code))

.子程序 EASM_GetHexCode, 文本型, , 返回HEX代码
返回 (字节集到十六进制 (EASM_GetCode ()))

.子程序 EASM_GetCode, 字节集, , 返回字节集代码
返回 (g_Codes)

.子程序 EASM_NewCode, 空白型, , 清空内部数据
赋值 (g_Codes, {  })

.子程序 EASM__asm, 字节集, , 用"|"或换行符隔开多句汇编语句
.参数 Code, 文本型, , 

.局部变量 s1, 文本型, , "0", 
.局部变量 n1, 整数型, , , 
.局部变量 s0, 文本型, , "0", 
.局部变量 n, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 p1, 字节集, , , 
.局部变量 opcode, 文本型, , , 
.局部变量 s9, 文本型, , , 
.局部变量 s10, 文本型, , "0", 

赋值 (Code, 删首尾空 (Code))
赋值 (Code, 子文本替换 (Code, 字符 (9), , , , 真)) ' \t
赋值 (Code, 子文本替换 (Code, #换行符, “|”, , , 真)) ' \n
赋值 (Code, 到小写 (Code))
赋值 (s0, 分割文本 (Code, “|”, ))
赋值 (n, 取数组成员数 (s0))
.计次循环首 (n, i)
    赋值 (s0 [i], 删首尾空 (s0 [i]))
    赋值 (s1, 分割文本 (s0 [i], “ ”, ))
    赋值 (n1, 取数组成员数 (s1))
    .如果真 (小于 (n1, 1))
        到循环尾 ()
    .如果真结束
    赋值 (opcode, s1 [1])
    赋值 (s10, 分割文本 (opcode, “:”, ))
    .判断开始 (等于 (取数组成员数 (s10), 2))
         ' 输出调试文本 (“找到标签:” ＋ s10 [1])
        赋值 (opcode, s10 [2])
        赋值 (s1 [1], opcode)
        赋值 (s0 [i], 子文本替换 (s0 [i], 相加 (s10 [1], “:”), , , , 真))
    .判断 (不等于 (寻找文本 (opcode, “:”, , 假), -1))
         ' 输出调试文本 (“找到标签:” ＋ s10 [1])
        到循环尾 ()
    .默认
        
    .判断结束
    
    .判断开始 (等于 (n1, 1))
        赋值 (p1, 无操作数指令 (opcode))
        .如果真 (等于 (p1, {  }))
            输出调试文本 (相加 (“【错误】:指令”, opcode, “未知,当前代码行:”, 到文本 (i), “,代码:”, s0 [i]))
            返回 ({  })
        .如果真结束
        EASM_AddCode (p1)
    .默认
        赋值 (p1, 无操作数指令 (opcode))
        .判断开始 (并且 (不等于 (p1, {  }), 不等于 (opcode, “aad”), 不等于 (opcode, “aam”)))
            输出调试文本 (相加 (“【警告】:代码”, s0 [i], “正确写法为:”, opcode, “,当前代码行:”, 到文本 (i)))
            EASM_AddCode (p1)
        .判断 (等于 (opcode, “aad”))
            赋值 (n1, 到数值 (s1 [2]))
            .如果真 (并且 (大于或等于 (n1, -128), 小于或等于 (n1, 127)))
                EASM_AddCode (相加 ({ 213 }, 到字节集 (到字节 (n1))))
            .如果真结束
            
        .判断 (等于 (opcode, “aam”))
            赋值 (n1, 到数值 (s1 [2]))
            .如果真 (并且 (大于或等于 (n1, -128), 小于或等于 (n1, 127)))
                EASM_AddCode (相加 ({ 212 }, 到字节集 (到字节 (n1))))
            .如果真结束
            
        .默认
            .如果真 (是否为指令头 (opcode))
                赋值 (opcode, s1 [2])
                赋值 (p1, 无操作数指令 (opcode))
                .如果真 (等于 (p1, {  }))
                    输出调试文本 (相加 (“【错误】:指令”, opcode, “未知,当前代码行:”, 到文本 (i), “,代码:”, s0 [i]))
                    返回 ({  })
                .如果真结束
                EASM_AddCode (p1)
                到循环尾 ()
            .如果真结束
            赋值 (s9, 子文本替换 (s0 [i], 相加 (opcode, “ ”), , , , 真))
            赋值 (p1, 指令处理 (opcode, s9))
            .如果真 (等于 (p1, {  }))
                输出调试文本 (相加 (“【错误】:指令”, opcode, “错误,当前代码行:”, 到文本 (i), “,代码:”, s0 [i]))
                返回 ({  })
            .如果真结束
            
        .判断结束
        
    .判断结束
    
.计次循环尾 ()
返回 (EASM_GetCode ())


.子程序 无操作数指令, 字节集, , 
.参数 指令, 文本型, , 

.判断开始 (等于 (指令, “aaa”))
    返回 ({ 55 })
.判断 (等于 (指令, “aas”))
    返回 ({ 63 })
.判断 (等于 (指令, “cbw”))
    返回 ({ 102, 152 })
.判断 (等于 (指令, “cbq”))
    返回 ({ 153 })
.判断 (等于 (指令, “clc”))
    返回 ({ 248 })
.判断 (等于 (指令, “cld”))
    返回 ({ 252 })
.判断 (等于 (指令, “cli”))
    返回 ({ 250 })
.判断 (等于 (指令, “clts”))
    返回 ({ 15, 6 })
.判断 (等于 (指令, “cmc”))
    返回 ({ 245 })
.判断 (等于 (指令, “cmpsb”))
    返回 ({ 166 })
.判断 (等于 (指令, “cmpsw”))
    返回 ({ 102, 167 })
.判断 (等于 (指令, “cmpsd”))
    返回 ({ 167 })
.判断 (等于 (指令, “cpuid”))
    返回 ({ 15, 162 })
.判断 (等于 (指令, “cwd”))
    返回 ({ 102, 153 })
.判断 (等于 (指令, “cwde”))
    返回 ({ 152 })
.判断 (等于 (指令, “daa”))
    返回 ({ 39 })
.判断 (等于 (指令, “das”))
    返回 ({ 47 })
.判断 (等于 (指令, “hlt”))
    返回 ({ 244 })
.判断 (等于 (指令, “insb”))
    返回 ({ 108 })
.判断 (等于 (指令, “insw”))
    返回 ({ 102, 109 })
.判断 (等于 (指令, “insd”))
    返回 ({ 109 })
.判断 (等于 (指令, “int3”))
    返回 ({ 204 })
.判断 (等于 (指令, “into”))
    返回 ({ 206 })
.判断 (等于 (指令, “invd”))
    返回 ({ 15, 8 })
.判断 (等于 (指令, “iret”))
    返回 ({ 102, 207 })
.判断 (等于 (指令, “iretd”))
    返回 ({ 207 })
.判断 (等于 (指令, “lahf”))
    返回 ({ 159 })
.判断 (等于 (指令, “lodsb”))
    返回 ({ 172 })
.判断 (等于 (指令, “lodsw”))
    返回 ({ 102, 173 })
.判断 (等于 (指令, “lodsd”))
    返回 ({ 173 })
.判断 (等于 (指令, “movsb”))
    返回 ({ 164 })
.判断 (等于 (指令, “movsw”))
    返回 ({ 102, 165 })
.判断 (等于 (指令, “movsd”))
    返回 ({ 165 })
.判断 (等于 (指令, “nop”))
    返回 ({ 144 })
.判断 (等于 (指令, “outsb”))
    返回 ({ 110 })
.判断 (等于 (指令, “outsw”))
    返回 ({ 102, 111 })
.判断 (等于 (指令, “outsd”))
    返回 ({ 111 })
.判断 (等于 (指令, “popa”))
    返回 ({ 102, 97 })
.判断 (等于 (指令, “popad”))
    返回 ({ 97 })
.判断 (等于 (指令, “popf”))
    返回 ({ 102, 157 })
.判断 (等于 (指令, “popfd”))
    返回 ({ 157 })
.判断 (等于 (指令, “pusha”))
    返回 ({ 102, 96 })
.判断 (等于 (指令, “pushad”))
    返回 ({ 96 })
.判断 (等于 (指令, “pushf”))
    返回 ({ 102, 156 })
.判断 (等于 (指令, “pushfd”))
    返回 ({ 156 })
.判断 (等于 (指令, “rdmsr”))
    返回 ({ 15, 50 })
.判断 (等于 (指令, “rdpmc”))
    返回 ({ 15, 51 })
.判断 (等于 (指令, “rsm”))
    返回 ({ 15, 170 })
.判断 (等于 (指令, “salc”))
    返回 ({ 214 })
.判断 (等于 (指令, “sahf”))
    返回 ({ 158 })
.判断 (等于 (指令, “scasb”))
    返回 ({ 174 })
.判断 (等于 (指令, “scasw”))
    返回 ({ 102, 175 })
.判断 (等于 (指令, “scasd”))
    返回 ({ 175 })
.判断 (等于 (指令, “stc”))
    返回 ({ 249 })
.判断 (等于 (指令, “std”))
    返回 ({ 253 })
.判断 (等于 (指令, “sti”))
    返回 ({ 251 })
.判断 (等于 (指令, “stosb”))
    返回 ({ 170 })
.判断 (等于 (指令, “stosw”))
    返回 ({ 102, 171 })
.判断 (等于 (指令, “stosd”))
    返回 ({ 171 })
.判断 (等于 (指令, “wait”))
    返回 ({ 155 })
.判断 (等于 (指令, “wbinvd”))
    返回 ({ 15, 9 })
.判断 (等于 (指令, “wrmsr”))
    返回 ({ 15, 48 })
.判断 (等于 (指令, “xlat”))
    返回 ({ 215 })
.判断 (等于 (指令, “aad”))
    返回 ({ 213, 10 })
.判断 (等于 (指令, “aam”))
    返回 ({ 212, 10 })
.判断 (等于 (指令, “leave”))
    返回 ({ 201 })
.判断 (等于 (指令, “retn”))
    返回 ({ 195 })
.默认
    
.判断结束
返回 ({  })

.子程序 指令处理, 字节集, , 
.参数 opcode, 文本型, , 
.参数 操作数信息, 文本型, , 

.局部变量 s0, 文本型, , "0", 
.局部变量 n0, 整数型, , , 
.局部变量 s1, 文本型, , "0", 
.局部变量 n1, 整数型, , , 
.局部变量 t1, 文本型, , , 
.局部变量 w, 字节型, , , 
.局部变量 i, 整数型, , , 
.局部变量 n2, 字节型, , , 
.局部变量 s11, 文本型, , "0", 
.局部变量 db, 字节集, , , 
.局部变量 Mem, 逻辑型, , , 
.局部变量 s22, 文本型, , "0", 
.局部变量 f22, 整数型, , "0", 
.局部变量 f21, 整数型, , "0", 
.局部变量 s21, 文本型, , "0", 
.局部变量 rMem, 逻辑型, , , 
.局部变量 t, 字节型, , , 
.局部变量 limm, 整数型, , , 
.局部变量 lreg, 逻辑型, , , 
.局部变量 sib, 字节型, , , 
.局部变量 sibi, 整数型, , , 
.局部变量 rimm, 整数型, , , 
.局部变量 rreg, 逻辑型, , , 
.局部变量 oo, 字节型, , , 
.局部变量 imm, 整数型, , , 
.局部变量 lregs, 整数型, , "0", 
.局部变量 x, 整数型, , , 
.局部变量 rregs, 整数型, , "0", 
.局部变量 regs, 整数型, , "0", 
.局部变量 code, 字节集, , , 
.局部变量 p1, 整数型, , , 
.局部变量 p2, 整数型, , , 
.局部变量 treg, 整数型, , , 
.局部变量 pb1, 字节集, , , 
.局部变量 b1, 逻辑型, , , 
.局部变量 opr, 整数型, , , 
.局部变量 qz, 文本型, , , 
.局部变量 jcq, 整数型, , , 
.局部变量 dsture, 逻辑型, , , 


赋值 (s0, 分割文本 (操作数信息, “,”, ))
赋值 (n0, 取数组成员数 (s0))
.如果真 (不等于 (n0, 2))
    .如果真 (等于 (n0, 1))
        .判断开始 (或者 (等于 (opcode, “dec”), 等于 (opcode, “inc”), 等于 (opcode, “pop”), 等于 (opcode, “push”)))
            赋值 (treg, 判断寄存器 (s0 [1], w))
            .如果真 (不等于 (treg, 55))
                赋值 (Mem, 寄存器16位判断 (s0 [1]))
                赋值 (p1, regword_opcode (opcode))
                .如果真 (等于 (p1, -1))
                    返回 ({  })
                .如果真结束
                赋值 (code, regword (p1, treg, Mem, GetOpr2 (opcode)))
                返回 (code)
            .如果真结束
            
        .判断 (等于 (opcode, “int”))
            赋值 (code, 相加 ({ 205 }, 到字节集 (到字节 (HexToInt (操作数信息)))))
            EASM_AddCode (code)
            返回 (code)
        .判断 (等于 (opcode, “ret”))
            赋值 (code, 相加 ({ 194 }, 到字节集 (到短整数 (HexToInt (操作数信息)))))
            EASM_AddCode (code)
            返回 (code)
        .默认
            
        .判断结束
        
    .如果真结束
    赋值 (操作数信息, 相加 (操作数信息, “,0”))
    赋值 (s0, 分割文本 (操作数信息, “,”, ))
    赋值 (n0, 取数组成员数 (s0))
.如果真结束
 ' ''''''''''''''''
赋值 (w, 55)
赋值 (db, {  })
 ' '''''''''解析左边
赋值 (s1, 分割文本 (s0 [1], “ ”, ))
赋值 (n1, 取数组成员数 (s1))
.判断开始 (等于 (n1, 1))
    赋值 (t1, s1 [1])
    .如果真 (或者 (等于 (取文本左边 (t1, 1), “[”), 不等于 (寻找文本 (t1, “[”, , 假), -1)))
        赋值 (w, #w_dword) ' 默认32位
        赋值 (Mem, 真) ' 大小已确认
    .如果真结束
    赋值 (t1, 子文本替换 (t1, “[”, , , , 真))
    赋值 (t1, 子文本替换 (t1, “]”, , , , 真)) ' 去掉中括号[]
    赋值 (s11, 分割文本 (t1, “:”, )) ' 获取段标识
    .如果真 (等于 (取数组成员数 (s11), 2))
        赋值 (db, 获取段标识数据 (s11 [1]))
        .如果真 (等于 (db, {  }))
            输出调试文本 (相加 (“【警告】:未知的前缀”, s11 [1], “,代码:”, opcode, “ ”, 操作数信息))
        .如果真结束
        赋值 (qz, s11 [1])
        赋值 (t1, s11 [2])
    .如果真结束
    获取操作数 (t1, s21, f21)
    .如果真 (等于 (Mem, 假))
        .如果真 (大于或等于 (取数组成员数 (f21), 1))
            输出调试文本 (相加 (“【错误】:操作数后有多余输入,代码:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .如果真结束
        
    .如果真结束
    
.默认
    .计次循环首 (n1, i)
        .判断开始 (等于 (s1 [i], “byte”))
            赋值 (w, #w_byte)
            赋值 (Mem, 真)
        .判断 (等于 (s1 [i], “word”))
            赋值 (w, #w_word)
            赋值 (Mem, 真)
        .判断 (等于 (s1 [i], “dword”))
            赋值 (w, #w_dword)
            赋值 (Mem, 真)
        .判断 (等于 (s1 [i], “qword”))
            赋值 (w, #w_dword)
            赋值 (Mem, 真)
        .判断 (等于 (i, n1))
            赋值 (t1, s1 [i])
            赋值 (t1, 子文本替换 (t1, “[”, , , , 真))
            赋值 (t1, 子文本替换 (t1, “]”, , , , 真)) ' 去掉中括号[]
            赋值 (s11, 分割文本 (t1, “:”, )) ' 获取段标识
            .如果真 (等于 (取数组成员数 (s11), 2))
                赋值 (db, 获取段标识数据 (s11 [1]))
                .如果真 (等于 (db, {  }))
                    输出调试文本 (相加 (“【警告】:未知的前缀”, s11 [1], “,代码:”, opcode, “ ”, 操作数信息))
                .如果真结束
                赋值 (t1, s11 [2])
            .如果真结束
            获取操作数 (t1, s21, f21)
            .如果真 (等于 (Mem, 假))
                .如果真 (大于或等于 (取数组成员数 (f21), 1))
                    输出调试文本 (相加 (“【错误】:操作数后有多余输入,代码:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
                    返回 ({  })
                .如果真结束
                
            .如果真结束
            跳出循环 ()
        .判断 (不等于 (s1 [i], “ptr”))
            输出调试文本 (相加 (“【警告】:未知的标识”, s1 [i], “,代码:”, opcode, “ ”, 操作数信息))
        .默认
            
        .判断结束
        
    .计次循环尾 ()
.判断结束

 ' '''''''''解析右边
赋值 (s1, 分割文本 (s0 [2], “ ”, ))
赋值 (n1, 取数组成员数 (s1))
.判断开始 (等于 (n1, 1))
    赋值 (t1, s1 [1])
    .如果真 (或者 (等于 (取文本左边 (t1, 1), “[”), 不等于 (寻找文本 (t1, “[”, , 假), -1)))
        .如果真 (等于 (Mem, 真))
            输出调试文本 (相加 (“【错误】:命令不支持所给操作数:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .如果真结束
        赋值 (w, #w_dword) ' 默认32位
        赋值 (rMem, 真)
    .如果真结束
    赋值 (t1, 子文本替换 (t1, “[”, , , , 真))
    赋值 (t1, 子文本替换 (t1, “]”, , , , 真)) ' 去掉中括号[]
    赋值 (s11, 分割文本 (t1, “:”, )) ' 获取段标识
    .如果真 (等于 (取数组成员数 (s11), 2))
        赋值 (db, 获取段标识数据 (s11 [1]))
        .如果真 (等于 (db, {  }))
            输出调试文本 (相加 (“【警告】:未知的前缀”, s11 [1], “,代码:”, opcode, “ ”, 操作数信息))
        .如果真结束
        赋值 (t1, s11 [2])
        赋值 (qz, s11 [1])
    .如果真结束
    获取操作数 (t1, s22, f22)
    .如果真 (等于 (rMem, 假))
        .如果真 (大于或等于 (取数组成员数 (f22), 1))
            输出调试文本 (相加 (“【错误】:操作数后有多余输入,代码:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .如果真结束
        
    .如果真结束
    
.默认
    .计次循环首 (n1, i)
        .判断开始 (等于 (s1 [i], “byte”))
            .如果真 (Mem)
                输出调试文本 (相加 (“【错误】:命令不支持所给操作数:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
                返回 ({  })
            .如果真结束
            赋值 (w, #w_byte)
            赋值 (rMem, 真)
        .判断 (等于 (s1 [i], “word”))
            .如果真 (Mem)
                输出调试文本 (相加 (“【错误】:命令不支持所给操作数:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
                返回 ({  })
            .如果真结束
            赋值 (w, #w_word)
            赋值 (rMem, 真)
        .判断 (等于 (s1 [i], “dword”))
            .如果真 (Mem)
                输出调试文本 (相加 (“【错误】:命令不支持所给操作数:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
                返回 ({  })
            .如果真结束
            赋值 (w, #w_dword)
            赋值 (rMem, 真)
        .判断 (等于 (s1 [i], “qword”))
            .如果真 (Mem)
                输出调试文本 (相加 (“【错误】:命令不支持所给操作数:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
                返回 ({  })
            .如果真结束
            赋值 (w, #w_dword)
            赋值 (rMem, 真)
        .判断 (等于 (i, n1))
            赋值 (t1, s1 [i])
            赋值 (t1, 子文本替换 (t1, “[”, , , , 真))
            赋值 (t1, 子文本替换 (t1, “]”, , , , 真)) ' 去掉中括号[]
            赋值 (s11, 分割文本 (t1, “:”, )) ' 获取段标识
            .如果真 (等于 (取数组成员数 (s11), 2))
                赋值 (db, 获取段标识数据 (s11 [1]))
                .如果真 (等于 (db, {  }))
                    输出调试文本 (相加 (“【警告】:未知的前缀”, s11 [1], “,代码:”, opcode, “ ”, 操作数信息))
                .如果真结束
                赋值 (qz, s11 [1])
                赋值 (t1, s11 [2])
            .如果真结束
            获取操作数 (t1, s22, f22)
            .如果真 (等于 (rMem, 假))
                .如果真 (大于或等于 (取数组成员数 (f22), 1))
                    输出调试文本 (相加 (“【错误】:操作数后有多余输入,代码:”, t1, “,代码:”, opcode, “ ”, 操作数信息))
                    返回 ({  })
                .如果真结束
                
            .如果真结束
            
            跳出循环 ()
        .判断 (不等于 (s1 [i], “ptr”))
            输出调试文本 (相加 (“【警告】:未知的标识[”, s1 [i], “],代码:”, opcode, “ ”, 操作数信息))
        .默认
            
        .判断结束
        
    .计次循环尾 ()
.判断结束

 ' '''''''''''
赋值 (sibi, 0)
.计次循环首 (取数组成员数 (s21), i)
    赋值 (n1, 判断寄存器 (s21 [i], t))
    .判断开始 (等于 (n1, 55))
        赋值 (limm, HexToInt (s21 [i])) ' left imm
        .判断开始 (等于 (i, 1)) ' 数字在前面撒
            赋值 (sibi, 1)
            .如果真 (等于 (取数组成员数 (f22), 0))
                到循环尾 ()
            .如果真结束
            .判断开始 (等于 (f21 [1], 2))
                赋值 (limm, 相减 (0, limm))
            .判断 (等于 (f21 [1], 3))
                .判断开始 (等于 (limm, 2))
                    赋值 (sib, 1)
                .判断 (等于 (limm, 4))
                    赋值 (sib, 2)
                .判断 (等于 (limm, 8))
                    赋值 (sib, 3)
                .默认
                    输出调试文本 (相加 (“【错误】:同学->乘法只有*2,*4,*8,代码:”, opcode, “ ”, 操作数信息))
                .判断结束
                赋值 (limm, 0)
            .默认
                
            .判断结束
            
        .判断 (等于 (f21 [相减 (i, 1)], 2))
            赋值 (limm, 相减 (0, limm))
        .判断 (等于 (f21 [相减 (i, 1)], 3))
            .判断开始 (等于 (limm, 2))
                赋值 (sib, 1)
            .判断 (等于 (limm, 4))
                赋值 (sib, 2)
            .判断 (等于 (limm, 8))
                赋值 (sib, 3)
            .默认
                输出调试文本 (相加 (“【错误】:同学->乘法只有*2,*4,*8,代码:”, opcode, “ ”, 操作数信息))
            .判断结束
            赋值 (limm, 0)
        .默认
            
        .判断结束
        
    .默认
        赋值 (lreg, 真) ' left reg
        .如果真 (等于 (w, 55))
            赋值 (w, t)
        .如果真结束
        
        .判断开始 (Mem)
            .如果真 (不等于 (t, 1))
                输出调试文本 (相加 (“【错误】:无效的地址标识[”, s21 [i], “],代码:”, opcode, “ ”, 操作数信息))
                返回 ({  })
            .如果真结束
            
        .判断 (不等于 (w, t))
            输出调试文本 (相加 (“【错误】:操作数大小不一致,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .默认
            
        .判断结束
        
        赋值 (x, 取数组成员数 (lregs))
        .判断开始 (大于或等于 (相加 (x, 1), 3))
            输出调试文本 (相加 (“【错误】:寄存器太多.,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .默认
            加入成员 (lregs, n1)
        .判断结束
        加入成员 (regs, n1)
        
    .判断结束
    
.计次循环尾 ()

 ' '''''''''''
赋值 (sibi, 0)
.计次循环首 (取数组成员数 (s22), i)
    赋值 (n1, 判断寄存器 (s22 [i], t))
    .判断开始 (等于 (n1, 55))
        赋值 (rimm, HexToInt (s22 [i])) ' right imm
        .判断开始 (等于 (i, 1)) ' 数字在前面撒
            赋值 (sibi, 1)
            .如果真 (等于 (取数组成员数 (f22), 0))
                到循环尾 ()
            .如果真结束
            .判断开始 (等于 (f22 [1], 2))
                赋值 (rimm, 相减 (0, rimm))
            .判断 (等于 (f22 [1], 3))
                .判断开始 (等于 (rimm, 2))
                    赋值 (sib, 1)
                .判断 (等于 (rimm, 4))
                    赋值 (sib, 2)
                .判断 (等于 (rimm, 8))
                    赋值 (sib, 3)
                .默认
                    输出调试文本 (相加 (“【错误】:同学->乘法只有*2,*4,*8,代码:”, opcode, “ ”, 操作数信息))
                .判断结束
                赋值 (rimm, 0)
            .默认
                
            .判断结束
            
        .判断 (等于 (f22 [相减 (i, 1)], 2))
            赋值 (rimm, 相减 (0, rimm))
        .判断 (等于 (f22 [相减 (i, 1)], 3))
            .判断开始 (等于 (rimm, 2))
                赋值 (sib, 1)
            .判断 (等于 (rimm, 4))
                赋值 (sib, 2)
            .判断 (等于 (rimm, 8))
                赋值 (sib, 3)
            .默认
                输出调试文本 (相加 (“【错误】:同学->乘法只有*2,*4,*8,代码:”, opcode, “ ”, 操作数信息))
            .判断结束
            赋值 (limm, 0)
        .默认
            
        .判断结束
        
    .默认
        赋值 (rreg, 真) ' right reg
        .如果真 (等于 (w, 55))
            赋值 (w, t)
        .如果真结束
        .判断开始 (rMem)
            .如果真 (不等于 (t, 1))
                输出调试文本 (相加 (“【错误】:无效的地址标识[”, s22 [i], “],代码:”, opcode, “ ”, 操作数信息))
                返回 ({  })
            .如果真结束
            
        .判断 (不等于 (w, t))
            输出调试文本 (相加 (“【错误】:操作数大小不一致,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .默认
            
        .判断结束
        
        赋值 (x, 取数组成员数 (rregs))
        .判断开始 (大于或等于 (相加 (x, 1), 3))
            输出调试文本 (相加 (“【错误】:寄存器太多.,代码:”, opcode, “ ”, 操作数信息))
            返回 ({  })
        .默认
            加入成员 (rregs, n1)
        .判断结束
        加入成员 (regs, n1)
        
    .判断结束
    
.计次循环尾 ()

 ' 输出调试文本 (lreg, limm, Mem, rreg, rimm, rMem)
.如果真 (不等于 (qz, “”))
    .判断开始 (等于 (Mem, 真))
        赋值 (x, 取数组成员数 (lregs))
        .判断开始 (等于 (x, 1))
            赋值 (jcq, lregs [1])
            .判断开始 (等于 (qz, “ds”))
                .如果真 (或者 (不等于 (jcq, #ebp), 不等于 (jcq, #esp)))
                    EASM_AddCode (db)
                .如果真结束
                
            .判断 (等于 (qz, “ss”))
                .如果真 (或者 (等于 (jcq, #ebp), 等于 (jcq, #esp)))
                    EASM_AddCode (db)
                .如果真结束
                
            .默认
                EASM_AddCode (db)
            .判断结束
            
        .默认
            .计次循环首 (x, i)
                赋值 (jcq, lregs [i])
                .判断开始 (等于 (qz, “ds”))
                    .判断开始 (不等于 (jcq, #esp))
                        赋值 (dsture, 真)
                    .默认
                        赋值 (dsture, 假)
                        跳出循环 ()
                    .判断结束
                    
                .判断 (等于 (qz, “ss”))
                    .判断开始 (不等于 (jcq, #esp))
                        赋值 (dsture, 假)
                    .默认
                        赋值 (dsture, 真)
                        跳出循环 ()
                    .判断结束
                    
                .默认
                    赋值 (dsture, 真)
                    跳出循环 ()
                .判断结束
                
            .计次循环尾 ()
            .如果真 (等于 (dsture, 假))
                EASM_AddCode (db)
            .如果真结束
            
        .判断结束
        
    .判断 (等于 (rMem, 真))
        赋值 (x, 取数组成员数 (rregs))
        .判断开始 (等于 (x, 1))
            赋值 (jcq, rregs [1])
            .判断开始 (等于 (qz, “ds”))
                .如果真 (或者 (不等于 (jcq, #ebp), 不等于 (jcq, #esp)))
                    EASM_AddCode (db)
                .如果真结束
                
            .判断 (等于 (qz, “ss”))
                .如果真 (或者 (等于 (jcq, #ebp), 等于 (jcq, #esp)))
                    EASM_AddCode (db)
                .如果真结束
                
            .默认
                EASM_AddCode (db)
            .判断结束
            
        .默认
            .计次循环首 (x, i)
                赋值 (jcq, rregs [i])
                .判断开始 (等于 (qz, “ds”))
                    .判断开始 (不等于 (jcq, #esp))
                        赋值 (dsture, 真)
                    .默认
                        赋值 (dsture, 假)
                        跳出循环 ()
                    .判断结束
                    
                .判断 (等于 (qz, “ss”))
                    .判断开始 (不等于 (jcq, #esp))
                        赋值 (dsture, 假)
                    .默认
                        赋值 (dsture, 真)
                        跳出循环 ()
                    .判断结束
                    
                .默认
                    赋值 (dsture, 真)
                    跳出循环 ()
                .判断结束
                
            .计次循环尾 ()
            .如果真 (等于 (dsture, 假))
                EASM_AddCode (db)
            .如果真结束
            
        .判断结束
        
    .默认
        
    .判断结束
    
.如果真结束

.判断开始 (等于 (opcode, “invlpg”))
    .判断开始 (并且 (等于 (Mem, 真), 等于 (lreg, 假)))
        赋值 (code, 相加 ({ 15, 1, 61 }, 到字节集 (limm)))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (等于 (Mem, 真), 等于 (lreg, 真)))
        赋值 (code, { 15 })
        EASM_AddCode (code)
        赋值 (n1, 取数组成员数 (regs))
        .判断开始 (等于 (n1, 1))
            赋值 (code, mem_imm (0, #w_dword, , 0, regs [1], , limm, , 7, #m_reg_oo, , ocode))
        .判断 (等于 (n1, 2))
            赋值 (code, mem_imm (0, #w_dword, , 0, regs [1], regs [2], limm, sib, 7, #m_reg_oo, , ocode))
        .默认
            
        .判断结束
        返回 (code)
    .默认
        
    .判断结束
    
.判断 (等于 (opcode, “lgdt”))
    .判断开始 (并且 (等于 (Mem, 真), 等于 (lreg, 假)))
        赋值 (code, 相加 ({ 15, 1, 21 }, 到字节集 (limm)))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (等于 (Mem, 真), 等于 (lreg, 真)))
        赋值 (code, { 15 })
        EASM_AddCode (code)
        赋值 (n1, 取数组成员数 (regs))
        .判断开始 (等于 (n1, 1))
            赋值 (code, mem_imm (0, #w_dword, , 0, regs [1], , limm, , 2, #m_reg_oo, 假, ocode))
        .判断 (等于 (n1, 2))
            赋值 (code, mem_imm (0, #w_dword, , 0, regs [1], regs [2], limm, sib, 2, #m_reg_oo, 假, ocode))
        .默认
            
        .判断结束
        返回 (code)
    .默认
        
    .判断结束
    
.判断 (等于 (opcode, “lidt”))
    .判断开始 (并且 (等于 (Mem, 真), 等于 (lreg, 假)))
        赋值 (code, 相加 ({ 15, 1, 29 }, 到字节集 (limm)))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (等于 (Mem, 真), 等于 (lreg, 真)))
        赋值 (code, { 15 })
        EASM_AddCode (code)
        赋值 (n1, 取数组成员数 (regs))
        .判断开始 (等于 (n1, 1))
            赋值 (code, mem_imm (0, #w_dword, , 0, regs [1], , limm, , 3, #m_reg_oo, , ocode))
        .判断 (等于 (n1, 2))
            赋值 (code, mem_imm (0, #w_dword, , 0, regs [1], regs [2], limm, sib, 3, #m_reg_oo, , ocode))
        .默认
            
        .判断结束
        返回 (code)
    .默认
        
    .判断结束
    
.判断 (等于 (opcode, “push”))
    .如果真 (并且 (等于 (Mem, 假), 等于 (lreg, 假)))
        .判断开始 (并且 (大于或等于 (limm, -128), 小于或等于 (limm, 127)))
            赋值 (code, 相加 ({ 106 }, 到字节集 (到字节 (limm))))
        .默认
            赋值 (code, 相加 ({ 104 }, 到字节集 (limm)))
        .判断结束
        EASM_AddCode (code)
        返回 (code)
    .如果真结束
    
.判断 (等于 (opcode, “call”))
    .判断开始 (并且 (等于 (Mem, 假), 等于 (lreg, 假)))
        赋值 (code, 相加 ({ 232 }, 到字节集 (limm)))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (等于 (Mem, 假), lreg))
        赋值 (code, 相加 ({ 255 }, 到字节集 (到字节 (相加 (208, regs [1])))))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (Mem, 等于 (lreg, 假)))
        赋值 (code, 相加 ({ 255, 21 }, 到字节集 (limm)))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (Mem, lreg))
        赋值 (n1, 取数组成员数 (regs))
    .默认
        
    .判断结束
    
.判断 (等于 (opcode, “jmp”))
    .判断开始 (并且 (等于 (Mem, 假), 等于 (lreg, 假)))
         ' code ＝ { 235 } ＋ 到字节集 (limm)  'jmp imm8
         ' AddCode (code)
        返回 (code)
    .判断 (并且 (等于 (Mem, 假), lreg))
        赋值 (code, 相加 ({ 255 }, 到字节集 (到字节 (相加 (224, regs [1])))))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (Mem, 等于 (lreg, 假)))
        赋值 (code, 相加 ({ 255, 32 }, 到字节集 (limm)))
        EASM_AddCode (code)
        返回 (code)
    .判断 (并且 (Mem, lreg))
        赋值 (n1, 取数组成员数 (regs))
    .默认
        
    .判断结束
    
.默认
    
.判断结束


.判断开始 (并且 (lreg, rreg)) ' reg_reg
    
    .判断开始 (等于 (opcode, “in”))
        .如果真 (或者 (并且 (等于 (regs [1], 0), 等于 (s22 [1], “edx”)), 等于 (s22 [1], “dl”), 等于 (s22 [1], “dx”)))
            .判断开始 (寄存器8位判断 (s21 [1]))
                EASM_AddCode ({ 236 })
            .判断 (寄存器16位判断 (s21 [1]))
                EASM_AddCode ({ 102, 237 })
            .默认
                EASM_AddCode ({ 237 })
            .判断结束
            返回 ({ 1 })
        .如果真结束
        返回 ({  })
    .判断 (等于 (opcode, “out”))
        .如果真 (或者 (并且 (等于 (regs [1], #edx), 等于 (s22 [1], “eax”)), 等于 (s22 [1], “al”), 等于 (s22 [1], “ax”)))
            .判断开始 (寄存器8位判断 (s22 [1]))
                EASM_AddCode ({ 238 })
            .判断 (寄存器16位判断 (s22 [1]))
                EASM_AddCode ({ 102, 239 })
            .默认
                EASM_AddCode ({ 239 })
            .判断结束
            返回 ({ 1 })
        .如果真结束
        返回 ({  })
    .默认
        
    .判断结束
    
    赋值 (p1, reg_reg_OpCode (opcode))
    .如果真 (等于 (p1, -1))
        返回 ({  })
    .如果真结束
    .判断开始 (或者 (Mem, rMem))
        赋值 (imm, rimm)
        .如果真 (Mem)
            赋值 (imm, limm)
        .如果真结束
        
        .判断开始 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
            赋值 (oo, #reg_disp8_oo)
        .默认
            赋值 (oo, #reg_disp32_oo)
        .判断结束
        
        .如果真 (等于 (imm, 0))
            赋值 (oo, #m_reg_oo)
        .如果真结束
        赋值 (n1, 取数组成员数 (regs))
        
        .判断开始 (等于 (p1, -8))
            赋值 (p1, reg1632_mem1632_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            
            .判断开始 (并且 (等于 (n1, 2), rMem))
                赋值 (code, reg1632_mem1632 (p1, regs [1], regs [2], , rimm, 等于 (w, 2), , sib))
            .判断 (并且 (等于 (n1, 3), rMem))
                赋值 (code, reg1632_mem1632 (p1, regs [1], regs [2], , rimm, 等于 (w, 2), regs [3], sib))
                返回 (code)
            .默认
                
            .判断结束
            
        .判断 (等于 (p1, -2))
            赋值 (p1, reg16_reg16_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            .判断开始 (并且 (等于 (n1, 2), rMem))
                赋值 (code, reg16_reg16 (p1, oo, regs [1], regs [2], imm, , , sib, 等于 (w, 1), ocode))
            .判断 (并且 (等于 (n1, 3), rMem))
                赋值 (code, reg16_reg16 (p1, oo, regs [1], #esp, imm, regs [3], regs [2], sib, 等于 (w, 1), ocode))
            .判断 (等于 (n1, 2))
                赋值 (code, reg16_reg16 (p1, oo, regs [2], regs [1], imm, , , sib, 等于 (w, 1), ocode))
            .判断 (等于 (n1, 3))
                赋值 (code, reg16_reg16 (p1, oo, regs [3], #esp, imm, regs [2], regs [1], sib, 等于 (w, 1), ocode))
            .默认
                
            .判断结束
            
        .判断 (等于 (p1, -3))
            赋值 (p1, regword_regword_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            .判断开始 (并且 (等于 (n1, 2), rMem))
                赋值 (code, regword_regword (p1, oo, regs [1], regs [2], imm, , , sib, 等于 (w, 1), ocode))
            .判断 (并且 (等于 (n1, 3), rMem))
                赋值 (code, regword_regword (p1, oo, regs [1], #esp, imm, regs [3], regs [2], sib, 等于 (w, 1), ocode))
            .判断 (等于 (n1, 2))
                赋值 (code, regword_regword (p1, oo, regs [2], regs [1], imm, , , sib, 等于 (w, 1), ocode))
            .判断 (等于 (n1, 3))
                赋值 (code, regword_regword (p1, oo, regs [3], #esp, imm, regs [2], regs [1], sib, 等于 (w, 1), ocode))
            .默认
                
            .判断结束
            
        .判断 (并且 (等于 (n1, 2), rMem))
            赋值 (code, reg_reg (p1, w, oo, regs [1], regs [2], imm, , , Mem, sib, ocode))
        .判断 (并且 (等于 (n1, 3), rMem))
            赋值 (code, reg_reg (p1, w, oo, regs [1], #esp, imm, regs [3], regs [2], Mem, sib, ocode))
        .判断 (等于 (n1, 2))
            赋值 (opr, GetOpr (opcode, b1))
            .判断开始 (b1)
                .如果真 (rreg)
                    赋值 (p1, 相加 (p1, 2))
                .如果真结束
                赋值 (code, reg_reg (p1, w, oo, opr, regs [1], imm, , , Mem, sib, ocode))
            .默认
                赋值 (code, reg_reg (p1, w, oo, regs [2], regs [1], imm, , , Mem, sib, ocode))
            .判断结束
            
        .判断 (等于 (n1, 3))
            赋值 (opr, GetOpr (opcode, b1))
            .判断开始 (b1)
                .如果真 (rreg)
                    赋值 (p1, 相加 (p1, 2))
                .如果真结束
                赋值 (code, reg_reg (p1, w, oo, opr, #esp, imm, regs [2], regs [1], Mem, sib, ocode))
            .默认
                赋值 (code, reg_reg (p1, w, oo, regs [3], #esp, imm, regs [2], regs [1], Mem, sib, ocode))
            .判断结束
            
        .默认
            
        .判断结束
        
    .判断 (并且 (等于 (Mem, 假), 等于 (rMem, 假)))
        .判断开始 (等于 (p1, -2))
            赋值 (p1, reg16_reg16_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            赋值 (code, reg16_reg16 (p1, #reg_oo, regs [2], regs [1], imm, , , , , ocode))
        .判断 (等于 (p1, -3))
            赋值 (p1, regword_regword_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            .判断开始 (等于 (opcode, “imul”))
                .判断开始 (大于或等于 (n0, 3))
                    赋值 (imm, HexToInt (s0 [3]))
                .判断 (并且 (大于或等于 (n0, 2), 等于 (rreg, 假)))
                    赋值 (imm, HexToInt (s0 [2]))
                .默认
                    
                .判断结束
                赋值 (p1, regword_regword_immx (opcode, imm))
                赋值 (code, regword_regword2 (p1, #reg_oo, regs [2], regs [1], imm, , , , 等于 (t, 1), ocode))
                .判断开始 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
                    EASM_AddCode (到字节集 (到字节 (imm)))
                .默认
                    EASM_AddCode (到字节集 (imm))
                .判断结束
                
            .默认
                赋值 (code, regword_regword (p1, #reg_oo, regs [2], regs [1], imm, , , , 等于 (t, 1), ocode))
            .判断结束
            
        .判断 (等于 (opcode, “imul”))
            .判断开始 (大于或等于 (n0, 3))
                赋值 (imm, HexToInt (s0 [3]))
            .判断 (并且 (大于或等于 (n0, 2), 等于 (rreg, 假)))
                赋值 (imm, HexToInt (s0 [2]))
            .默认
                
            .判断结束
            赋值 (p1, regword_regword_immx (opcode, imm))
            赋值 (code, regword_regword2 (p1, #reg_oo, regs [1], regs [2], imm, , , , 等于 (t, 1), ocode))
            .判断开始 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
                EASM_AddCode (到字节集 (到字节 (imm)))
            .默认
                EASM_AddCode (到字节集 (imm))
            .判断结束
            
        .默认
            .如果真 (或者 (等于 (opcode, “movsx”), 等于 (opcode, “movzx”)))
                .如果真 (等于 (w, 2))
                    赋值 (p1, 相加 (p1, 1))
                .如果真结束
                
            .如果真结束
            赋值 (opr, GetOpr (opcode, b1))
            .判断开始 (b1)
                .如果真 (rreg)
                    赋值 (p1, 相加 (p1, 2))
                .如果真结束
                赋值 (code, reg_reg (p1, w, #reg_oo, opr, regs [1], , , , , , ocode))
            .默认
                赋值 (code, reg_reg (p1, w, #reg_oo, regs [1], regs [2], imm, , , , , ocode))
            .判断结束
            
            
        .判断结束
        
    .默认
        
    .判断结束
    
.判断 (并且 (lreg, 等于 (rreg, 假))) ' reg_mem reg_immx
    赋值 (n1, 取数组成员数 (regs))
    .如果真 (小于 (n1, 1))
        输出调试文本 (“模块出现错误..”)
        返回 ({  })
    .如果真结束
    .判断开始 (并且 (rMem, 等于 (rreg, 假)))
        .如果真 (rMem)
            赋值 (p1, reg_mem_OpCode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            
            .判断开始 (等于 (p1, -8))
                赋值 (p1, reg1632_mem1632_opcode (opcode))
                .如果真 (等于 (p1, -1))
                    返回 ({  })
                .如果真结束
                .如果真 (rMem)
                    赋值 (code, reg1632_mem1632 (p1, regs [1], , rimm, , 等于 (w, 2), , ))
                    返回 (code)
                .如果真结束
                
                
            .判断 (等于 (p1, -7))
                赋值 (p1, regword_memword_opcode (opcode))
                .判断开始 (大于或等于 (n0, 3))
                    赋值 (imm, HexToInt (s0 [3]))
                    .判断开始 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
                        .判断开始 (等于 (opcode, “imul”))
                            赋值 (p1, 107)
                            赋值 (pb1, 到字节集 (到字节 (imm)))
                        .默认
                            
                        .判断结束
                        
                    .判断 (等于 (opcode, “imul”))
                        赋值 (p1, 105)
                        赋值 (pb1, 到字节集 (imm))
                    .默认
                        
                    .判断结束
                    赋值 (code, regword_memword2 (p1, regs [1], rimm, 等于 (w, 2)))
                    EASM_AddCode (pb1)
                    赋值 (code, 相加 (code, pb1))
                .默认
                    赋值 (code, regword_memword (p1, regs [1], rimm, 等于 (w, 2)))
                .判断结束
                
            .默认
                .如果真 (或者 (等于 (opcode, “movsx”), 等于 (opcode, “movzx”)))
                    .如果真 (等于 (w, 2))
                        赋值 (p1, 相加 (p1, 1))
                    .如果真结束
                    
                .如果真结束
                赋值 (code, reg_mem (p1, w, regs [1], rimm))
            .判断结束
            
        .如果真结束
        
    .判断 (并且 (Mem, 等于 (rreg, 假)))
        .判断开始 (并且 (大于或等于 (rimm, -128), 小于或等于 (rimm, 127)))
            赋值 (p1, reg_imm8_OpCode (opcode))
        .默认
            赋值 (p1, reg_imm_OpCode (opcode))
        .判断结束
        .如果真 (等于 (p1, -1))
            返回 ({  })
        .如果真结束
        .判断开始 (等于 (p1, -2))
             ' '''''这里写不支持 reg_imm8的.
            赋值 (p1, mem_imm_OpCode (opcode))
            .判断开始 (等于 (n1, 1))
                赋值 (code, mem_imm (p1, w, , rimm, regs [1], , , , GetOpr (opcode), , , ocode))
            .判断 (等于 (n1, 2))
                赋值 (code, mem_imm (p1, w, , rimm, regs [1], regs [2], limm, sib, GetOpr (opcode), , , ocode))
            .默认
                
            .判断结束
            
        .判断 (等于 (p1, -6))
            赋值 (p1, regword_imm8_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            赋值 (code, regword_imm8 (p1, #m_reg_oo, GetOpr (opcode), regs [1], rimm, 等于 (t, 2)))
        .判断 (等于 (n1, 1))
            赋值 (code, mem_imm (p1, w, , rimm, regs [1], , limm, , GetOpr (opcode), , 并且 (大于或等于 (rimm, -128), 小于或等于 (rimm, 127)), ocode))
        .判断 (等于 (n1, 2))
            赋值 (code, mem_imm (p1, w, , rimm, regs [1], regs [2], limm, sib, GetOpr (opcode), , 并且 (大于或等于 (rimm, -128), 小于或等于 (rimm, 127)), ocode))
        .默认
            
        .判断结束
        
    .判断 (并且 (等于 (Mem, 假), 等于 (rMem, 假), 等于 (rreg, 假)))
        .判断开始 (等于 (opcode, “in”))
            .如果真 (等于 (regs [1], 0))
                .判断开始 (寄存器8位判断 (s21 [1]))
                    EASM_AddCode (相加 ({ 228 }, 到字节集 (到字节 (rimm))))
                .判断 (寄存器16位判断 (s21 [1]))
                    EASM_AddCode (相加 ({ 102, 229 }, 到字节集 (到字节 (rimm))))
                .默认
                    EASM_AddCode (相加 ({ 229 }, 到字节集 (到字节 (rimm))))
                .判断结束
                返回 ({ 1 })
            .如果真结束
            
        .判断 (等于 (opcode, “out”))
            .如果真 (等于 (regs [1], 0))
                .判断开始 (寄存器8位判断 (s21 [1]))
                    EASM_AddCode (相加 ({ 230 }, 到字节集 (到字节 (rimm))))
                .判断 (寄存器16位判断 (s21 [1]))
                    EASM_AddCode (相加 ({ 102, 231 }, 到字节集 (到字节 (rimm))))
                .默认
                    EASM_AddCode (相加 ({ 231 }, 到字节集 (到字节 (rimm))))
                .判断结束
                返回 ({ 1 })
            .如果真结束
            
        .默认
            
        .判断结束
        
        .判断开始 (或者 (并且 (大于或等于 (rimm, -128), 小于或等于 (rimm, 127)), 等于 (opcode, “mov”)))
            赋值 (p1, reg_imm8_OpCode (opcode))
            .如果真 (等于 (regs [1], 0))
                赋值 (p1, acc_imm_Opcode (opcode))
                .判断开始 (等于 (p1, -1))
                    赋值 (p1, reg_imm8_OpCode (opcode))
                .默认
                    赋值 (code, acc_imm (p1, w, rimm))
                    返回 (code)
                .判断结束
                
            .如果真结束
            
        .判断 (等于 (regs [1], 0))
            赋值 (p1, acc_imm_Opcode (opcode))
            .判断开始 (等于 (p1, -1))
                赋值 (p1, reg_imm_OpCode (opcode))
            .默认
                赋值 (code, acc_imm (p1, w, rimm))
                返回 (code)
            .判断结束
            
        .默认
            赋值 (p1, reg_imm_OpCode (opcode))
        .判断结束
        .如果真 (等于 (p1, -1))
            返回 ({  })
        .如果真结束
        .判断开始 (等于 (p1, -2))
            赋值 (p1, reg_imm_OpCode (opcode))
            赋值 (code, reg_imm (p1, w, regs [1], rimm))
        .判断 (等于 (p1, -6))
            赋值 (p1, regword_imm8_opcode (opcode))
            .如果真 (等于 (p1, -1))
                返回 ({  })
            .如果真结束
            赋值 (code, regword_imm8 (p1, #reg_oo, GetOpr (opcode), regs [1], rimm, 等于 (t, 2)))
        .默认
            赋值 (code, mem_imm (p1, w, , rimm, regs [1], , , , GetOpr (opcode), #reg_oo, 并且 (大于或等于 (rimm, -128), 小于或等于 (rimm, 127)), ocode))
        .判断结束
        
    .默认
        
    .判断结束
    
.判断 (并且 (等于 (lreg, 假), rreg))
    赋值 (n1, 取数组成员数 (regs))
    .如果真 (小于 (n1, 1))
        输出调试文本 (“模块出现错误..”)
        返回 ({  })
    .如果真结束
    赋值 (p1, mem_reg_OpCode (opcode))
    .如果真 (等于 (p1, -1))
        返回 ({  })
    .如果真结束
    .判断开始 (等于 (p1, -4))
        赋值 (p1, memword_regword_Opcode (opcode))
        .如果真 (等于 (p1, -1))
            返回 ({  })
        .如果真结束
        .判断开始 (并且 (Mem, 等于 (lreg, 假)))
            赋值 (code, memword_regword (p1, #m_reg_oo, regs [1], limm, 等于 (t, 2)))
        .默认
            
        .判断结束
        
    .判断 (并且 (Mem, 等于 (lreg, 假)))
        赋值 (code, mem_reg (p1, w, regs [1], limm))
    .默认
        
    .判断结束
    
.判断 (并且 (等于 (lreg, 假), 等于 (rreg, 假)))
    
    赋值 (p1, mem_imm_OpCode (opcode))
    .如果真 (等于 (p1, -1))
        返回 ({  })
    .如果真结束
    .判断开始 (等于 (p1, -5))
        赋值 (p1, memword_imm8_opcode (opcode))
        .如果真 (等于 (p1, -1))
            返回 ({  })
        .如果真结束
        .判断开始 (Mem)
            赋值 (code, memword_imm8 (p1, GetOpr (opcode), #m_reg_oo, limm, rimm, 等于 (t, 1), ocode))
        .默认
            
        .判断结束
        
    .判断 (noimm8 (opcode)) ' 立即数不支持imm8的指令
        赋值 (code, mem_imm (p1, w, limm, rimm, , , , , GetOpr (opcode), , , ocode))
    .默认
        赋值 (code, mem_imm (p1, w, limm, rimm, , , , , GetOpr (opcode), , 并且 (大于或等于 (rimm, -128), 小于或等于 (rimm, 127)), ocode))
    .判断结束
    
.默认
    
.判断结束
返回 (code)


.子程序 noimm8, 逻辑型, , 
.参数 opcode, 文本型, , 

返回 (或者 (等于 (opcode, “mov”), 等于 (opcode, “sbb”), 等于 (opcode, “sub”)))

.子程序 寄存器32位判断, 逻辑型, , 
.参数 s, 文本型, , 

返回 (取反 (或者 (等于 (s, “al”), 等于 (s, “bl”), 等于 (s, “cl”), 等于 (s, “dl”), 等于 (s, “ah”), 等于 (s, “ch”), 等于 (s, “dh”), 等于 (s, “bh”), 等于 (s, “ax”), 等于 (s, “cx”), 等于 (s, “bx”), 等于 (s, “dx”), 等于 (s, “sp”), 等于 (s, “bp”), 等于 (s, “si”), 等于 (s, “di”))))


.子程序 寄存器16位判断, 逻辑型, , 
.参数 s, 文本型, , 

返回 (取反 (或者 (等于 (s, “al”), 等于 (s, “bl”), 等于 (s, “cl”), 等于 (s, “dl”), 等于 (s, “ah”), 等于 (s, “ch”), 等于 (s, “dh”), 等于 (s, “bh”), 等于 (s, “eax”), 等于 (s, “ecx”), 等于 (s, “ebx”), 等于 (s, “edx”), 等于 (s, “esp”), 等于 (s, “ebp”), 等于 (s, “esi”), 等于 (s, “edi”))))

.子程序 寄存器8位判断, 逻辑型, , 
.参数 s, 文本型, , 

返回 (取反 (或者 (等于 (s, “eax”), 等于 (s, “ecx”), 等于 (s, “edx”), 等于 (s, “ebx”), 等于 (s, “ebp”), 等于 (s, “esp”), 等于 (s, “esi”), 等于 (s, “edi”), 等于 (s, “ax”), 等于 (s, “cx”), 等于 (s, “bx”), 等于 (s, “dx”), 等于 (s, “sp”), 等于 (s, “bp”), 等于 (s, “si”), 等于 (s, “di”))))


.子程序 判断寄存器, 字节型, , 
.参数 s, 文本型, , 
.参数 w, 字节型, 参考, 

.判断开始 (等于 (s, “eax”))
    赋值 (w, #w_dword)
    返回 (#eax)
.判断 (等于 (s, “ecx”))
    赋值 (w, #w_dword)
    返回 (#ecx)
.判断 (等于 (s, “edx”))
    赋值 (w, #w_dword)
    返回 (#edx)
.判断 (等于 (s, “ebx”))
    赋值 (w, #w_dword)
    返回 (#ebx)
.判断 (等于 (s, “ebp”))
    赋值 (w, #w_dword)
    返回 (#ebp)
.判断 (等于 (s, “esp”))
    赋值 (w, #w_dword)
    返回 (#esp)
.判断 (等于 (s, “esi”))
    赋值 (w, #w_dword)
    返回 (#esi)
.判断 (等于 (s, “edi”))
    赋值 (w, #w_dword)
    返回 (#edi)
.判断 (等于 (s, “al”))
    赋值 (w, #w_byte)
    返回 (#al)
.判断 (等于 (s, “cl”))
    赋值 (w, #w_byte)
    返回 (#cl)
.判断 (等于 (s, “bl”))
    赋值 (w, #w_byte)
    返回 (#bl)
.判断 (等于 (s, “dl”))
    赋值 (w, #w_byte)
    返回 (#dl)
.判断 (等于 (s, “ah”))
    赋值 (w, #w_byte)
    返回 (#ah)
.判断 (等于 (s, “ch”))
    赋值 (w, #w_byte)
    返回 (#ch)
.判断 (等于 (s, “dh”))
    赋值 (w, #w_byte)
    返回 (#dh)
.判断 (等于 (s, “bh”))
    赋值 (w, #w_byte)
    返回 (#bh)
.判断 (等于 (s, “ax”))
    赋值 (w, #w_word)
    返回 (#ax)
.判断 (等于 (s, “cx”))
    赋值 (w, #w_word)
    返回 (#cx)
.判断 (等于 (s, “dx”))
    赋值 (w, #w_word)
    返回 (#dx)
.判断 (等于 (s, “bx”))
    赋值 (w, #w_word)
    返回 (#bx)
.判断 (等于 (s, “sp”))
    赋值 (w, #w_word)
    返回 (#sp)
.判断 (等于 (s, “bp”))
    赋值 (w, #w_word)
    返回 (#bp)
.判断 (等于 (s, “si”))
    赋值 (w, #w_word)
    返回 (#si)
.判断 (等于 (s, “di”))
    赋值 (w, #w_word)
    返回 (#di)
.默认
    返回 (55)
.判断结束


.子程序 获取操作数, 空白型, , 
.参数 s, 文本型, , 
.参数 ret, 文本型, 数组, 
.参数 fh, 整数型, 数组, 数学符号

.局部变量 n, 整数型, , , 
.局部变量 i, 整数型, , , 
.局部变量 s1, 文本型, , , 
.局部变量 s9, 文本型, , , 

重定义数组 (ret, 假, 0)
重定义数组 (fh, 假, 0)
赋值 (n, 取文本长度 (s))
.计次循环首 (n, i)
    赋值 (s1, 取文本中间 (s, i, 1))
    .判断开始 (等于 (s1, “+”))
        加入成员 (ret, s9)
        加入成员 (fh, 1)
        赋值 (s9, “”)
    .判断 (等于 (s1, “-”))
        加入成员 (ret, s9)
        加入成员 (fh, 2)
        赋值 (s9, “”)
    .判断 (等于 (s1, “*”))
        加入成员 (ret, s9)
        加入成员 (fh, 3)
        赋值 (s9, “”)
    .默认
        赋值 (s9, 相加 (s9, s1))
    .判断结束
    
.计次循环尾 ()
加入成员 (ret, s9)

.子程序 获取段标识数据, 字节集, , 
.参数 d, 文本型, , 

.判断开始 (等于 (d, “cs”))
    返回 (到字节集 (到字节 (#cs)))
.判断 (等于 (d, “ds”))
    返回 (到字节集 (到字节 (#ds)))
.判断 (等于 (d, “es”))
    返回 (到字节集 (到字节 (#es)))
.判断 (等于 (d, “fs”))
    返回 (到字节集 (到字节 (#fs)))
.判断 (等于 (d, “gs”))
    返回 (到字节集 (到字节 (#gs)))
.判断 (等于 (d, “ss”))
    返回 (到字节集 (到字节 (#ss)))
.默认
    返回 ({  })
.判断结束


.子程序 reg_reg_OpCode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“reg_reg    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “mov”))
    返回 (138)
.判断 (等于 (opcode, “adc”))
    返回 (18)
.判断 (等于 (opcode, “and”))
    返回 (34)
.判断 (等于 (opcode, “add”))
    返回 (2)
.判断 (等于 (opcode, “arpl”))
    返回 (-2)
.判断 (等于 (opcode, “bound”))
    返回 (-2)
.判断 (等于 (opcode, “bsf”))
    返回 (-3)
.判断 (等于 (opcode, “bsr”))
    返回 (-3)
.判断 (等于 (opcode, “bt”))
    返回 (-3)
.判断 (等于 (opcode, “btc”))
    返回 (-3)
.判断 (等于 (opcode, “btr”))
    返回 (-3)
.判断 (等于 (opcode, “bts”))
    返回 (-3)
.判断 (等于 (opcode, “cmp”))
    返回 (58)
.判断 (等于 (opcode, “cmpxchg”))
    赋值 (ocode, 15)
    返回 (176)
.判断 (等于 (opcode, “lar”))
    返回 (-3)
.判断 (等于 (opcode, “lds”))
    返回 (-8)
.判断 (等于 (opcode, “les”))
    返回 (-8)
.判断 (等于 (opcode, “lfs”))
    返回 (-8)
.判断 (等于 (opcode, “lgs”))
    返回 (-8)
.判断 (等于 (opcode, “lss”))
    返回 (-8)
.判断 (等于 (opcode, “lea”))
    返回 (140)
.判断 (等于 (opcode, “movsx”))
    赋值 (ocode, 15)
    返回 (189)
.判断 (等于 (opcode, “movzx”))
    赋值 (ocode, 15)
    返回 (181)
.判断 (等于 (opcode, “or”))
    返回 (10)
.判断 (等于 (opcode, “rcl”))
    返回 (210)
.判断 (等于 (opcode, “rol”))
    返回 (210)
.判断 (等于 (opcode, “ror”))
    返回 (210)
.判断 (等于 (opcode, “rcr”))
    返回 (210)
.判断 (等于 (opcode, “sal”))
    返回 (210)
.判断 (等于 (opcode, “sar”))
    返回 (210)
.判断 (等于 (opcode, “shl”))
    返回 (210)
.判断 (等于 (opcode, “shr”))
    返回 (210)
.判断 (等于 (opcode, “sbb”))
    返回 (26)
.判断 (等于 (opcode, “sub”))
    返回 (42)
.判断 (等于 (opcode, “test”))
    返回 (132)
.判断 (等于 (opcode, “xadd”))
    赋值 (ocode, 15)
    返回 (192)
.判断 (等于 (opcode, “xchg”))
    返回 (134)
.判断 (等于 (opcode, “xor”))
    返回 (50)
.判断 (等于 (opcode, “imul”))
    返回 (106)
.默认
    
.判断结束
返回 (-1)

.子程序 reg16_reg16_opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“reg16_reg16    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “arpl”))
    返回 (99)
.判断 (等于 (opcode, “bound”))
    返回 (98)
.默认
    
.判断结束
返回 (-1)


.子程序 regword_regword_immx, 整数型, , 
.参数 opcode, 文本型, , 
.参数 imm, 整数型, , 

赋值 (ocode, 0)
.判断开始 (等于 (opcode, “imul”))
    .判断开始 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
        返回 (107)
    .默认
        返回 (105)
    .判断结束
    
.默认
    
.判断结束
返回 (-1)

.子程序 regword_regword_opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“regword_regword    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “bsf”))
    返回 (188)
.判断 (等于 (opcode, “bsr”))
    返回 (189)
.判断 (等于 (opcode, “bt”))
    返回 (163)
.判断 (等于 (opcode, “btc”))
    返回 (163)
.判断 (等于 (opcode, “btr”))
    返回 (163)
.判断 (等于 (opcode, “bts”))
    返回 (163)
.判断 (等于 (opcode, “imul”))
    返回 (175)
.判断 (等于 (opcode, “lar”))
    返回 (2)
.默认
    
.判断结束
返回 (-1)

.子程序 regword_opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“regword    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “bswap”))
    赋值 (ocode, 15)
    返回 (12)
.判断 (等于 (opcode, “dec”))
    返回 (4)
.判断 (等于 (opcode, “div”))
    返回 (246)
.判断 (等于 (opcode, “idiv”))
    返回 (246)
.判断 (等于 (opcode, “inc”))
    返回 (4)
.判断 (等于 (opcode, “pop”))
    返回 (5)
.判断 (等于 (opcode, “push”))
    返回 (5)
.默认
    
.判断结束
返回 (-1)

.子程序 regword_imm8_opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“regword_imm8    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “bt”))
    返回 (186)
.判断 (等于 (opcode, “btc”))
    返回 (186)
.判断 (等于 (opcode, “btr”))
    返回 (186)
.判断 (等于 (opcode, “bts”))
    返回 (186)
.默认
    
.判断结束
返回 (-1)


.子程序 regword_memword_opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“regword_imm8    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “imul”))
    返回 (175)
.默认
    
.判断结束
返回 (-1)


.子程序 reg1632_mem1632_opcode, 整数型, , 
.参数 opcode, 文本型, , 

赋值 (ocode, 0)
.判断开始 (等于 (opcode, “lds”))
    返回 (197)
.判断 (等于 (opcode, “les”))
    返回 (196)
.判断 (等于 (opcode, “lfs”))
    赋值 (ocode, 15)
    返回 (180)
.判断 (等于 (opcode, “lgs”))
    赋值 (ocode, 15)
    返回 (181)
.判断 (等于 (opcode, “lfs”))
    赋值 (ocode, 15)
    返回 (180)
.判断 (等于 (opcode, “lss”))
    赋值 (ocode, 15)
    返回 (178)
.默认
    
.判断结束
返回 (-1)

.子程序 memword_imm8_opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“memword_imm8    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “bt”))
    返回 (186)
.判断 (等于 (opcode, “btc”))
    返回 (186)
.判断 (等于 (opcode, “btr”))
    返回 (186)
.判断 (等于 (opcode, “bts”))
    返回 (186)
.默认
    
.判断结束
返回 (-1)


.子程序 mem_reg_OpCode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“mem_reg    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “mov”))
    返回 (138)
.判断 (等于 (opcode, “adc”))
    返回 (16)
.判断 (等于 (opcode, “and”))
    返回 (32)
.判断 (等于 (opcode, “add”))
    返回 (0)
.判断 (等于 (opcode, “add”))
    返回 (0)
.判断 (等于 (opcode, “bt”))
    返回 (-4)
.判断 (等于 (opcode, “btc”))
    返回 (-4)
.判断 (等于 (opcode, “btr”))
    返回 (-4)
.判断 (等于 (opcode, “bts”))
    返回 (-4)
.判断 (等于 (opcode, “cmp”))
    返回 (56)
.判断 (等于 (opcode, “cmpxchg”))
    赋值 (ocode, 15)
    返回 (176)
.判断 (等于 (opcode, “or”))
    返回 (8)
.判断 (等于 (opcode, “sbb”))
    返回 (24)
.判断 (等于 (opcode, “sub”))
    返回 (40)
.判断 (等于 (opcode, “test”))
    返回 (132)
.判断 (等于 (opcode, “xadd”))
    赋值 (ocode, 15)
    返回 (192)
.判断 (等于 (opcode, “xchg”))
    返回 (134)
.判断 (等于 (opcode, “xor”))
    返回 (48)
.默认
    
.判断结束
返回 (-1)


.子程序 memword_regword_Opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“memword_regword    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “bt”))
    返回 (163)
.判断 (等于 (opcode, “btc”))
    返回 (163)
.判断 (等于 (opcode, “btr”))
    返回 (163)
.判断 (等于 (opcode, “bts”))
    返回 (163)
.默认
    
.判断结束
返回 (-1)

.子程序 reg_mem_OpCode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“reg_mem    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “mov”))
    返回 (138)
.判断 (等于 (opcode, “adc”))
    返回 (18)
.判断 (等于 (opcode, “and”))
    返回 (34)
.判断 (等于 (opcode, “add”))
    返回 (2)
.判断 (等于 (opcode, “bound”))
    返回 (97)
.判断 (等于 (opcode, “bsf”))
    返回 (187)
.判断 (等于 (opcode, “bsr”))
    返回 (188)
.判断 (等于 (opcode, “cmp”))
    返回 (56)
.判断 (等于 (opcode, “imul”))
    返回 (-7)
.判断 (等于 (opcode, “lar”))
    赋值 (ocode, 15)
    返回 (1)
.判断 (等于 (opcode, “lds”))
    返回 (-8)
.判断 (等于 (opcode, “les”))
    返回 (-8)
.判断 (等于 (opcode, “lfs”))
    返回 (-8)
.判断 (等于 (opcode, “lgs”))
    返回 (-8)
.判断 (等于 (opcode, “lss”))
    返回 (-8)
.判断 (等于 (opcode, “movsx”))
    赋值 (ocode, 15)
    返回 (189)
.判断 (等于 (opcode, “movzx”))
    赋值 (ocode, 15)
    返回 (181)
.判断 (等于 (opcode, “or”))
    返回 (10)
.判断 (等于 (opcode, “sbb”))
    返回 (26)
.判断 (等于 (opcode, “sub”))
    返回 (42)
.判断 (等于 (opcode, “test”))
    返回 (132)
.判断 (等于 (opcode, “xchg”))
    返回 (134)
.判断 (等于 (opcode, “xor”))
    返回 (50)
.默认
    
.判断结束
返回 (-1)

.子程序 mem_imm_OpCode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“mem_imm    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “mov”))
    返回 (198)
.判断 (等于 (opcode, “adc”))
    返回 (128)
.判断 (等于 (opcode, “and”))
    返回 (128)
.判断 (等于 (opcode, “add”))
    返回 (128)
.判断 (等于 (opcode, “bt”))
    返回 (-5)
.判断 (等于 (opcode, “btc”))
    返回 (-5)
.判断 (等于 (opcode, “btr”))
    返回 (-5)
.判断 (等于 (opcode, “bts”))
    返回 (-5)
.判断 (等于 (opcode, “cmp”))
    返回 (128)
.判断 (等于 (opcode, “dec”))
    返回 (254)
.判断 (等于 (opcode, “div”))
    返回 (246)
.判断 (等于 (opcode, “idiv”))
    返回 (246)
.判断 (等于 (opcode, “idiv”))
    返回 (246)
.判断 (等于 (opcode, “imul”))
    返回 (246)
.判断 (等于 (opcode, “inc”))
    返回 (254)
.判断 (等于 (opcode, “mul”))
    返回 (246)
.判断 (等于 (opcode, “neg”))
    返回 (246)
.判断 (等于 (opcode, “not”))
    返回 (246)
.判断 (等于 (opcode, “or”))
    返回 (130)
.判断 (等于 (opcode, “pop”))
    返回 (142)
.判断 (等于 (opcode, “sbb”))
    返回 (128)
.判断 (等于 (opcode, “sub”))
    返回 (128)
.判断 (等于 (opcode, “test”))
    返回 (246)
.判断 (等于 (opcode, “xor”))
    返回 (128)
.默认
    
.判断结束
返回 (-1)

.子程序 reg_imm_OpCode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“reg_imm    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “mov”))
    返回 (11)
.判断 (等于 (opcode, “adc”))
    返回 (128)
.判断 (等于 (opcode, “and”))
    返回 (128)
.判断 (等于 (opcode, “add”))
    返回 (128)
.判断 (等于 (opcode, “bt”))
    返回 (-6)
.判断 (等于 (opcode, “btc”))
    返回 (-6)
.判断 (等于 (opcode, “btr”))
    返回 (-6)
.判断 (等于 (opcode, “bts”))
    返回 (-6)
.判断 (等于 (opcode, “cmp”))
    返回 (128)
.判断 (等于 (opcode, “dec”))
    返回 (254)
.判断 (等于 (opcode, “inc”))
    返回 (254)
.判断 (等于 (opcode, “invlpg”))
    返回 (-6)
.判断 (等于 (opcode, “or”))
    返回 (128)
.判断 (等于 (opcode, “sbb”))
    返回 (128)
.判断 (等于 (opcode, “sub”))
    返回 (128)
.判断 (等于 (opcode, “test”))
    返回 (246)
.判断 (等于 (opcode, “xor”))
    返回 (128)
.默认
    
.判断结束
返回 (-1)


.子程序 reg_imm8_OpCode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“reg_imm8    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “mov”))
    返回 (-2)
.判断 (等于 (opcode, “adc”))
    返回 (130)
.判断 (等于 (opcode, “and”))
    返回 (130)
.判断 (等于 (opcode, “add”))
    返回 (130)
.判断 (等于 (opcode, “bt”))
    返回 (-6)
.判断 (等于 (opcode, “btc”))
    返回 (-6)
.判断 (等于 (opcode, “btr”))
    返回 (-6)
.判断 (等于 (opcode, “bts”))
    返回 (-6)
.判断 (等于 (opcode, “cmp”))
    返回 (130)
.判断 (等于 (opcode, “cmp”))
    返回 (130)
.判断 (等于 (opcode, “dec”))
    返回 (-2)
.判断 (等于 (opcode, “div”))
    返回 (246)
.判断 (等于 (opcode, “idiv”))
    返回 (246)
.判断 (等于 (opcode, “imul”))
    返回 (246)
.判断 (等于 (opcode, “inc”))
    返回 (-2)
.判断 (等于 (opcode, “mul”))
    返回 (246)
.判断 (等于 (opcode, “neg”))
    返回 (246)
.判断 (等于 (opcode, “not”))
    返回 (246)
.判断 (等于 (opcode, “or”))
    返回 (130)
.判断 (等于 (opcode, “pop”))
    返回 (142)
.判断 (等于 (opcode, “push”))
    返回 (254)
.判断 (等于 (opcode, “rcl”))
    返回 (192)
.判断 (等于 (opcode, “rol”))
    返回 (192)
.判断 (等于 (opcode, “ror”))
    返回 (192)
.判断 (等于 (opcode, “rcr”))
    返回 (192)
.判断 (等于 (opcode, “sal”))
    返回 (192)
.判断 (等于 (opcode, “sar”))
    返回 (192)
.判断 (等于 (opcode, “shl”))
    返回 (192)
.判断 (等于 (opcode, “shr”))
    返回 (192)
.判断 (等于 (opcode, “sbb”))
    返回 (130)
.判断 (等于 (opcode, “sub”))
    返回 (130)
.判断 (等于 (opcode, “xor”))
    返回 (130)
.默认
    
.判断结束
返回 (-1)


.子程序 acc_imm_Opcode, 整数型, , 
.参数 opcode, 文本型, , 

 ' 输出调试文本 (“acc_imm    ” ＋ opcode)
赋值 (ocode, 0)
.判断开始 (等于 (opcode, “and”))
    返回 (36)
.判断 (等于 (opcode, “adc”))
    返回 (20)
.判断 (等于 (opcode, “add”))
    返回 (4)
.判断 (等于 (opcode, “cmp”))
    返回 (60)
.默认
    
.判断结束
返回 (-1)

.子程序 GetOpr, 字节型, , 
.参数 opcode, 文本型, , 
.参数 yesorno, 逻辑型, 参考 可空, 

.判断开始 (等于 (opcode, “mov”))
    返回 (0)
.判断 (等于 (opcode, “adc”))
    返回 (2)
.判断 (等于 (opcode, “and”))
    返回 (4)
.判断 (等于 (opcode, “add”))
    返回 (0)
.判断 (等于 (opcode, “bt”))
    返回 (4)
.判断 (等于 (opcode, “btc”))
    返回 (7)
.判断 (等于 (opcode, “btr”))
    返回 (6)
.判断 (等于 (opcode, “bts”))
    返回 (5)
.判断 (等于 (opcode, “cmp”))
    返回 (7)
.判断 (等于 (opcode, “dec”))
    返回 (1)
.判断 (等于 (opcode, “div”))
    返回 (6)
.判断 (等于 (opcode, “idiv”))
    返回 (7)
.判断 (等于 (opcode, “imul”))
    返回 (5)
.判断 (等于 (opcode, “mul”))
    返回 (4)
.判断 (等于 (opcode, “neg”))
    返回 (3)
.判断 (等于 (opcode, “not”))
    返回 (2)
.判断 (等于 (opcode, “or”))
    返回 (1)
.判断 (等于 (opcode, “push”))
    返回 (6)
.判断 (等于 (opcode, “rcl”))
    赋值 (yesorno, 真)
    返回 (2)
.判断 (等于 (opcode, “rol”))
    赋值 (yesorno, 真)
    返回 (0)
.判断 (等于 (opcode, “ror”))
    赋值 (yesorno, 真)
    返回 (1)
.判断 (等于 (opcode, “rcr”))
    赋值 (yesorno, 真)
    返回 (3)
.判断 (等于 (opcode, “sal”))
    赋值 (yesorno, 真)
    返回 (4)
.判断 (等于 (opcode, “sar”))
    赋值 (yesorno, 真)
    返回 (7)
.判断 (等于 (opcode, “shr”))
    赋值 (yesorno, 真)
    返回 (5)
.判断 (等于 (opcode, “shl”))
    赋值 (yesorno, 真)
    返回 (4)
.判断 (等于 (opcode, “sbb”))
    返回 (3)
.判断 (等于 (opcode, “sub”))
    返回 (5)
.判断 (等于 (opcode, “xor”))
    返回 (6)
.默认
    
.判断结束
返回 (0)


.子程序 是否为指令头, 逻辑型, , 
.参数 opcode, 文本型, , 

.判断开始 (等于 (opcode, “lock”))
    EASM_AddCode ({ 240 })
    返回 (真)
.判断 (等于 (opcode, “rep”))
    EASM_AddCode ({ 243 })
    返回 (真)
.判断 (等于 (opcode, “repe”))
    EASM_AddCode ({ 243 })
    返回 (真)
.判断 (等于 (opcode, “repz”))
    EASM_AddCode ({ 243 })
    返回 (真)
.判断 (等于 (opcode, “repne”))
    EASM_AddCode ({ 242 })
    返回 (真)
.判断 (等于 (opcode, “repnz”))
    EASM_AddCode ({ 242 })
    返回 (真)
.默认
    返回 (假)
.判断结束


.子程序 GetOpr2, 整数型, , 
.参数 opcode, 文本型, , 

.判断开始 (等于 (opcode, “dec”))
    返回 (-1)
.判断 (等于 (opcode, “inc”))
    返回 (0)
.判断 (等于 (opcode, “push”))
    返回 (0)
.默认
    
.判断结束
返回 (-1)

.程序集 扩展模块, , , 

.子程序 _shl, 整数型, , 
.参数 被移动数, 整数型, , 
.参数 移动位数, 整数型, , 

返回 (左移 (被移动数, 移动位数))


.子程序 HexToInt, 整数型, , 将十六进制转换成十进制(返回十进制文本)
.参数 十六进制文本, 文本型, , 待转换的十六进制文本

.局部变量 中间文本, 文本型, , , 
.局部变量 结果, 整数型, , , 
.局部变量 容器1, 整数型, , , 

.变量循环首 (1, 取文本长度 (十六进制文本), 1, 容器1)
    赋值 (中间文本, 取文本中间 (十六进制文本, 容器1, 1))
    赋值 (结果, 相加 (相乘 (相减 (寻找文本 (“0123456789ABCDEF”, 中间文本, , 真), 1), 求次方 (16, 相减 (取文本长度 (十六进制文本), 容器1))), 结果))
.变量循环尾 ()
返回 (结果)


.子程序 字节到十六进制, 文本型, , 这个取十六进制文本没有去0
.参数 数值, 字节型, , 只能是255以内的数

 ' 取出十六进制文本，用易语言的函数会丢掉0，所以重新做了一个
 ' 论坛上monktiger少0的原因可能类似，只有亲自做过才知道啊
返回 (相加 (多项选择 (相加 (右移 (数值, 4), 1), “0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”, “8”, “9”, “A”, “B”, “C”, “D”, “E”, “F”), 多项选择 (相加 (位与 (数值, 15), 1), “0”, “1”, “2”, “3”, “4”, “5”, “6”, “7”, “8”, “9”, “A”, “B”, “C”, “D”, “E”, “F”)))

.子程序 字节集到十六进制, 文本型, , 
.参数 字节集, 字节集, , 

.局部变量 Hex, 文本型, , , 
.局部变量 i, 整数型, , , 

.计次循环首 (取字节集长度 (字节集), i)
    赋值 (Hex, 相加 (Hex, 字节到十六进制 (字节集 [i])))
.计次循环尾 ()
返回 (Hex)



.程序集 ESuperASM, , , '超级过程,N个过程通用所有命令,强大无比!!!,有的只针对部分命令!!

.子程序 reg_reg, 字节集, , opcode_reg_reg
.参数 opcode, 字节型, , 'opcode!!!!
.参数 w, 字节型, , 0=8bits,1=32bits,2=16bits
.参数 oo, 字节型, , 
.参数 rrr, 字节型, , 
.参数 mmm, 字节型, , 
.参数 Imm, 整数型, 可空, 可空
.参数 reg1, 字节型, 可空, 可空
.参数 reg2, 字节型, 可空, 可空
.参数 mem, 逻辑型, 可空, 可空
.参数 sib, 字节型, 可空, 乘法,1=*2,2=*4,3=*8
.参数 opcode2, 字节型, , 

.局部变量 pb1, 字节集, , , 
.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 
.局部变量 p2, 字节型, , , 

.判断开始 (并且 (不等于 (oo, #m_reg_oo), 不等于 (oo, #reg_oo)))
    .判断开始 (是否为空 (Imm))
        .如果真 (或者 (等于 (oo, #reg_disp8_oo), 等于 (oo, #reg_disp32_oo)))
            赋值 (oo, #m_reg_oo)
        .如果真结束
        
    .判断 (等于 (oo, #reg_disp8_oo))
        赋值 (pb1, 到字节集 (到字节 (Imm)))
    .默认
        赋值 (pb1, 到字节集 (Imm))
    .判断结束
    
.判断 (并且 (等于 (mmm, #ebp), 不等于 (oo, #reg_oo)))
    赋值 (pb1, 到字节集 (Imm))
.默认
    
.判断结束
.如果真 (等于 (w, 2))
    赋值 (Code, { 102 })
    赋值 (w, 1)
.如果真结束
.如果真 (不等于 (opcode2, 0))
    赋值 (Code, 相加 (Code, 到字节集 (opcode2)))
.如果真结束
赋值 (p1, 相加 (opcode, w))
.如果真 (mem)
    赋值 (p1, 相减 (p1, 2))
.如果真结束
赋值 (Code, 相加 (Code, 到字节集 (p1)))
赋值 (p1, 相加 (_shl (oo, 6), _shl (rrr, 3), mmm))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
.如果真 (并且 (等于 (mmm, #esp), 不等于 (oo, #reg_oo)))
    .如果真 (是否为空 (reg2))
        赋值 (reg2, 4)
    .如果真结束
    .如果真 (是否为空 (reg1))
        赋值 (reg1, 4)
    .如果真结束
    .判断开始 (是否为空 (sib))
        赋值 (p2, 相加 (_shl (reg1, 3), reg2))
    .默认
        赋值 (p2, 相加 (_shl (reg1, 3), reg2, _shl (sib, 6)))
    .判断结束
    
    赋值 (Code, 相加 (Code, 到字节集 (p2)))
.如果真结束
赋值 (Code, 相加 (Code, pb1))
EASM_AddCode (Code)
返回 (Code)

.子程序 reg16_reg16, 字节集, , 
.参数 opcode, 字节型, , 'opcode!!!!
.参数 oo, 字节型, , 
.参数 rrr, 字节型, , 
.参数 mmm, 字节型, , 
.参数 Imm, 整数型, 可空, 可空
.参数 reg1, 字节型, 可空, 可空
.参数 reg2, 字节型, 可空, 可空
.参数 sib, 字节型, 可空, 乘法,1=*2,2=*4,3=*8
.参数 mem64, 逻辑型, 可空, 
.参数 opcode2, 字节型, , 

.局部变量 pb1, 字节集, , , 
.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 
.局部变量 p2, 字节型, , , 

.判断开始 (并且 (不等于 (oo, #m_reg_oo), 不等于 (oo, #reg_oo)))
    .判断开始 (是否为空 (Imm))
        .如果真 (或者 (等于 (oo, #reg_disp8_oo), 等于 (oo, #reg_disp32_oo)))
            赋值 (oo, #m_reg_oo)
        .如果真结束
        
    .判断 (等于 (oo, #reg_disp8_oo))
        赋值 (pb1, 到字节集 (到字节 (Imm)))
    .默认
        赋值 (pb1, 到字节集 (Imm))
    .判断结束
    
.判断 (并且 (等于 (mmm, #ebp), 不等于 (oo, #reg_oo)))
    赋值 (pb1, 到字节集 (Imm))
.默认
    
.判断结束
.如果真 (等于 (mem64, 假))
    赋值 (Code, { 102 })
.如果真结束
.如果真 (不等于 (opcode2, 0))
    赋值 (Code, 相加 (Code, 到字节集 (opcode2)))
.如果真结束

赋值 (p1, opcode)
赋值 (Code, 相加 (Code, 到字节集 (p1)))
赋值 (p1, 相加 (_shl (oo, 6), _shl (rrr, 3), mmm))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
.如果真 (并且 (等于 (mmm, #esp), 不等于 (oo, #reg_oo)))
    .如果真 (是否为空 (reg2))
        赋值 (reg2, 4)
    .如果真结束
    .如果真 (是否为空 (reg1))
        赋值 (reg1, 4)
    .如果真结束
    .判断开始 (是否为空 (sib))
        赋值 (p2, 相加 (_shl (reg1, 3), reg2))
    .默认
        赋值 (p2, 相加 (_shl (reg1, 3), reg2, _shl (sib, 6)))
    .判断结束
    
    赋值 (Code, 相加 (Code, 到字节集 (p2)))
.如果真结束
赋值 (Code, 相加 (Code, pb1))
EASM_AddCode (Code)
返回 (Code)


.子程序 regword_regword, 字节集, , 
.参数 opcode, 字节型, , 'opcode!!!!
.参数 oo, 字节型, , 
.参数 rrr, 字节型, , 
.参数 mmm, 字节型, , 
.参数 Imm, 整数型, 可空, 可空
.参数 reg1, 字节型, 可空, 可空
.参数 reg2, 字节型, 可空, 可空
.参数 sib, 字节型, 可空, 乘法,1=*2,2=*4,3=*8
.参数 mem64, 逻辑型, 可空, 
.参数 opcode2, 字节型, , 

.局部变量 pb1, 字节集, , , 
.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 
.局部变量 p2, 字节型, , , 

.判断开始 (并且 (不等于 (oo, #m_reg_oo), 不等于 (oo, #reg_oo)))
    .判断开始 (是否为空 (Imm))
        .如果真 (或者 (等于 (oo, #reg_disp8_oo), 等于 (oo, #reg_disp32_oo)))
            赋值 (oo, #m_reg_oo)
        .如果真结束
        
    .判断 (等于 (oo, #reg_disp8_oo))
        赋值 (pb1, 到字节集 (到字节 (Imm)))
    .默认
        赋值 (pb1, 到字节集 (Imm))
    .判断结束
    
.判断 (并且 (等于 (mmm, #ebp), 不等于 (oo, #reg_oo)))
    赋值 (pb1, 到字节集 (Imm))
.默认
    
.判断结束
.如果真 (等于 (mem64, 假))
    赋值 (Code, { 102 })
.如果真结束
.如果真 (不等于 (opcode2, 0))
    赋值 (Code, 相加 (Code, 到字节集 (opcode2)))
.如果真结束
赋值 (p1, opcode)
赋值 (Code, 相加 (Code, 到字节集 (到字节 (15)), 到字节集 (p1)))
赋值 (p1, 相加 (_shl (oo, 6), _shl (rrr, 3), mmm))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
.如果真 (并且 (等于 (mmm, #esp), 不等于 (oo, #reg_oo)))
    .如果真 (是否为空 (reg2))
        赋值 (reg2, 4)
    .如果真结束
    .如果真 (是否为空 (reg1))
        赋值 (reg1, 4)
    .如果真结束
    .判断开始 (是否为空 (sib))
        赋值 (p2, 相加 (_shl (reg1, 3), reg2))
    .默认
        赋值 (p2, 相加 (_shl (reg1, 3), reg2, _shl (sib, 6)))
    .判断结束
    
    赋值 (Code, 相加 (Code, 到字节集 (p2)))
.如果真结束
赋值 (Code, 相加 (Code, pb1))
EASM_AddCode (Code)
返回 (Code)


.子程序 regword_regword2, 字节集, , 
.参数 opcode, 字节型, , 'opcode!!!!
.参数 oo, 字节型, , 
.参数 rrr, 字节型, , 
.参数 mmm, 字节型, , 
.参数 Imm, 整数型, 可空, 可空
.参数 reg1, 字节型, 可空, 可空
.参数 reg2, 字节型, 可空, 可空
.参数 sib, 字节型, 可空, 乘法,1=*2,2=*4,3=*8
.参数 mem64, 逻辑型, 可空, 
.参数 opcode2, 字节型, , 

.局部变量 pb1, 字节集, , , 
.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 
.局部变量 p2, 字节型, , , 

.判断开始 (并且 (不等于 (oo, #m_reg_oo), 不等于 (oo, #reg_oo)))
    .判断开始 (是否为空 (Imm))
        .如果真 (或者 (等于 (oo, #reg_disp8_oo), 等于 (oo, #reg_disp32_oo)))
            赋值 (oo, #m_reg_oo)
        .如果真结束
        
    .判断 (等于 (oo, #reg_disp8_oo))
        赋值 (pb1, 到字节集 (到字节 (Imm)))
    .默认
        赋值 (pb1, 到字节集 (Imm))
    .判断结束
    
.判断 (并且 (等于 (mmm, #ebp), 不等于 (oo, #reg_oo)))
    赋值 (pb1, 到字节集 (Imm))
.默认
    
.判断结束
.如果真 (等于 (mem64, 假))
    赋值 (Code, { 102 })
.如果真结束
.如果真 (不等于 (opcode2, 0))
    赋值 (Code, 相加 (Code, 到字节集 (opcode2)))
.如果真结束

赋值 (p1, opcode)
赋值 (Code, 相加 (Code, 到字节集 (p1)))
赋值 (p1, 相加 (_shl (oo, 6), _shl (rrr, 3), mmm))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
.如果真 (并且 (等于 (mmm, #esp), 不等于 (oo, #reg_oo)))
    .如果真 (是否为空 (reg2))
        赋值 (reg2, 4)
    .如果真结束
    .如果真 (是否为空 (reg1))
        赋值 (reg1, 4)
    .如果真结束
    .判断开始 (是否为空 (sib))
        赋值 (p2, 相加 (_shl (reg1, 3), reg2))
    .默认
        赋值 (p2, 相加 (_shl (reg1, 3), reg2, _shl (sib, 6)))
    .判断结束
    
    赋值 (Code, 相加 (Code, 到字节集 (p2)))
.如果真结束
赋值 (Code, 相加 (Code, pb1))
EASM_AddCode (Code)
返回 (Code)


.子程序 regword, 字节集, , 
.参数 opcode, 字节型, , '前4位
.参数 rrr, 字节型, , 
.参数 w, 逻辑型, 可空, 
.参数 o, 整数型, 可空, 

.局部变量 code, 字节集, , , 

.如果真 (w)
    赋值 (code, { 102 })
.如果真结束
.判断开始 (等于 (o, -1))
    赋值 (code, 相加 (code, 到字节集 (到字节 (相加 (_shl (opcode, 4), 8, rrr)))))
.默认
    赋值 (code, 相加 (code, 到字节集 (到字节 (相加 (_shl (opcode, 4), o, rrr)))))
.判断结束

EASM_AddCode (code)
返回 (code)


.子程序 regword_imm8, 字节集, , 
.参数 opcode, 字节型, , 
.参数 oo, 字节型, , 
.参数 opr, 字节型, , 
.参数 mmm, 字节型, , 
.参数 imm8, 字节型, , 
.参数 w, 逻辑型, 可空, 

.局部变量 code, 字节集, , , 

.如果真 (w)
    赋值 (code, { 102 })
.如果真结束
赋值 (code, 相加 (code, 到字节集 (到字节 (15)), 到字节集 (opcode), 到字节集 (到字节 (相加 (_shl (oo, 6), _shl (opr, 3), mmm))), 到字节集 (imm8)))
EASM_AddCode (code)
返回 (code)


.子程序 memofs_acc, 字节集, , opcode_memofs_acc
.参数 opcode, 字节型, , 
.参数 w, 字节型, , 
.参数 addr, 整数型, , 

.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 

.如果真 (等于 (w, 2))
    赋值 (Code, { 102 })
    赋值 (w, 1)
.如果真结束
赋值 (p1, 相加 (opcode, w))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
赋值 (Code, 相加 (Code, 到字节集 (addr)))
EASM_AddCode (Code)
返回 (Code)

.子程序 acc_memofs, 字节集, , opcode_acc_memofs
.参数 opcode, 字节型, , 
.参数 w, 字节型, , 
.参数 addr, 整数型, , 

.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 

.如果真 (等于 (w, 2))
    赋值 (Code, { 102 })
    赋值 (w, 1)
.如果真结束
赋值 (p1, 相加 (opcode, w))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
赋值 (Code, 相加 (Code, 到字节集 (addr)))
EASM_AddCode (Code)
返回 (Code)

.子程序 reg_imm, 字节集, , opcode_reg_imm
.参数 opcode, 字节型, , 前4位
.参数 w, 字节型, , 
.参数 reg, 字节型, , 
.参数 imm, 整数型, , 

.局部变量 p1, 字节型, , , 
.局部变量 Code, 字节集, , , 
.局部变量 pb1, 字节集, , , 

.判断开始 (等于 (w, 0))
    赋值 (pb1, 到字节集 (到字节 (imm)))
.判断 (等于 (w, 2))
    赋值 (pb1, 到字节集 (到短整数 (imm)))
.默认
    赋值 (pb1, 到字节集 (imm))
.判断结束
.如果真 (等于 (w, 2))
    赋值 (Code, { 102 })
    赋值 (w, 1)
.如果真结束
赋值 (p1, _shl (opcode, 4))
赋值 (p1, 相加 (p1, _shl (w, 3), reg))
赋值 (Code, 相加 (Code, 到字节集 (p1)))
赋值 (Code, 相加 (Code, pb1))
EASM_AddCode (Code)
返回 (Code)

.子程序 mem_imm, 字节集, , 通用 reg_imm
.参数 opcode, 字节型, , 
.参数 w, 字节型, , 
.参数 addr, 整数型, 可空, 
.参数 x, 整数型, , 
.参数 reg1, 字节型, 可空, 
.参数 reg2, 字节型, 可空, 
.参数 imm, 整数型, 可空, 
.参数 sib, 字节型, 可空, 
.参数 opr, 字节型, 可空, 
.参数 oo, 字节型, 可空, 
.参数 mm8, 逻辑型, 可空, 
.参数 opcode2, 字节型, , 

.局部变量 p1, 字节型, , , 
.局部变量 code, 字节集, , , 
.局部变量 pb1, 字节集, , , 
.局部变量 t, 字节型, , , 
.局部变量 pb2, 字节集, , , 

.判断开始 (等于 (w, 0))
    赋值 (pb1, 到字节集 (到字节 (x)))
.判断 (等于 (w, 2))
    赋值 (pb1, 到字节集 (到短整数 (x)))
    赋值 (code, { 102 })
    赋值 (w, 1)
.判断 (并且 (大于或等于 (x, -128), 小于或等于 (x, 127), 等于 (mm8, 真)))
    赋值 (pb1, 到字节集 (到字节 (x)))
.默认
    赋值 (pb1, 到字节集 (x))
.判断结束

.如果真 (并且 (大于或等于 (x, -128), 小于或等于 (x, 127), 等于 (mm8, 真)))
    赋值 (pb1, 到字节集 (到字节 (x)))
.如果真结束
.如果真 (等于 (x, 0))
    赋值 (pb1, {  })
.如果真结束
赋值 (p1, 相加 (opcode, w))
.如果真 (不等于 (opcode2, 0))
    赋值 (code, 相加 (code, 到字节集 (opcode2)))
.如果真结束
.判断开始 (是否为空 (reg1))
    赋值 (t, 5)
    赋值 (t, 相加 (t, _shl (opr, 3)))
    赋值 (pb2, 到字节集 (addr))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (t), pb2, pb1))
.判断 (并且 (是否为空 (reg2), 是否为空 (imm)))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), _shl (oo, 6), reg1))), pb1))
.判断 (是否为空 (imm))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), 4))), 到字节集 (到字节 (相加 (reg1, 相乘 (reg2, 8), _shl (sib, 6)))), pb1))
.判断 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127), 是否为空 (reg2)))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), _shl (#reg_disp8_oo, 6), reg1))), 到字节集 (到字节 (imm)), pb1))
.判断 (是否为空 (reg2))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), _shl (#reg_disp32_oo, 6), reg1))), 到字节集 (imm), pb1))
.判断 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127), 是否为空 (oo)))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), 4, _shl (#reg_disp8_oo, 6)))), 到字节集 (到字节 (相加 (reg1, 相乘 (reg2, 8), _shl (sib, 6)))), 到字节集 (到字节 (imm)), pb1))
.判断 (是否为空 (oo))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), 4, _shl (#reg_disp32_oo, 6)))), 到字节集 (到字节 (相加 (reg1, 相乘 (reg2, 8), _shl (sib, 6)))), 到字节集 (imm), pb1))
.判断 (等于 (oo, #reg_disp8_oo))
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), 4, _shl (#reg_disp8_oo, 6)))), 到字节集 (到字节 (相加 (reg1, 相乘 (reg2, 8), _shl (sib, 6)))), 到字节集 (到字节 (imm)), pb1))
.默认
    赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (到字节 (相加 (_shl (opr, 3), 4, _shl (#reg_disp32_oo, 6)))), 到字节集 (到字节 (相加 (reg1, 相乘 (reg2, 8), _shl (sib, 6)))), 到字节集 (imm), pb1))
.判断结束
EASM_AddCode (code)
返回 (code)


.子程序 memword_imm8, 字节集, , 
.参数 opcode, 字节型, , 
.参数 opr, 字节型, , 
.参数 oo, 字节型, , 
.参数 addr, 整数型, , 
.参数 imm8, 字节型, , 
.参数 w, 逻辑型, 可空, 
.参数 opcode2, 字节型, , 

.局部变量 code, 字节集, , , 
.局部变量 pb1, 字节集, , , 
.局部变量 p1, 字节型, , , 

.如果真 (w)
    赋值 (code, { 102 })
.如果真结束
.如果真 (不等于 (opcode2, 0))
    赋值 (code, 相加 (code, 到字节集 (opcode2)))
.如果真结束

赋值 (pb1, 到字节集 (imm8))
赋值 (p1, opcode)
赋值 (code, 相加 (code, 到字节集 (到字节 (15)), 到字节集 (p1)))
赋值 (p1, 相加 (_shl (oo, 6), _shl (opr, 3), 5))
赋值 (code, 相加 (code, 到字节集 (p1), 到字节集 (addr), pb1))
EASM_AddCode (code)
返回 (code)

.子程序 memword_regword, 字节集, , 
.参数 opcode, 字节型, , 
.参数 oo, 字节型, , 
.参数 reg, 字节型, , 
.参数 addr, 整数型, , 
.参数 w, 逻辑型, 可空, 

返回 (regword_regword (opcode, #m_reg_oo, reg, #ebp, addr, , , , 取反 (w), ocode))


.子程序 regword_memword, 字节集, , 
.参数 opcode, 字节型, , 
.参数 reg, 字节型, , 
.参数 addr, 整数型, , 
.参数 w, 逻辑型, 可空, 

返回 (regword_regword (opcode, #m_reg_oo, reg, #ebp, addr, , , , 取反 (w), ocode))

.子程序 reg_mem, 字节集, , opcode_reg_mem
.参数 opcode, 字节型, , 
.参数 w, 字节型, , 
.参数 reg, 字节型, , 
.参数 addr, 整数型, , 

返回 (reg_reg (opcode, w, #m_reg_oo, reg, #ebp, addr, , , , , ocode))


.子程序 regword_memword2, 字节集, , 
.参数 opcode, 字节型, , 
.参数 reg, 字节型, , 
.参数 addr, 整数型, , 
.参数 w, 逻辑型, 可空, 

返回 (regword_regword2 (opcode, #m_reg_oo, reg, #ebp, addr, , , , 取反 (w), ocode))


.子程序 mem_reg, 字节集, , opcode_mem_reg
.参数 opcode, 字节型, , 
.参数 w, 字节型, , 
.参数 reg, 字节型, , 
.参数 addr, 整数型, , 

返回 (reg_reg (opcode, w, #m_reg_oo, reg, #ebp, addr, , , 真, , ocode))


.子程序 _imm8, 字节集, , opcode_imm8
.参数 opcode, 字节型, , 
.参数 imm8, 短整数型, , 

.局部变量 code, 字节集, , , 

赋值 (code, 相加 (opcode, 到字节集 (imm8)))
EASM_AddCode (code)
返回 (code)

.子程序 acc_imm, 字节集, , opcode_imm
.参数 opcode, 字节型, , 
.参数 w, 字节型, , 
.参数 imm, 整数型, , 

.局部变量 code, 字节集, , , 
.局部变量 p1, 字节型, , , 
.局部变量 pb1, 字节集, , , 

.判断开始 (等于 (w, #w_byte))
    赋值 (pb1, 到字节集 (到字节 (imm))) ' 操作8位
.判断 (等于 (w, #w_word))
    赋值 (pb1, 到字节集 (到短整数 (imm))) ' 操作16位
    赋值 (code, { 102 }) ' 66,标识是操作16位
    赋值 (w, 1)
.默认
    赋值 (pb1, 到字节集 (imm)) ' 操作32位
.判断结束
赋值 (p1, 相加 (opcode, w))
赋值 (code, 相加 (code, 到字节集 (p1), pb1))
EASM_AddCode (code)
返回 (code)

.子程序 Addsss, 空白型, , 
.参数 sss, 字节型, , 

EASM_AddCode (到字节集 (sss))


.子程序 reg1632_mem1632, 字节集, , 
.参数 opcode, 字节型, , 
.参数 reg1, 字节型, , 
.参数 reg2, 字节型, 可空, 
.参数 mem32, 整数型, 可空, 
.参数 imm, 整数型, 可空, 
.参数 w, 逻辑型, 可空, 
.参数 reg3, 字节型, 可空, 
.参数 sib, 字节型, 可空, 

.局部变量 t, 整数型, , , 
.局部变量 code, 字节集, , , 

.判断开始 (等于 (w, 真))
    赋值 (t, 2)
.默认
    赋值 (t, 1)
.判断结束

.判断开始 (是否为空 (mem32))
    .判断开始 (并且 (等于 (是否为空 (imm), 假), 是否为空 (reg3)))
        .判断开始 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
            赋值 (code, reg_reg (相减 (opcode, 1), t, #reg_disp8_oo, reg1, reg2, imm, , , , , ocode))
        .默认
            赋值 (code, reg_reg (相减 (opcode, 1), t, #reg_disp32_oo, reg1, reg2, imm, , , , , ocode))
        .判断结束
        
    .判断 (是否为空 (imm))
        赋值 (code, reg_reg (相减 (opcode, 1), t, #m_reg_oo, reg1, #esp, , reg3, reg2, , sib, ocode))
    .判断 (并且 (大于或等于 (imm, -128), 小于或等于 (imm, 127)))
        赋值 (code, reg_reg (相减 (opcode, 1), t, #reg_disp8_oo, reg1, #esp, , reg3, reg2, , sib, ocode))
    .默认
        赋值 (code, reg_reg (相减 (opcode, 1), t, #reg_disp32_oo, reg1, #esp, imm, reg3, reg2, , sib, ocode))
    .判断结束
    
.默认
    赋值 (code, reg_reg (相减 (opcode, 1), t, #m_reg_oo, reg1, #ebp, mem32, , , , , ocode))
.判断结束
返回 (code)


.程序集 标签处理, , , 

.子程序 加入标签, 空白型, , 
.参数 Name, 文本型, , 
.参数 Offset, 整数型, , 
.参数 opcode, 文本型, , 




 ' 不属于任何一个程序集、类模块的函数：
